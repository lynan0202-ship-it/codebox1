/* 
intconv.c -- 演示“转换说明与类型不匹配”的问题（按教程思路注释）
核心目标：理解 %hd/%hu/%c 等格式与 short/unsigned short/char 类型不匹配时的风险
*/
#include <stdio.h>
// 定义常量，模拟实际场景中的数值
#define PAGES 336  
#define WORDS 65618

int main(void)
{
    // 1. 用 short 类型存储 PAGES（336）
    short num = PAGES;        
    // 2. 用 short 类型存储 -PAGES（-336）
    short mnum = -PAGES;      

    // 3. 演示 1：short 类型用 %hd（有符号）和 %hu（无符号）输出
    //    - %hd：按“有符号 short”解析，输出 336（正确）
    //    - %hu：按“无符号 short”解析，输出 336（正确，因为 num 本身是正数）
    printf("num as short and unsigned short: %hd %hu\n", num, num);

    // 4. 演示 2：负数 short 类型用 %hd（有符号）和 %hu（无符号）输出
    //    - %hd：按“有符号 short”解析，输出 -336（正确）
    //    - %hu：按“无符号 short”解析，因补码规则，-336 被当成无符号数 65200（错误，但符合底层存储逻辑）
    printf("-num as short and unsigned short: %hd %hu\n", mnum, mnum);

    // 5. 演示 3：short 类型用 %d（int）和 %c（char）输出
    //    - %d：按“int”解析，short 自动提升为 int，输出 336（正确）
    //    - %c：按“char”解析，只取 short 低 8 位（336 的低 8 位是 80，对应 ASCII 字符 'P'）
    printf("num as int and char: %d %c\n", num, num);

    // 6. 演示 4：int 类型（WORDS）用 %d（int）、%hd（short）、%c（char）输出
    //    - %d：按“int”解析，输出 65618（正确）
    //    - %hd：按“short”解析，因 WORDS（65618）超过 short 范围（假设 short 是 2 字节，最大 32767），发生截断
    //    - %c：按“char”解析，只取低 8 位（65618 的低 8 位是 82，对应 ASCII 字符 'R'）
    printf("WORDS as int, short, and char: %d %hd %c\n", WORDS, WORDS, WORDS);

    return 0;
}

/*
num as short and unsigned short: 336 336
-num as short and unsigned short: -336 65200
num as int and char: 336 P
WORDS as int, short, and char: 65618 82 R
*/



/*



要理解 **补码规则** 为何让 `-336` 被解析为无符号数 `65200`，我们可以拆解为 **3步核心逻辑**（以 **16位 short 类型** 为例，因为早期 C 中 `short` 通常占 2 字节 = 16 位 ）：  


### 1. 补码的本质：计算机如何存负数？  
计算机用 **二进制补码** 统一存储**有符号整数**（正数、负数），核心规则：  
- **正数**：二进制直接存数值（如 `336` 的 16 位二进制是 `0000000101011000`）。  
- **负数**：通过「**绝对值取反 + 1**」生成补码（如 `-336` 的补码需计算）。  


### 2. 计算 `-336` 的 16 位补码  
对 16 位 `short` 类型，`-336` 的补码生成分 3 步：  

#### ① 求绝对值的二进制  
`336` 的 16 位二进制（不足 16 位前面补 `0`）：  
```binary
0000 0001 0101 1000   （即十进制 336）
```  

#### ② 逐位取反（反码）  
把每一位 `0` 变 `1`，`1` 变 `0`：  
```binary
1111 1110 1010 0111   （这是反码，还不是补码）
```  

#### ③ 加 `1` 得到补码  
反码 + `1`，最终补码：  
```binary
1111 1110 1010 1000   （这就是 `-336` 在 16 位 short 中的存储）
```  


### 3. 无符号解析：补码变“大正数”  
当用 **无符号数格式（如 `%hu`）** 解析这个补码时，计算机不再区分“符号位”，**把所有二进制位当“数值位”**：  

#### ① 补码的无符号值计算  
16 位无符号数的范围是 `0 ~ 65535`（`2^16 - 1`）。补码 `1111 1110 1010 1000` 对应的无符号值，可通过公式简化：  
```
无符号值 = 2^16 - |负数的绝对值|  
```  
代入 `-336`，得：  
```
无符号值 = 65536 - 336 = 65200  
```  

#### ② 验证二进制值  
直接计算补码的二进制对应的十进制：  
```binary
1111 1110 1010 1000 = 2^15 + 2^14 + ... + 2^7 + 2^5 + 2^3  
```  
手动计算（或用计算器）会发现结果确实是 `65200`。  


### 总结：补码的“双面性”  
- 作为**有符号数**（`%hd`）：二进制 `1111 1110 1010 1000` 是 `-336`（最高位是符号位，1 表示负数）。  
- 作为**无符号数**（`%hu`）：二进制 `1111 1110 1010 1000` 是 `65200`（所有位都是数值位，无符号）。  

这就是补码的核心逻辑：**同一组二进制，因解析方式（有符号/无符号）不同，会被解读为完全不同的数值**
——这也是 C 语言中“类型匹配”特别重要的原因！*/

/*
要理解 **“低8位”**，需结合 **计算机数据存储的“二进制位、字节”底层逻辑** 与 **类型截断规则** 详细拆解，以下分步骤讲透：  


### 1. 先明确基础概念：**位（bit）与字节（byte）**  
- **1 字节（byte）= 8 位（bit）**：  
  计算机用二进制（`0`/`1`）存储数据，**8 个二进制位** 组成 1 个“字节”，是存储的最小可寻址单元。  
- **多字节类型的存储**：  
  像 `short`（通常 2 字节 = 16 位）、`int`（通常 4 字节 = 32 位），会占用连续的多个字节。  
  例如：`short num = 336` 在内存中占 **2 字节（16 位）**，`int WORDS = 65618` 占 **4 字节（32 位）**。  


### 2. 什么是“低8位”？  
“低8位”指一个数值的 **二进制表示中，最右侧的 8 个二进制位**（对应 1 字节）。  

可以简单理解为：  
**低8位 = 数值对 `256` 取余的结果**（因为 `2^8 = 256`，取余会保留最后 8 位的贡献）。  


### 3. 结合代码例子，逐行拆解“低8位”  

#### 例子 1：`short num = 336` 用 `%c` 输出  
`num` 是 `short` 类型（假设 2 字节 = 16 位），值为 `336`。  

##### 步骤 1：计算 `336` 的二进制（16 位）  
`336` 的十进制转二进制：  
```  
336 = 256（2^8） + 80（2^6 + 2^5 + 2^3）  
```  
对应 16 位二进制为：  
```binary  
0000 0001 0101 1000  
↑高8位       ↑低8位  
```  

##### 步骤 2：截断“低8位”  
`%c` 要求输出 `char` 类型（1 字节 = 8 位），因此 **只保留最右侧的 8 位**（低8位）：  
```binary  
0101 1000  （对应十进制 80）  
```  

##### 步骤 3：`80` 对应 ASCII 字符 `'P'`  
ASCII 表中，十进制 `80` 对应字符 `'P'`，因此输出 `P`。  


#### 例子 2：`int WORDS = 65618` 用 `%c` 输出  
`WORDS` 是 `int` 类型（假设 4 字节 = 32 位），值为 `65618`。  

##### 步骤 1：计算 `65618` 的二进制（32 位）  
`65618` 的十进制转二进制，核心看 **低8位**：  
```  
65618 ÷ 256 = 256 余 82（因为 256×256 = 65536，65618 - 65536 = 82）  
```  
因此，`65618` 的 **低8位** 是 `82` 的二进制：  
```binary  
0101 0010  （对应十进制 82）  
```  

##### 步骤 2：`82` 对应 ASCII 字符 `'R'`  
ASCII 表中，十进制 `82` 对应字符 `'R'`，因此输出 `R`。  


### 4. 本质：类型截断的“取低字节”规则  
当用更小类型（如 `char`）解析更大类型（如 `short`/`int`）时，**只保留“低字节”（低8位、低16位等）**，高位直接丢弃。  

- 从 `short`（2 字节）转 `char`（1 字节）：丢弃高8位，保留低8位。  
- 从 `int`（4 字节）转 `char`（1 字节）：丢弃高24位，保留低8位。  


### 5. 一句话总结  
“低8位”是数值二进制表示中 **最右侧的 8 个二进制位**，对应十进制是数值对 `256` 取余的结果。当用 `%c` 输出多字节类型时，会**截断只保留低8位**，并将其解释为 ASCII 字符。  

（拓展：若系统是“大端序”存储，字节顺序会反过来，但截断规则仍保留“低地址的字节”，本质仍是取“低8位”的逻辑～）
*/