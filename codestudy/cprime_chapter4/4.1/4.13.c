/* 
floatcnv.c -- 演示“浮点与整数类型不匹配”的问题（结合参数传递深度注释）
核心目标：通过参数传递机制，理解格式不匹配时的二进制解析错误
*/
#include <stdio.h>

int main(void)
{
    // 1. 定义不同类型变量（注意：类型决定了参数传递时的栈占用）
    float n1 = 3.0;       // float（4字节）→ 传递时会被自动提升为 double（8字节，占栈8字节）
    double n2 = 3.0;      // double（8字节，占栈8字节）
    long n3 = 2000000000; // long（假设4字节，占栈4字节）
    long n4 = 1234567890; // long（4字节，占栈4字节）

    // 2. 演示 1：用 %le（浮点）输出所有类型 → 涉及「类型提升 + 错误解析」
    //    底层逻辑（参数传递视角）：
    //    - n1（float）→ 提升为 double（8字节），按浮点格式解析 ✔️（输出 3.0e+00）
    //    - n2（double）→ 直接按浮点格式解析 ✔️（输出 3.0e+00）
    //    - n3（long）→ 占栈4字节，printf 用 %le 读取时，会额外读取相邻4字节（共8字节）
    //      → 这8字节是随机栈数据 + n3 的值，被错误解析为浮点数（输出 3.1e+46 这类无意义值） ❌
    //    - n4（long）→ 同理，占栈4字节，被错误读取8字节解析为浮点数（输出 1.7e+266 这类无意义值） ❌
    printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);

    // 3. 演示 2：用 %ld（整数）输出 long 类型 → 正确匹配
    //    底层逻辑（参数传递视角）：
    //    - n3、n4 都是 long（4字节），%ld 要求读取4字节整数补码 ✔️
    //    → 直接按 long 类型解析，输出原值 2000000000 和 1234567890 ✔️
    printf("%ld %ld\n", n3, n4);

    // 4. 演示 3：用 %ld（整数）输出 float/double 类型 → 涉及「跨类型栈读取」
    //    底层逻辑（参数传递视角）：
    //    - n1（double 形式传递，占栈8字节）→ %ld 要求读4字节，取前4字节解析为 long ❌
    //      → 3.0 的 double 存储是 0x4008000000000000 → 前4字节是 0x40080000 → 解析为 1074266112（随机值）
    //    - n2（double，占栈8字节）→ %ld 读4字节，取前4字节（同样是 0x40080000 ）→ 解析为 1074266112（随机值） ❌
    //    - n3、n4 → 正确读4字节，输出原值 ✔️
    //    → 结果：前两个输出是随机错误值，后两个是正确 long 值
    printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);

    return 0;
}
/*
3.0e+000 3.0e+000 9.9e-315 6.1e-315
2000000000 1234567890
0 0 2000000000 1234567890
*/