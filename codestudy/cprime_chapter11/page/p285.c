// ------------------------------
// 知识要点总结：
//  1. fgets 函数：从输入流（如键盘）读取一行，最多存储 STLEN-1 个字符（剩余1位存'\0'），会保留输入的换行符 '\n'。  
//  2. fputs 函数：将字符串输出到屏幕，不会自动添加换行符（但因 fgets 保留了'\n'，实际输出会换行）。  
//  3. 循环结束条件：  
//     - fgets 返回非NULL → 未到文件末尾（如 Ctrl+D/Ctrl+Z）；  
//     - words[0] != '\n' → 输入不是空行（首字符不是换行符）。  
//  4. 输入截断：若输入超长，fgets 会分多次读取，每次读满 STLEN-1 个字符，直到读完换行或文件结束。  
// 总体逻辑说明：  
//  1. 定义字符数组 words 存储输入，提示用户“输入空行可退出”。  
//  2. 循环读取输入：用 fgets 读入 words，若读取成功且非空行，就用 fputs 输出内容。  
//  3. 当读取到空行或文件结束时，退出循环，输出“Done.”。  

#include <stdio.h>
#define STLEN 10  // 数组总长度：9个有效字符 + 1个'\0'

int main(void)
{
    char words[STLEN];  // 分配空间，存用户输入的字符串

    puts("Enter strings (empty line to quit):");  // 提示用户如何退出

    // 循环逻辑：
    // - fgets(words, STLEN, stdin)：从键盘读一行，最多存9个字符到words
    // - != NULL：没读到文件末尾（比如按了Ctrl+D）
    // - words[0] != '\n'：输入不是空行（直接按回车）
    while (fgets(words, STLEN, stdin) != NULL && words[0] != '\n')
    {
        fputs(words, stdout);  // 输出读取的内容：因为fgets保留了'\n'，所以输出会换行
    }

    puts("Done.");  // 循环结束，提示程序结束

    return 0;
}

// ------------------------------
// 测试验证建议方案：  
//  1. 正常短输入测试：  
//     - 运行程序，输入 "Hello"（长度5），按回车。  
//     - 预期：输出 "Hello" 并换行，程序继续等待新输入。  
//  2. 超长输入测试（如 "1234567890123"，长度13）：  
//     - 输入后按回车，观察输出：  
//       - 第一次读 "123456789"（9个字符），输出后，下一行读 "0123\n"（剩余内容），继续输出。  
//  3. 空行测试：  
//     - 直接按回车，预期立即输出 "Done."，程序结束。  
//  4. EOF 测试（Linux/Mac按Ctrl+D，Windows按Ctrl+Z+回车）：  
//     - 输入几行后触发EOF，预期输出 "Done."，程序结束。  

// ------------------------------
// 易错点提醒：  
//  1. 数组长度算错：STLEN是10，但实际只能存9个有效字符（最后一位必须给'\0'），输入第10个字符会被截断。  
//  2. 换行符残留：fgets会把'\n'存到数组里，若输入空行，words[0]就是'\n'，直接退出循环。  
//  3. fputs换行误解：以为fputs会自动换行，其实是因为fgets保留了'\n'才换行；若输入被截断（没读到'\n'），输出会和下一次内容连在一起。  

// ------------------------------
// 拓展思考：  
//  1. 去除换行符：想让输出更整洁？可以在fputs前删掉'\n'：  
//     ```c
//     for (int i = 0; i < STLEN; i++) {
//         if (words[i] == '\n') {
//             words[i] = '\0';  // 把换行符换成结束符
//             break;
//         }
//     }
//     ```  
//  2. 处理截断残留：输入超长时，残留字符会干扰后续读取，可添加清空代码：  
//     ```c
//     if (words[strcspn(words, "\n")] != '\n') {  // 没读到换行符 → 输入被截断
//         int c;
//         while ((c = getchar()) != '\n' && c != EOF);  // 读掉残留字符
//     }
//     ```  
//  3. 对比fgets和gets：  
//     - gets没有长度限制，容易溢出崩溃；fgets更安全，但需要处理换行和截断问题。  