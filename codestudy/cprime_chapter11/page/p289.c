/* 
代码名称：put_out.c（教材程序清单11.12，演示puts()正确用法）
知识要点总结：
1. puts() 核心特性：输出字符串内容，并自动在末尾追加换行符 
2. 入参类型支持：字符串常量（双引号）、字符数组名（隐式转地址）、字符指针、指针运算结果（如&str[5]、ptr+4）
3. 字符串终止条件：必须以 '\0' 结尾，puts() 遇到 '\0' 才停止输出 
4. 宏定义的本质：#define 定义的字符串是编译期替换的常量，等价于字符串字面量的地址 

代码总体逻辑：
1. 构建四种字符串形式：
   - 字符数组 str1：初始化时编译器自动补充 '\0' 
   - const 指针 str2：指向只读的字符串常量（末尾自带 '\0'） 
   - 宏 DEF：预处理阶段替换为字符串常量 
   - 字符串字面量：直接传入 puts() 的双引号内容 
2. 通过 puts() 演示不同入参的输出：
   - 直接输出字面量、宏、数组、指针 
   - 用指针运算（&str1[5]、str2+4）展示"从指定位置开始输出"的效果 
3. 利用 puts() 自动换行的特性，使每个输出项独占一行 
*/

#include <stdio.h>
#define DEF "I am a #defined string."  // 宏定义的字符串常量（末尾隐含 '\0'）

int main(void)
{
    // 字符数组初始化：编译器自动在末尾加 '\0'，长度80（实际用了27字节+1个'\0'）
    char str1[80] = "An array was initialized to me.";  
    // 指针指向字符串常量（存储在只读区，末尾有 '\0'）
    const char *str2 = "A pointer was initialized to me.";  

    // 1. 输出字符串字面量（直接传双引号内容，地址是首字符地址）
    puts("I'm an argument to puts().");  
    // 2. 输出宏定义（DEF替换为字符串，等价于直接传字面量）
    puts(DEF);  
    // 3. 输出字符数组（str1是数组名，代表首地址，指向第一个字符 'A'）
    puts(str1);  
    // 4. 输出字符指针（str2指向字符串首字符 'A'）
    puts(str2);  

    // 5. 指针运算：&str1[5] 是str1第6个字符的地址（索引从0开始）
    //    原str1: "An array..." → 前5个字符是 'A','n',' ','a','r' → 第6个是 'r'，输出 "ray was initialized to me."
    puts(&str1[5]);  

    // 6. 指针运算：str2+4 跳过前4个字符（'A',' ','p','o'），从 'i' 开始
    //    原str2: "A pointer..." → 第5个字符是 'i'，输出 "inter was initialized to me."
    puts(str2 + 4);  

    return 0;
}


/* 
代码名称：nono.c（教材程序清单11.13，演示puts()错误用法：无'\0'的字符数组）
知识要点总结：
1. 字符串的本质：以 '\0' 结尾的字符序列；若字符数组没 '\0'，只是普通字符集合（不是字符串） 
2. puts() 的风险：传入非字符串（无'\0'）时，会持续输出内存内容，直到遇到某个 '\0'（行为随机，依赖内存布局） 
3. 内存布局影响：编译器决定数组的存储顺序，导致乱码内容不确定（示例中dont紧邻side_a，输出包含side_a内容） 

代码总体逻辑：
1. 定义三个字符数组：
   - side_a、side_b：正确的字符串（初始化时自动加 '\0'） 
   - dont：手动初始化4个字符，**未加 '\0'**（不是字符串） 
2. 用 puts() 输出 dont：因无 '\0'，puts会从dont首地址开始，遍历内存直到找到 '\0'（通常是后面side_a的 '\0'） 
3. 观察输出乱码，验证"非字符串传入puts()"的危害 
*/

#include <stdio.h>

int main(void)
{
    char side_a[] = "Side A";  // 末尾自动加 '\0'，是字符串（长度6：'S','i','d','e',' ','A','\0'）
    // 字符数组：仅存4个字符 'W','O','W','!'，**无 '\0'**（不是字符串！）
    char dont[] = { 'W', 'O', 'W', '!' };  
    char side_b[] = "Side B";  // 末尾自动加 '\0'，是字符串（长度6）

    // 危险操作：puts接收的不是字符串（无'\0'），会输出dont内容 + 后续内存数据，直到遇到'\0'
    puts(dont);  

    return 0;
}


/* 
==================== put_out.c 测试方案 ====================
1. 基础验证：
   - 编译运行，检查输出是否与教材一致（每行一个字符串，最后两行分别是 "ray was initialized to me." 和 "inter was initialized to me."） 
   - 观察指针运算的效果：修改 &str1[5] 为 &str1[0]，输出应和直接puts(str1)一致 

2. 边界测试：
   - 将 str2+4 改为 str2+100（超出字符串长度），观察输出是否包含乱码（直到遇到内存中的'\0'） 
   - 给 str1 赋值超过80字符（测试数组溢出，编译器可能报警，理解数组大小的重要性） 

3. 对比实验：
   - 用 printf("%s\n", ...) 替换 puts()，观察输出是否一致（验证puts自动换行的特性） 
   - 将 str2 改为非const指针（char *str2 = ...），尝试修改str2内容（会触发段错误，理解字符串常量的只读属性） 

==================== nono.c 测试方案 ====================
1. 乱码验证：
   - 编译运行，观察输出（示例可能是"WOW!Side A"，但结果因编译器/系统而异） 
   - 注释掉 side_a 和 side_b，重新运行，观察输出是否变短（内存中随机'\0'的位置变化） 

2. 修复验证：
   - 给 dont 手动添加 '\0'：char dont[] = { 'W','O','W','!', '\0' };，重新运行，输出应为"WOW!"（验证'\0'的作用） 
   - 交换 dont 和 side_a 的定义顺序，重新运行，观察乱码内容变化（验证内存布局的影响） 

3. 风险认知：
   - 尝试将 dont 定义为局部变量（如在main里定义），对比全局变量的输出差异（局部变量内存初始化为随机值，乱码更明显） 

==================== 通用易错点提醒 ====================
1. 指针运算别越界：str2+100 可能访问非法内存，导致程序崩溃（虽然puts会停在'\0'，但风险极高） 
2. 字符数组初始化：用大括号时，必须手动加'\0'（如 dont[] = { 'W','O','W','!', '\0' }），否则不是字符串 
3. 宏定义的坑：DEF是字符串常量，若写 #define DEF 'A'（单引号），会导致编译错误（puts需要字符串地址，而非字符） 
4. puts和printf区别：puts自动换行，printf("%s")不换行，需手动加\n 
*/