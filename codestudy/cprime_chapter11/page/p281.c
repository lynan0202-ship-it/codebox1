// ------------------------------
// 知识要点总结：
//  1. 字符串本质："Don't be a fool!" 是**静态区的字符串常量**，`mesg` 是指向它的指针（存静态区地址）。  
//  2. 指针赋值：`copy = mesg` 是**地址拷贝**（copy和mesg指向同一块静态内存），不是字符串内容拷贝。  
//  3. 地址区分：  
//     - `&mesg`：指针变量 `mesg` 本身在**栈区的地址**（存储指针的容器地址）；  
//     - `mesg`：指针 `mesg` **指向的字符串在静态区的地址**（字符串内容的首地址）。  
//  4. printf 格式：  
//     - `%s`：输出指针指向的字符串（从地址开始到 `\0`）；  
//     - `%p`：输出指针存储的地址（十六进制，带 `0x` 前缀）。  
// 总体逻辑说明：  
//  1. 定义字符串指针 `mesg`，指向静态区的字符串常量。  
//  2. 定义空指针 `copy`，将 `mesg` 的地址赋给 `copy`（两者指向同一字符串）。  
//  3. 用 `printf` 分别输出：  
//     - 字符串内容（验证 `copy` 和 `mesg` 指向相同内容）；  
//     - 指针变量自身的地址（`&mesg`、`&copy`，在栈区，地址不同）；  
//     - 指针指向的地址（`mesg`、`copy`，都指向静态区，地址相同）。  


#include <stdio.h>

int main(void) {
    // 定义指针 mesg，指向静态区的字符串常量（内容："Don't be a fool!"）
    const char *mesg = "Don't be a fool!";  
    const char *copy;  // 定义空指针，准备接收地址

    // 关键操作：让 copy 指向 mesg 指向的地址（地址拷贝，不是内容拷贝！）
    copy = mesg;  

    // 1. 输出字符串内容：copy 和 mesg 都指向同一字符串，所以输出相同
    printf("%s\n", copy);  

    // 2. 打印 mesg 的三个信息：
    //    - %s：mesg 指向的字符串内容；
    //    - %p：mesg 变量本身在栈区的地址（存储指针的容器地址）；
    //    - %p：mesg 指向的字符串在静态区的地址（内容首地址）。
    printf("mesg = %s; &mesg = %p; value = %p\n", mesg, &mesg, mesg);  

    // 3. 打印 copy 的三个信息：
    //    - %s：copy 指向的字符串（和 mesg 相同，因为地址一样）；
    //    - %p：copy 变量本身在栈区的地址（和 &mesg 不同，因为是两个不同的指针变量）；
    //    - %p：copy 指向的地址（和 mesg 相同，因为 copy = mesg）。
    printf("copy = %s; &copy = %p; value = %p\n", copy, &copy, copy);  

    return 0;
}


// ------------------------------
// 测试验证建议方案：  
//  1. 编译运行：  
//     - 保存为 `p_and_s.c`，执行命令 `gcc p_and_s.c -o p_and_s && ./p_and_s`（Linux/Mac），或在编译器中直接运行（Windows）。  
//  2. 预期结果：  
//     - 第一行输出：`Don't be a fool!`（字符串内容）；  
//     - 第二行和第三行的 `%s` 部分都为 `Don't be a fool!`；  
//     - 第二行的 `&mesg` 和第三行的 `&copy` 地址**不同**（因为是两个不同的指针变量，存在栈区不同位置）；  
//     - 第二行的 `value` 和第三行的 `value` 地址**相同**（因为都指向静态区的同一字符串）。  
//  3. 检查点：  
//     - 对比 `&mesg` 和 `&copy`：确认是不同地址（栈区的两个变量）；  
//     - 对比 `mesg` 和 `copy` 的 `value`：确认是相同地址（静态区的同一字符串）。  

// ------------------------------
// 易错点提醒：  
//  1. 混淆“指针变量的地址”和“指针指向的地址”：  
//     - `&mesg` 是指针本身的地址（栈区），`mesg` 是指针指向的地址（静态区），两者完全不同！  
//  2. 误以为指针赋值是“内容拷贝”：  
//     - `copy = mesg` 只是让 copy 指向 mesg 的地址，**没有拷贝字符串内容**！如果修改 `*copy` 会崩溃（因为字符串常量是只读的）。  
//  3. 格式符误用：  
//     - 用 `%p` 输出指针地址，若编译器报错，可尝试 `%u` 或 `%lu`（但推荐优先支持 `%p` 的编译器）。  

// ------------------------------
// 拓展思考：  
//  1. 尝试修改字符串内容：  
//     → 写 `*mesg = 'X';`，编译运行会崩溃（静态区字符串只读，不可修改）。  
//  2. 对比数组和指针的赋值：  
//     → 定义 `char arr[] = "Hello"; char *p = arr;`，观察 `&arr`（数组首地址，也是数组名的地址）和 `p`（指向 arr 的地址）的关系，体会数组名是“地址常量”，指针是“地址变量”。  
//  3. 验证字符串复用：  
//     → 定义 `const char *s1 = "Hi"; const char *s2 = "Hi";`，打印 `s1` 和 `s2` 的 `value` 地址，看是否相同（编译器可能复用同一字符串的静态区地址）。  