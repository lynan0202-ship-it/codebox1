// ------------------------------
// 知识要点总结：
//  1. 字符串常量本质：以 '\0' 结尾的字符序列，存储在**静态内存区**，名字是首字符的**指针**。
//  2. printf 格式符：
//     - %s：从指针位置输出字符，直到遇到 '\0'；
//     - %p：输出指针存储的**内存地址**（十六进制，带 0x 前缀）；
//     - %c：输出指针**解引用后的值**（单个字符）。
//  3. 指针解引用：*"字符串" 等价于访问字符串的**首字符**（如 *"abc" → 'a'）。
// 总体逻辑说明：
//  通过一次 printf 调用，同时测试三个特性：  
//  - 用 %s 输出字符串内容；  
//  - 用 %p 输出字符串常量的首地址；  
//  - 用 *"字符串" 解引用获取首字符，通过 %c 输出。  

#include <stdio.h>

int main(void) {
    // printf 三个参数分别测试：
    // 1. "%s" → 输出 "We" 整个字符串（从首地址到 '\0'）；
    // 2. "%p" → 输出 "are" 的首地址（字符串常量名就是地址）；
    // 3. "%c" → 解引用 "space farers"，取第一个字符 's'（*"space..." 等价于访问首字符）。
    printf("%s, %p, %c\n", "We", "are", *"space farers");
    
    return 0;
}

// ------------------------------
// 代码测试及验证建议方案：
//  1. 编译运行：  
//     - 保存为 `strptr_demo.c`，执行命令：`gcc strptr_demo.c -o demo`（Linux/Mac），或用编译器直接编译（Windows）；  
//     - 运行生成的程序：`./demo`（Linux/Mac）或双击 `demo.exe`（Windows）。  
//  2. 预期结果：  
//     - 输出格式：`We, 0xXXXXXXXX, s`（`0xXXXXXXXX` 是 "are" 的首地址，每次运行地址可能不同，但一定是**十六进制格式**）。  
//  3. 检查验证：  
//     - 确认 `%s` 输出 "We"（完整字符串）；  
//     - 确认 `%c` 输出 's'（"space farers" 的首字符）；  
//     - 观察 `%p` 输出的地址（只要以 `0x` 开头，即为合法内存地址，逻辑正确）。  

// ------------------------------
// 易错点提醒：  
//  1. 格式符混用：若将 `%p` 写成 `%s` 输出 "are"，会打印字符串内容而非地址，导致逻辑错误；  
//  2. 解引用误解：`*"space farers"` 只取**首字符**，若想输出整个字符串，仍需用 `%s`；  
//  3. 地址变化：每次运行程序，"are" 的地址可能不同（系统动态分配内存），属正常现象。  

// ------------------------------
// 拓展思考：  
//  1. 字符串复用测试：  
//     → 定义 `const char *s1 = "hi"; const char *s2 = "hi";`，打印 `s1` 和 `s2` 的 `%p`，观察地址是否相同（多数编译器会复用相同字符串的内存，地址一致）；  
//  2. 解引用任意位置：  
//     → 尝试 `*(("space farers") + 5)`，输出第 6 个字符（'f'，因为下标从 0 开始）；  
//  3. 数组 vs 常量对比：  
//     → 定义 `char arr[] = "are";`，打印 `arr` 和 `"are"` 的 `%p`，观察**栈区（数组）**和**静态区（常量）**的地址差异。  