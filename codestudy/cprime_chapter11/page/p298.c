/*
代码名称：compback.c
知识要点总结：
1. strcmp函数返回规则：  
   - 相等→0；第1个字符串ASCII序在前→负数；第1个在后→正数  
   - 返回值具体数值由编译器实现（通常是首对不同字符的ASCII差）  
2. 比较逻辑：逐字符对比ASCII值，直到发现不同字符或到达字符串末尾（'\0'）  
3. 核心区分：strcmp比较**字符串**（需以'\0'结尾），单个字符用关系运算符（如==、<）  

代码总体逻辑：  
通过6组字符串对比，调用strcmp并打印结果，直观展示：  
- 相等/不等时的返回特性  
- 大小写、长度、字符顺序对结果的影响  
- 不同编译器下返回值的差异（如-1/1 vs ASCII差值）  
*/

#include <stdio.h>      // 提供printf函数
#include <string.h>     // 提供strcmp函数原型

int main(void)
{
    // 测试1：完全相同的字符串 → 返回0
    printf("strcmp(\"A\", \"A\") is ");
    printf("%d\n", strcmp("A", "A"));  

    // 测试2："A"和"B" → 'A'(65) < 'B'(66) → 返回负数（如-1或-1的差值）
    printf("strcmp(\"A\", \"B\") is ");
    printf("%d\n", strcmp("A", "B"));  

    // 测试3："B"和"A" → 'B'(66) > 'A'(65) → 返回正数（如1或1的差值）
    printf("strcmp(\"B\", \"A\") is ");
    printf("%d\n", strcmp("B", "A"));  

    // 测试4："C"和"A" → 'C'(67) > 'A'(65) → 返回正数（如2或2的差值）
    printf("strcmp(\"C\", \"A\") is ");
    printf("%d\n", strcmp("C", "A"));  

    // 测试5："Z"和"a" → 'Z'(90) < 'a'(97) → 返回负数（如-7或-7的差值）
    // 注意：ASCII中大写字母在小写字母前面，所以Z比a小
    printf("strcmp(\"Z\", \"a\") is ");
    printf("%d\n", strcmp("Z", "a"));  

    // 测试6："apples"和"apple" → 前5字符相同，第6位：
    // "apples"是's'(115)，"apple"是'\0'(0) → 115>0 → 返回正数（如115或1的差值）
    printf("strcmp(\"apples\", \"apple\") is ");
    printf("%d\n", strcmp("apples", "apple"));  

    return 0;
}

/*
代码测试及验证建议方案：
1. 基础运行验证：  
   - 编译运行（如gcc compback.c -o compback），观察输出值，对比教材示例，理解“返回值依赖实现”。  
   - 记录GCC、MSVC等不同编译器的输出差异（如有的返回-1/1，有的返回ASCII差值）。  

2. 拓展场景测试：  
   - 空字符串：测试strcmp("", "a")、strcmp("a", "")，分析返回值（空字符串视为0，比'a'小）。  
   - 长度差异：如"banana"和"banan"，观察返回值（类似apples/apple的逻辑）。  
   - 特殊字符：测试数字（"123"和"12"）、符号（"@"和"!"），结合ASCII表分析结果。  

3. 易错点验证：  
   - 错误用法：尝试strcpy('A', 'B')（编译器报错），理解“字符串指针 vs 字符”的区别。  
   - 对比测试：用'A' < 'B'（字符比较，正确）和strcmp("A","B")（字符串比较，返回负数），明确两种比较的适用场景。  

4. 原理探究：  
   - 计算测试用例的ASCII差值（如"Z"和"a"差90-97=-7），对比程序输出是否匹配。  
   - 思考：若字符串前n个字符相同，后续一个字符串更长（如"apple"和"apples"），strcmp如何处理？  
*/