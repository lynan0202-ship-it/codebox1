/* 
知识要点总结：
1. 掌握自定义字符串输入函数 s_gets 的实现逻辑，模仿 fgets 处理输入，同时优化换行符和超长输入的处理。
2. 理解 fgets 函数的返回值（读取成功返回缓冲区地址，失败/EOF返回NULL）。
3. 学会处理输入缓冲区残留的多余字符，避免影响后续输入读取。
4. 对比 gets（不安全，易缓冲区溢出）、fgets（保留换行符）、gets_s（可选，行为依赖实现）与自定义 s_gets 的差异。

代码总体逻辑说明：
1. s_gets 函数：
   - 第一步：调用 fgets 从标准输入（stdin）读取最多 n-1 个字符到 st 缓冲区（留一个位置给 '\0'）。
   - 第二步：检查 fgets 的返回值，若为 NULL 直接返回（表示读取失败或到文件尾）。
   - 第三步：遍历 st 中的字符，寻找换行符 '\n' 或字符串结束符 '\0'：
     - 若找到 '\n'，将其替换为 '\0'（去除换行符，让字符串更“干净”）。
     - 若没找到 '\n'（说明输入行超长），则循环调用 getchar() 丢弃缓冲区中多余的字符，直到遇到换行符或文件尾。
   - 第四步：返回 fgets 的返回值（同 st 的地址，或 NULL）。
2. 主函数测试：
   - 定义字符数组存储输入，循环调用 s_gets 读取输入，直到读取到 EOF（如键盘输入 Ctrl+Z/Ctrl+D）。
   - 每次读取后打印内容，验证是否正确处理了换行和超长情况。
*/

#include <stdio.h>

// 自定义字符串读取函数 s_gets，模仿 fgets 并优化换行符和超长输入处理
char *s_gets(char *st, int n) {
    char *ret_val;  // 存储 fgets 的返回值，用于判断读取是否成功
    int i = 0;      // 用于遍历字符串的索引

    // 1. 调用 fgets 读取数据：最多读 n-1 个字符（剩余1位存'\0'），从标准输入 stdin 读取
    ret_val = fgets(st, n, stdin);
    
    if (ret_val) {  // 如果读取成功（ret_val 不为 NULL，即没到文件尾且没出错）
        // 2. 遍历字符串，寻找换行符或字符串结束符
        while (st[i] != '\n' && st[i] != '\0') {
            i++;  // 移动索引，直到找到目标字符
        }

        if (st[i] == '\n') {  // 如果找到换行符（说明输入行长度 ≤ n-1）
            st[i] = '\0';     // 将换行符替换为字符串结束符，去掉换行
        } else {  // 没找到换行符（说明输入行超长，超过 n-1 个字符）
            // 3. 丢弃缓冲区中多余的字符，直到遇到换行符或文件尾
            while (getchar() != '\n') {  // getchar 逐个读字符，直到读到换行
                continue;  // 只要没读到换行，就一直读（丢弃）
            }
        }
    }

    return ret_val;  // 返回 fgets 的返回值（成功时是 st 的地址，失败时是 NULL）
}

int main() {
    char input[10];  // 定义输入缓冲区，大小为10（实际最多存9个有效字符 + '\0'）
    printf("请输入字符串（输入 Ctrl+Z/Ctrl+D 可结束输入）：\n");
    
    // 循环读取：只要 s_gets 返回非 NULL（即没到文件尾且没出错），就继续读取
    while (s_gets(input, 10) != NULL) {
        printf("你输入的内容：%s\n", input);  // 打印读取的内容，验证处理结果
    }

    printf("程序结束（已检测到输入结束或读取错误）\n");
    return 0;
}

/* 
代码测试及验证建议方案：
1. 正常长度输入测试（字符数 < 9）：
   - 输入：hello（回车），预期输出："你输入的内容：hello"（换行被替换，无多余换行）。
   - 输入：abc def（回车），预期：完整显示"abc def"，换行被替换。

2. 超长输入测试（字符数 ≥ 9）：
   - 输入：1234567890123（回车，共13个字符），预期缓冲区存"123456789"（9个字符），多余的"0123\n"被丢弃。
   - 测试后续输入：再输入"test"，应正常读取并输出"test"，验证缓冲区已被清空。

3. 空行测试：
   - 直接按回车，预期输出空字符串（因为换行符被替换为'\0'），程序继续等待输入。

4. 结束输入测试：
   - Windows：按 Ctrl+Z 再回车；Linux/Mac：按 Ctrl+D，预期循环结束，打印"程序结束..."。

5. 对比测试（理解差异）：
   - 替换 s_gets 为 fgets，输入"hello"，观察输出是否带换行（fgets 会存"hello\n\0"，输出会多一行空行）。
   - 尝试用 gets（编译器可能警告），输入超长内容（如20个字符），观察是否崩溃（对比 s_gets 的安全性）。

易错点提醒：
- 注意 s_gets 的参数 n 是缓冲区总大小，实际有效字符最多是 n-1 个（必须留位存'\0'）。
- 处理超长输入时，getchar 会清空缓冲区，避免残留字符影响下一次读取（比如后面用 scanf 读整数时，不会读到残留的字母）。
- fgets 返回 NULL 时，可能是文件尾或读取错误，主函数据此结束循环，需区分两种情况（可扩展代码判断错误，但示例中简化处理）。
*/