// ------------------------------
// 知识要点总结：
//  1. fgets 函数：从输入流（如 stdin）读取一行，最多存 `STLEN-1` 个字符（留 1 个位置给 '\0'），会保留输入的换行符 `\n`。  
//  2. fputs 函数：将字符串输出到流（如 stdout），**不会自动添加换行符**（与 puts 的区别：puts 会自动加换行）。  
//  3. 循环条件：  
//     - `fgets(...) != NULL`：判断是否读到文件结束（如 Ctrl+D/Ctrl+Z）或出错；  
//     - `words[0] != '\n'`：判断是否输入空行（首字符是换行符）。  
//  4. 输入截断：当输入长度超过 `STLEN-1` 时，fgets 会分多次读取，每次读满 `STLEN-1` 个字符（直到遇到换行或 EOF）。  
// 总体逻辑说明：  
//  1. 定义字符数组 `words` 存储输入，提示用户“空行退出”。  
//  2. 循环读取输入：用 fgets 读入 `words`，若读取成功且非空行，就用 fputs 输出到屏幕。  
//  3. 当读取到 EOF（如 Ctrl+D）或空行时，结束循环，输出“Done.”。  

#include <stdio.h>
#define STLEN 10  // 数组总长度：实际存储 STLEN-1 个字符 + 1 个 '\0'

int main(void)
{
    char words[STLEN];  // 定义字符数组，用于存放输入的字符串

    puts("Enter strings (empty line to quit):");  // 提示用户输入，空行可退出
    // 循环条件：
    // 1. fgets返回非NULL → 没到文件末尾/没出错；
    // 2. words[0] != '\n' → 输入不是空行（首字符不是换行符）
    while (fgets(words, STLEN, stdin) != NULL && words[0] != '\n')
    {
        fputs(words, stdout);  // 输出读取的字符串（fputs不会自动加换行，但输入的'\n'会保留，所以实际会换行）
    }

    puts("Done.");  // 循环结束，输出结束提示

    return 0;
}

// ------------------------------
// 测试验证建议方案：  
//  1. 正常输入测试：  
//     - 运行程序，输入短字符串（如 "Hello"，长度 < 9 ），按回车。  
//     - 预期：输入的字符串会原样输出（含换行），程序继续等待新输入。  
//  2. 长输入测试（超过 9 字符，如 "1234567890123" ）：  
//     - 输入后按回车，观察输出：  
//       - 第一次 fgets 读前 9 个字符（"123456789"），fputs 输出后，下一行继续读剩余的 "0123\n"（分多次读取，直到读完换行符）。  
//  3. 空行测试：  
//     - 直接按回车（输入空行），预期循环立即结束，输出 "Done."。  
//  4. EOF 测试（Linux/Mac 按 Ctrl+D，Windows 按 Ctrl+Z 再回车）：  
//     - 输入若干行后触发 EOF，预期循环结束，输出 "Done."。  

// ------------------------------
// 易错点提醒：  
//  1. 数组长度陷阱：`STLEN` 是数组总长度，实际能存的有效字符是 `STLEN-1`（最后一位必须给 '\0'），输入超过会被截断。  
//  2. 换行符残留：fgets 会把输入的 `\n` 也存到数组里，若输入空行，`words[0]` 就是 `\n`，直接触发退出。  
//  3. fputs 换行误解：fputs 本身不会加换行，但因为 fgets 保留了输入的 `\n`，所以输出时会“间接换行”；若输入被截断（没读到 `\n`），fputs 输出会和下一次内容拼接。  

// ------------------------------
// 拓展思考：  
//  1. 去除换行符：若想让输出更整洁，可在 fputs 前删除 `\n`：  
//     ```c
//     for (int i = 0; i < STLEN; i++) {
//         if (words[i] == '\n') {
//             words[i] = '\0';  // 把换行符换成结束符
//             break;
//         }
//     }
//     ```  
//  2. 处理截断残留：若输入超长，剩余字符会留在缓冲区，可通过循环清空：  
//     ```c
//     if (words[strcspn(words, "\n")] != '\n') {  // 没读到换行符 → 输入被截断
//         int c;
//         while ((c = getchar()) != '\n' && c != EOF);  // 读掉剩余字符
//     }
//     ```  
//  3. 对比 fgets 和 gets：  
//     - gets 无长度检查，极易溢出；fgets 安全但需处理换行和截断，实际开发优先用 fgets。  