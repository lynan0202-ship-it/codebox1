/*
代码名称：format.c（演示sprintf函数的格式化字符串功能）
知识要点总结：
1. 掌握sprintf函数：与printf类似，但将格式化结果存入字符串而非输出到屏幕
2. 理解自定义输入函数s_gets：处理fgets的换行符残留和缓冲区溢出问题
3. 学习字符串内存分配：根据内容复杂度规划数组大小（如formal需容纳两个名字+格式字符）
4. 实践格式控制符：
   - %s：字符串输出
   - %-19s：左对齐，占19个字符宽度
   - %6.2f：浮点数占6位，保留2位小数
   - 格式拼接：组合多个数据类型为统一字符串

代码总体逻辑说明：
1. 输入处理：
   - 调用s_gets读取名字和姓氏，自动清理换行符并处理超长输入
   - 用scanf读取奖金（double类型）
2. 格式化操作：
   - 通过sprintf将姓氏、名字（左对齐）、奖金（规范格式）拼接成一个字符串
   - 格式字符串："%s, %-19s: $%6.2f\n" 定义了拼接规则
3. 输出展示：打印格式化后的完整字符串
4. 辅助函数s_gets：
   - 封装fgets的调用，确保每个输入字符串正确终止（替换换行符或清理缓冲区）
   - 返回值用于判断输入是否有效（虽本例未用到，但保留通用设计）
*/

#include <stdio.h>
#define MAX 20  // 名字的最大长度（需留1位给'\0'，实际可输入19个字符）

// 自定义输入函数：处理换行符和超长输入
char *s_gets(char *st, int n);

int main(void)
{
    char first[MAX];          // 存储名字
    char last[MAX];           // 存储姓氏
    // formal数组大小计算：2*MAX（两个名字） + 逗号、空格、$、小数点等符号，10足够容纳格式字符
    char formal[2 * MAX + 10]; 
    double prize;             // 存储奖金

    puts("Enter your first name:");
    s_gets(first, MAX);  // 读取名字，自动处理换行符

    puts("Enter your last name:");
    s_gets(last, MAX);   // 读取姓氏

    puts("Enter your prize money:");
    scanf("%lf", &prize);  // 读取奖金（%lf对应double类型）

    // 核心操作：sprintf格式化
    // 格式解析：
    // %s：输出last字符串
    // , ：固定字符
    // %-19s：first左对齐，占19个字符宽度（不足补空格，超过则截断，因s_gets限制输入长度，此处实际不会超过）
    // : $ ：固定字符
    // %6.2f：prize占6位，保留2位小数（如25000→25000.00，占6位："25000.00"）
    // \n ：换行符
    sprintf(formal, "%s, %-19s: $%6.2f\n", last, first, prize);
    
    puts(formal);  // 输出格式化后的完整字符串

    return 0;
}

// s_gets函数实现：解决fgets的两个问题
// 1. 残留换行符→替换为'\0'
// 2. 输入超长→清理缓冲区剩余字符
char *s_gets(char *st, int n)
{
    char *ret_val;  // 保存fgets的返回值（用于判断输入是否有效）
    int i = 0;      // 索引，用于遍历字符串

    ret_val = fgets(st, n, stdin);  // 读取一行，最多n-1个字符（留1位给'\0'）
    if (ret_val) {  // 如果读取成功（非EOF或错误）
        // 寻找换行符或字符串结束符
        while (st[i] != '\n' && st[i] != '\0') {
            i++;
        }
        if (st[i] == '\n') {  // 如果是换行符（输入未超长）
            st[i] = '\0';     // 替换为字符串结束符
        } else {  // 输入超长（st[i]是'\0'，但缓冲区还有剩余字符）
            // 清理缓冲区，直到遇到换行符
            while (getchar() != '\n') {
                continue;
            }
        }
    }
    return ret_val;  // 返回读取结果（NULL表示输入结束或错误）
}

/*
代码测试及验证建议方案：
1. 正常功能测试：
   - 输入：Annie、von Wurstkasse、25000
   - 预期输出：von Wurstkasse, Annie           : $25000.00（注意Annie后有空格补到19位）
   - 检查格式：逗号、空格、$符号、小数点是否正确

2. 边界测试：
   - 名字长度=19（如first输入"ABCDEFGHIJKLMNOPQRS"），验证是否左对齐且无溢出
   - 奖金=0.01 → 输出$  0.01（占6位，前面补空格）；奖金=99999.99 → $99999.99（刚好6位）

3. 异常输入测试：
   - 输入超长名字（25个字符），观察s_gets是否清理缓冲区，后续输入是否正常
   - 输入非数字奖金（如"abc"），查看程序反应（可扩展错误处理，当前会因scanf失败导致异常，需注意）

4. 格式验证：
   - 姓氏超长（20个字符，如last输入"12345678901234567890"），s_gets会截断为19个字符+'\0'，检查输出是否截断
   - 奖金为负数（如-100.5），观察格式是否仍为6位（如$-100.50，占6位）

易错点提醒：
⚠️ sprintf的目标数组必须足够大！若formal尺寸不足（如2*MAX+5），可能导致缓冲区溢出（类似strcpy的安全问题）
⚠️ s_gets的n参数必须等于数组实际大小（如first[MAX]，n传MAX），否则可能越界
⚠️ 格式符%-19s中，19是"字段宽度"，不是"最大长度"——若输入字符串超过19位，会直接截断（但s_gets已限制输入长度，故本例中实际是"最大长度"）
⚠️ scanf读取double时用%lf，printf/sprintf中用%f（因double和float在printf中统一处理为double）
*/