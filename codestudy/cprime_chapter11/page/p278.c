// ------------------------------
// 知识要点总结：
//  1. 存储区域差异：  
//     - 字符串数组（`char ar[]`）：在**栈区**分配内存，拷贝静态区字符串内容。  
//     - 字符串指针（`const char *pt`）：在栈区存储**静态区字符串的地址**，自身是变量。  
//     - 字符串字面量（如`"I'm special"`）：存储在**静态区**，相同字面量可能被编译器复用（地址相同）。  
//  2. `const` 作用：保护静态区的只读数据，避免通过指针修改其内容（否则程序崩溃）。  
//  3. 地址特性：  
//     - 数组名是**地址常量**（不能修改指向，如`ar = pt;` 非法）；  
//     - 指针是**地址变量**（可修改指向，如`pt = ar;` 合法）。  
// 总体逻辑说明：  
//  通过定义数组、指针、宏和字符串字面量，打印它们的地址，对比 **栈区（数组）** 和 **静态区（指针、宏、字面量）** 的地址差异，验证字符串的存储特性。  

#include <stdio.h>
#define MSG "I'm special"  // 宏：静态区的字符串字面量

int main(void) {
    // 1. 数组形式：在栈区分配内存，拷贝 MSG 的内容（静态区字符串被复制到栈区）
    char ar[] = MSG;  

    // 2. 指针形式：pt 存储静态区中 MSG 的地址（pt 自身在栈区，指向静态区）
    const char *pt = MSG;  

    // 打印各种地址，观察差异（%p 输出十六进制地址）：
    printf("address of \"I'm special\": %p\n", "I'm special");  // 静态区的字符串字面量地址
    printf("address ar: %p\n", ar);  // 栈区的数组首地址（和静态区不同）
    printf("address pt: %p\n", pt);  // 静态区的地址（和 MSG、字面量相同）
    printf("address of MSG: %p\n", MSG);  // 宏展开为静态区地址，和 pt、字面量一致
    printf("address of \"I'm special\": %p\n", "I'm special");  // 同第一个，验证编译器复用

    return 0;
}

// ------------------------------
// 测试验证建议方案：
//  1. 编译运行：  
//     - 保存为 `addresses.c`，执行命令 `gcc addresses.c -o addr && ./addr`（Linux/Mac），或在编译器中直接运行（Windows）。  
//  2. 预期结果：  
//     - `"address of "I'm special""`、`"address of MSG"`、`"address pt"` 的地址 **相同**（静态区复用）；  
//     - `"address ar"` 的地址 **不同**（栈区分配，与静态区无关）。  
//  3. 检查点：  
//     - 观察前、后两个 `"I'm special"` 的地址是否一致（验证编译器对相同字面量的复用）；  
//     - 对比 `ar` 和 `pt` 的地址，确认栈区和静态区的地址范围差异（通常栈区地址更小，静态区地址更大，因系统内存布局而异）。  

// ------------------------------
// 易错点提醒：  
//  1. 数组是“拷贝”而非“引用”：  
//     - 修改 `ar[0] = 'U';` 只会改变栈区数组的内容，不会影响静态区的 `MSG`（因为是拷贝）。  
//  2. 指针的“指向” vs “内容”：  
//     - `pt` 是变量，可修改指向（如 `pt = ar;`，此时 `pt` 指向栈区数组），但不能修改静态区内容（如 `*pt = 'U';` 会崩溃，因 `pt` 指向 `const` 数据）。  
//  3. 字符串字面量的只读性：  
//     - 直接修改字面量（如 `*"I'm special" = 'X';`）会导致**未定义行为**（程序崩溃），需用 `const` 保护指针。  

// ------------------------------
// 拓展思考：  
//  1. 验证数组的“拷贝”特性：  
//     → 修改 `ar[0] = 'U';`，再次打印 `ar` 和 `MSG`，观察只有 `ar` 的内容变化（静态区 `MSG` 不受影响）。  
//  2. 验证指针的“可修改指向”：  
//     → 执行 `pt = ar;`，打印 `*pt`，观察输出 `ar` 的内容（如修改后的 `U'm special`）。  
//  3. 测试字面量复用：  
//     → 定义 `const char *s1 = "hi"; const char *s2 = "hi";`，打印 `s1` 和 `s2` 的地址，看是否相同（多数编译器会复用，地址一致）。  