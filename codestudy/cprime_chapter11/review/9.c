


// ------------------------------
// 题干：9. 本章定义的 s_gets() 函数，用指针表示法代替数组表示法便可减少一个变量 i。请改写该函数。  
// 原逻辑核心：安全读取一行，处理换行符和输入溢出，原实现用数组索引 i 遍历，现改用指针操作。  
// 知识要点：  
//  1. 指针遍历字符串：通过 `p++` 移动指针，`*p` 访问字符  
//  2. fgets 行为：读取到换行/EOF/满缓冲区，自动加 `\0`  
//  3. 输入清理：超长时用 getchar 清空缓冲区，避免影响后续输入  
// 总体逻辑：  
//  1. 调用 fgets 读取数据，保存返回值  
//  2. 若读取成功，用指针从数组首地址开始遍历，找换行符或结束符  
//  3. 找到换行符则替换为 `\0`，否则循环清理缓冲区  
//  4. 返回 fgets 的结果（标记读取状态）  
#include <stdio.h>

char *s_gets(char *st, int n) {
    char *ret_val = fgets(st, n, stdin);  // 尝试读取一行，最多存 n-1 字符（留1位给'\0'）
    if (ret_val) {  // 读取成功（非NULL，即使是空行也会返回st）
        char *p = st;  // 指针p指向数组起始位置，代替原代码的i=0
        
        // 遍历直到找到换行符（\n）或字符串结束符（\0，fgets自动添加）
        while (*p != '\n' && *p != '\0') {
            p++;  // 指针后移，逐个检查字符
        }
        
        if (*p == '\n') {  // 找到换行符：说明输入未超长，替换为\0
            *p = '\0';
        } else {  // 没找到换行符：说明输入超长，清理缓冲区剩余字符
            while (getchar() != '\n') {  // 循环读字符，直到遇到换行符
                continue;  // 丢弃多余字符，避免影响下次输入
            }
        }
    }
    return ret_val;  // 返回fgets的结果（NULL表示EOF或读取失败）
}

// 测试代码：验证s_gets的行为
int main(void) {
    char test_buf[10];  // 缓冲区大小10，最多存9个有效字符 + '\0'
    printf("测试1：输入短字符串（如\"abc\"，带换行）\n");
    s_gets(test_buf, 10);
    printf("读取内容：\"%s\"（长度：%zu）\n", test_buf, strlen(test_buf));
    
    printf("\n测试2：输入超长字符串（如\"123456789\"，共9字符+换行）\n");
    s_gets(test_buf, 10);
    printf("读取内容：\"%s\"（长度：%zu）\n", test_buf, strlen(test_buf));
    
    printf("\n测试3：输入EOF（Linux按Ctrl+D，Windows按Ctrl+Z回车）\n");
    if (!s_gets(test_buf, 10)) {
        printf("检测到EOF或读取失败\n");
    }
    
    return 0;
}

// ------------------------------
// 测试验证方案：  
//  1. 短输入测试：  
//     - 输入：`abc`（回车）  
//     - 预期：输出 `读取内容："abc"（长度：3）`（换行符被替换为\0）  
//  2. 超长输入测试：  
//     - 输入：`123456789`（回车，共9字符）  
//     - 预期：test_buf存`12345678`（前8字符），长度8；缓冲区剩余的`9`和换行被清理  
//  3. EOF测试：  
//     - 操作：Linux按Ctrl+D，Windows按Ctrl+Z再回车  
//     - 预期：输出 `检测到EOF或读取失败`  
//  4. 检查点：  
//     - 短输入后，换行符是否被正确替换（输出无换行，长度符合）。  
//     - 超长输入后，数组是否只存前n-1字符，且后续输入正常（可再调用s_gets验证）。  

// ------------------------------
// 易错点提醒：  
//  1. 指针未初始化：忘记`char *p = st;`，导致p乱指，程序崩溃。  
//  2. 循环条件错误：写成`while (*p != '\n' || *p != '\0')`（逻辑或），会导致死循环（永远满足一个条件）。  
//  3. 返回值误解：`s_gets`返回NULL仅表示EOF或读取错误，空行（如只输入换行）会返回非NULL（st存储`"\n"`，后续被替换为`"\0"`）。  

// ------------------------------
// 拓展思考：  
//  1. 如何让函数支持返回“是否发生了输入截断”？  
//     → 添加输出参数：`char *s_gets(char *st, int n, int *truncated)`，在清理缓冲区时设`*truncated=1`。  
//  2. 对比数组索引和指针版的性能：  
//     → 指针版更高效（硬件级地址运算），但数组索引对初学者更直观。  
//  3. 若fgets读取的字符串本身就有`\0`（极特殊情况），会怎样？  
//     → 遍历会在第一个`\0`处停止，视为“输入结束”，可能导致逻辑错误（实际应为二进制数据，非字符串场景）。  
