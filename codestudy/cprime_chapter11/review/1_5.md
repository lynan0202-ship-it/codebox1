

// ------------------------------
// 题干：1. 下面字符串的声明有什么问题？  
// int main(void) { char name[] = {'r','e','s','s'}; }  
// 知识要点：  
//  1. 字符串的定义：C语言中，字符串必须以 '\0'（空字符）结尾  
//  2. 字符数组 vs 字符串：字符数组存字符，若没有 '\0'，就不是字符串（无法用 %s 正确输出）  
// 总体逻辑：  
//  1. 定义题目中的字符数组，尝试用 %s 输出，观察结果  
//  2. 对比正确的字符串定义（添加 '\0' 或用双引号），看输出差异  
#include <stdio.h>

int main(void) {
    // 题目中的声明：字符数组存了4个字符，但没有 '\0'
    char name[] = {'r', 'e', 's', 's'};  
    // 正确的字符串声明（两种方式）：  
    char name_ok1[] = {'r', 'e', 's', 's', '\0'}; // 手动加 '\0'  
    char name_ok2[] = "ress"; // 双引号自动加 '\0'  

    printf("错误声明的输出（无\\0，会乱码）：%s\n", name);  
    printf("正确声明1的输出：%s\n", name_ok1);  
    printf("正确声明2的输出：%s\n", name_ok2);  

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：编译后执行，观察输出  
//  2. 预期：  
//     - 错误声明的输出会乱码（因为没 '\0'，printf 会一直读内存直到遇到 '\0'）  
//     - 两个正确声明都输出 "ress"  
//  3. 检查点：对比乱码和正常输出，理解 '\0' 的作用  
// 易错点提醒：  
//  1. 忘记加 '\0' 会导致字符串操作（如 printf、strlen）出错  
// 拓展思考：  
//  1. 如果用 sizeof(name) 计算长度，错误声明和正确声明有什么区别？  


// ------------------------------
// 题干：2. 下面的程序会打印什么？  
// #include <stdio.h>  
// int main(void) {  
//     char note[] = "See you at the snack bar.";  
//     char *ptr;  
//     ptr = note;  
//     puts(ptr);  
//     puts(++ptr);  
//     note[7] = '\0';  
//     puts(note);  
//     puts(++ptr);  
//     return 0;  
// }  
// 知识要点：  
//  1. 指针操作：指针自增（++ptr）会移动到下一个字符  
//  2. 字符串终止符：修改 note[7] 为 '\0' 会截断字符串  
//  3. puts 输出：从指针位置开始，直到遇到 '\0'  
// 总体逻辑：  
//  1. 逐步分析指针位置和字符串内容的变化，模拟每一步输出  
#include <stdio.h>

int main(void) {
    char note[] = "See you at the snack bar.";  
    char *ptr = note; // ptr 指向 note[0]（'S'）  

    puts(ptr); // 输出：See you at the snack bar.（从 note[0] 开始）  
    puts(++ptr); // ptr 移到 note[1]（'e'），输出：ee you at the snack bar.  

    note[7] = '\0'; // 将 note[7]（原空格）设为 '\0'，字符串截断为 "See you"  

    puts(note); // 从 note[0] 开始，到 '\0' 结束，输出：See you  
    puts(++ptr); // ptr 原本在 note[1]，++后移到 note[2]（'e'），输出：e you  

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：直接编译执行，观察四行输出是否符合分析  
//  2. 预期输出：  
//     See you at the snack bar.  
//     ee you at the snack bar.  
//     See you  
//     e you  
//  3. 检查点：重点看截断后的输出和指针移动的效果  
// 易错点提醒：  
//  1. 容易算错指针位置（比如 ++ptr 后指向哪里）  
//  2. 忘记字符串索引从 0 开始，导致 note[7] 的位置判断错误  
// 拓展思考：  
//  1. 如果把 note[7] = '\0' 改成 note[6] = '\0'，输出会怎么变？  


// ------------------------------
// 题干：3. 下面的程序会打印什么？  
// #include <stdio.h>  
// #include <string.h>  
// int main(void) {  
//     char food[] = "Yummy";  
//     char *ptr;  
//     ptr = food + strlen(food);  
//     while (--ptr >= food)  
//         puts(ptr);  
//     return 0;  
// }  
// 知识要点：  
//  1. strlen 函数：计算字符串长度（不含 '\0'）  
//  2. 指针运算：food + strlen(food) 指向 '\0' 的位置  
//  3. 逆序输出：通过指针自减，从末尾往开头遍历  
// 总体逻辑：  
//  1. 先定位到字符串末尾（'\0' 处），再逐步往前移动指针，每次输出子串  
#include <stdio.h>
#include <string.h> // 包含 strlen 函数

int main(void) {
    char food[] = "Yummy"; // 字符数组：'Y','u','m','m','y','\0'  
    char *ptr = food + strlen(food); // strlen(food)=5，ptr 指向 '\0'（索引5）  

    // 指针自减到 food 开头（索引0），每次输出从 ptr 开始的字符串  
    while (--ptr >= food) {  
        puts(ptr);  
    }  

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：编译后执行，观察输出顺序  
//  2. 预期输出（逐行）：  
//     y  
//     my  
//     mmy  
//     ummy  
//     Yummy  
//  3. 检查点：看是否逆序输出每个字符的子串  
// 易错点提醒：  
//  1. 容易混淆 strlen 的返回值（不含 '\0'，所以 food + 5 指向 '\0'）  
//  2. while 循环的条件是 --ptr >= food，先自减再判断，所以第一次输出的是 'y'（索引4）  
// 拓展思考：  
//  1. 如果字符串是 "Hello"，输出会是什么？  


// ------------------------------
// 题干：4. 下面的程序会打印什么？  
// #include <stdio.h>  
// #include <string.h>  
// int main(void) {  
//     char goldwyn[40] = "art of it all ";  
//     char samuel[40] = "I read p";  
//     const char *quote = "the way through.";  
//     strcat(goldwyn, quote);  
//     strcat(samuel, goldwyn);  
//     puts(samuel);  
//     return 0;  
// }  
// 知识要点：  
//  1. strcat 函数：拼接字符串（目标数组必须有足够空间，且以 '\0' 结尾）  
//  2. 数组拼接：注意源和目标的顺序，以及数组长度是否足够  
// 总体逻辑：  
//  1. 先拼接 goldwyn 和 quote，再拼接 samuel 和 goldwyn，最后输出 samuel  
#include <stdio.h>
#include <string.h> // 包含 strcat 函数

int main(void) {
    char goldwyn[40] = "art of it all "; // 末尾有空格，确保 '\0' 存在  
    char samuel[40] = "I read p";        // 末尾是 'p'，后续要拼接  
    const char *quote = "the way through.";  

    // 第一步：goldwyn = "art of it all " + "the way through." → "art of it all the way through."  
    strcat(goldwyn, quote);  

    // 第二步：samuel = "I read p" + "art of it all the way through." → "I read part of it all the way through."  
    strcat(samuel, goldwyn);  

    puts(samuel); // 输出拼接后的 samuel  

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：编译后执行，观察输出内容  
//  2. 预期输出：I read part of it all the way through.  
//  3. 检查点：看 "p" 和 "art" 是否拼接成 "part"  
// 易错点提醒：  
//  1. strcat 的第一个参数必须是可修改的数组（不能是 const 指针）  
//  2. 容易忽略数组长度：如果 goldwyn 或 samuel 空间不足，会导致溢出（本题中 40 足够）  
// 拓展思考：  
//  1. 如果 goldwyn 初始值是 "art of it all"（末尾无空格），输出会变成 "I read partof it all the way through."，为什么？  
//  2. 尝试用 strncat 替代 strcat，避免缓冲区溢出风险  


// ------------------------------
// （注：第5题题干未完整展示，若需补充可参考类似逻辑扩展。以上4题已按要求完整实现。）

// ------------------------------
// 题干：1. 下面字符串的声明有什么问题？  
// int main(void) { char name[] = {'F','e','s','s'}; }  
// 知识要点：  
//  1. 字符串必须以 '\0'（空字符）结尾，否则不是合法字符串  
//  2. 字符数组 vs 字符串：字符数组存字符，字符串是带 '\0' 的字符数组  
// 总体逻辑：  
//  1. 定义题目中的字符数组，观察输出乱码  
//  2. 定义正确字符串（加 '\0' 或双引号），对比输出  
#include <stdio.h>

int main(void) {
    // 题目中的声明：4个字符，无 '\0' → 不是字符串
    char name_bad[] = {'F', 'e', 's', 's'}; 
    // 正确写法1：手动加 '\0'
    char name_good1[] = {'F', 'e', 's', 's', '\0'}; 
    // 正确写法2：双引号自动加 '\0'
    char name_good2[] = "Fess"; 

    printf("错误声明输出（乱码）：%s\n", name_bad); 
    printf("正确声明1：%s\n", name_good1); 
    printf("正确声明2：%s\n", name_good2); 

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：gcc 1.c -o 1 && ./1  
//  2. 预期：错误声明输出乱码，两个正确声明输出 "Fess"  
//  3. 检查点：对比乱码和正常输出，理解 '\0' 的作用  
// 易错点提醒：  
//  1. 忘记加 '\0' 会导致字符串函数（如 printf、strlen）出错  
// 拓展思考：  
//  1. 用 sizeof 计算三个数组的长度，有什么不同？  


### 题目2解答
```c
// ------------------------------
// 题干：2. 下面的程序会打印什么？  
// #include <stdio.h>  
// int main(void) {  
//     char note[] = "See you at the snack bar.";  
//     char *ptr;  
//     ptr = note;  
//     puts(ptr);  
//     puts(++ptr);  
//     note[7] = '\0';  
//     puts(note);  
//     puts(++ptr);  
//     return 0;  
// }  
// 知识要点：  
//  1. 指针自增：ptr++ 移动到下一个字符  
//  2. 字符串截断：修改数组为 '\0' 会提前结束字符串  
//  3. puts 输出：从指针位置到 '\0' 为止  
// 总体逻辑：  
//  1. 跟踪 ptr 位置变化，分析每次输出内容  
#include <stdio.h>

int main(void) {
    char note[] = "See you at the snack bar."; // 带 '\0' 的字符串
    char *ptr = note; // 指向第一个字符 'S'

    puts(ptr); // 输出：See you at the snack bar.（从 'S' 开始）
    puts(++ptr); // 指针移到 'e'，输出：ee you at the snack bar.

    note[7] = '\0'; // 第8个字符（空格）设为 '\0'，截断为 "See you"
    puts(note); // 输出：See you（从 'S' 到新 '\0'）
    puts(++ptr); // 指针移到 'e'（第3个字符），输出：e you

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：gcc 2.c -o 2 && ./2  
//  2. 预期：4行输出（见题干分析）  
//  3. 检查点：截断后和指针移动的输出是否符合预期  
// 易错点提醒：  
//  1. 算错指针位置（前缀自增是先移动再输出）  
//  2. 忘记字符串索引从 0 开始（note[7] 是第8个字符）  
// 拓展思考：  
//  1. 把 note[7] 改成 note[6]，输出会怎样？  


### 题目3解答
```c
// ------------------------------
// 题干：3. 下面的程序会打印什么？  
// #include <stdio.h>  
// #include <string.h>  
// int main(void) {  
//     char food[] = "Yummy";  
//     char *ptr;  
//     ptr = food + strlen(food);  
//     while (--ptr >= food)  
//         puts(ptr);  
//     return 0;  
// }  
// 知识要点：  
//  1. strlen：计算字符串长度（不含 '\0'）  
//  2. 指针运算：food + strlen(food) 指向 '\0'  
//  3. 逆序输出：指针自减遍历，输出子串  
// 总体逻辑：  
//  1. 定位到 '\0'，逐步向前移动指针，逆序输出  
#include <stdio.h>
#include <string.h>

int main(void) {
    char food[] = "Yummy"; // 内容：'Y','u','m','m','y','\0'
    char *ptr = food + strlen(food); // 指向 '\0'

    while (--ptr >= food) { // 指针先自减，再判断是否在数组内
        puts(ptr); // 输出从 ptr 到 '\0' 的内容
    }

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：gcc 3.c -o 3 && ./3  
//  2. 预期：逆序输出 "y" "my" "mmy" "ummy" "Yummy"  
//  3. 检查点：输出是否逐行变长，最终完整  
// 易错点提醒：  
//  1. 混淆 strlen 返回值（5，对应 '\0' 位置）  
//  2. while 循环中 --ptr 是前缀自减（先移动再判断）  
// 拓展思考：  
//  1. 把循环条件改成 ptr-- >= food，输出会怎样？  


### 题目4解答
```c
// ------------------------------
// 题干：4. 下面的程序会打印什么？  
// #include <stdio.h>  
// #include <string.h>  
// int main(void) {  
//     char goldwyn[40] = "art of it all ";  
//     char samuel[40] = "I read p";  
//     const char *quote = "the way through.";  
//     strcat(goldwyn, quote);  
//     strcat(samuel, goldwyn);  
//     puts(samuel);  
//     return 0;  
// }  
// 知识要点：  
//  1. strcat：拼接字符串（目标数组需有足够空间）  
//  2. 常量指针：quote 指向的内容不可修改  
//  3. 拼接顺序：先拼 goldwyn 和 quote，再拼 samuel 和 goldwyn  
// 总体逻辑：  
//  1. 两次拼接，最终输出 samuel 的内容  
#include <stdio.h>
#include <string.h>

int main(void) {
    char goldwyn[40] = "art of it all "; // 末尾有空格（带 '\0'）
    char samuel[40] = "I read p";        // 末尾是 'p'（带 '\0'）
    const char *quote = "the way through."; 

    strcat(goldwyn, quote); // goldwyn 变成 "art of it all the way through."
    strcat(samuel, goldwyn); // samuel 变成 "I read part of it all the way through."

    puts(samuel); // 输出拼接结果

    return 0;  
}  

// 测试验证方案：  
//  1. 运行：gcc 4.c -o 4 && ./4  
//  2. 预期：I read part of it all the way through.  
//  3. 检查点："p" 和 "art" 是否拼成 "part"  
// 易错点提醒：  
//  1. strcat 目标数组必须可修改（quote 是 const，不能当目标）  
//  2. 确保目标数组空间足够（本题用 40 字节，避免溢出）  
// 拓展思考：  
//  1. 若 goldwyn 空间不足（如 20 字节），会发生什么？  
//  2. 用 strncat 替代 strcat 如何避免溢出？  