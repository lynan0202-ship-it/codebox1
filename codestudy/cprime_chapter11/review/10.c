
// ------------------------------
// 题干：10. strlen()函数接受一个指向字符串的指针作为参数，并返回该字符串的长度。请编写一个这样的函数。  
// 知识要点：  
//  1. 字符串本质：以 '\0' 结尾的字符数组，指针遍历字符串的方法  
//  2. 函数定义：参数为字符指针，返回整数（长度）  
//  3. 边界处理：空字符串（仅 '\0'）的长度为 0，指针为 NULL 时的健壮性处理  
// 总体逻辑：  
//  1. 检查指针合法性（可选，增强健壮性）  
//  2. 初始化长度计数器为 0  
//  3. 遍历字符串：只要指针指向的字符不是 '\0'，计数器加 1，指针后移一位  
//  4. 返回最终计数器值（即字符串长度，不含 '\0'）  
#include <stdio.h>

// 自定义实现strlen功能的函数
int my_strlen(const char *str) {  // const修饰：保证函数内不修改字符串内容
    if (str == NULL) {  // 健壮性处理：避免空指针解引用崩溃
        return 0;
    }
    
    int len = 0;  // 长度计数器，初始为0
    while (*str != '\0') {  // 当指针指向的字符不是结束符时循环
        len++;             // 计数器加1
        str++;             // 指针后移一位，指向下一个字符
    }
    return len;  // 返回最终长度（不含'\0'）
}

// 测试主函数
int main(void) {
    // 测试用例：覆盖空字符串、正常字符串、特殊字符
    const char *test1 = "";          // 空字符串
    const char *test2 = "a";         // 长度1
    const char *test3 = "hello";     // 长度5
    const char *test4 = "你好";      // 注意：中文在UTF-8中占多字节，但字符串仍以'\0'结尾，不影响长度计算（按字符数，不是字节数）
    const char *test5 = NULL;        // 空指针（测试健壮性）
    
    // 调用自定义函数并输出结果
    printf("test1（空字符串）长度：%d\n", my_strlen(test1));
    printf("test2（\"a\"）长度：%d\n", my_strlen(test2));
    printf("test3（\"hello\"）长度：%d\n", my_strlen(test3));
    printf("test4（\"你好\"）长度：%d\n", my_strlen(test4));  // 输出2（字符数，非字节数）
    printf("test5（NULL）长度：%d\n", my_strlen(test5));      // 输出0（健壮性体现）
    
    return 0;
}

// ------------------------------
// 测试验证方案：  
//  1. 运行方式：  
//     - 编译：`gcc 10.c -o 10`  
//     - 执行：`./10`（Windows下为 `10.exe`）  
//  2. 预期结果：  
//     test1（空字符串）长度：0  
//     test2（"a"）长度：1  
//     test3（"hello"）长度：5  
//     test4（"你好"）长度：2（按字符数，每个汉字是1个字符，因字符串以'\0'结尾，遍历到第二个汉字后遇到'\0'）  
//     test5（NULL）长度：0（无崩溃，健壮性通过）  
//  3. 检查点：  
//     - 空字符串和NULL指针是否返回0，无崩溃。  
//     - 正常字符串的长度是否与预期一致（如"hello"是5，不含'\0'）。  

// ------------------------------
// 易错点提醒：  
//  1. **空指针未处理**：如果直接写 `while(*str != '\0')` 而不判断 `str == NULL`，传入NULL时会导致程序崩溃（解引用空指针）。  
//  2. **指针未移动**：忘记写 `str++`，会导致死循环（永远判断第一个字符）。  
//  3. **混淆字符和字节**：对于多字节字符（如中文UTF-8），`my_strlen` 计算的是**字符个数**（按'\0'分隔），而非字节数（如"你好"占6字节，但字符数是2）。  

// ------------------------------
// 拓展思考：  
//  1. **递归实现**：如何用递归改写 `my_strlen`？  
//     → `int my_strlen(const char *str) { if (*str == '\0') return 0; return 1 + my_strlen(str+1); }`  
//  2. **处理二进制数据**：如果字符串中包含 '\0'（非结束符，如二进制数据），如何计算真实长度？  
//     → 无法用传统方法，需传入显式长度（如 `strlen` 只处理以'\0'结尾的字符串，二进制数据需单独接口）。  
//  3. **性能优化**：库函数 `strlen` 通常用汇编优化（如批量判断内存），自定义实现如何加速？  
//     → 可尝试指针跳转（如每次跳4字节判断），但复杂度高，适合深入学习时探索。  
