
// ------------------------------
// 题干：7. 分析以下程序的输出结果，并解释原因：  
// #include <stdio.h>  
// int main(void) {  
//     char str[] = "Hello";  
//     char *ptr = "Hello";  
//     printf("str的大小：%zu\n", sizeof(str));  
//     printf("ptr的大小：%zu\n", sizeof(ptr));  
//     return 0;  
// }  
// 知识要点：  
//  1. **字符数组与指针的区别**：数组名代表数组首地址，但本质是“存储数据的容器”；指针变量存储的是地址，本身是一个变量。  
//  2. **sizeof对数组的作用**：计算整个数组占用的内存大小（包含字符串结束符'\0'）。  
//  3. **sizeof对指针的作用**：计算指针变量本身占用的内存大小（与系统位数相关，32位系统占4字节，64位占8字节）。  
//  4. **字符串存储**：字符数组"Hello"会包含'\0'，总长度为5+1=6个字符。  
// 总体逻辑：  
//  1. 定义字符数组str，存储字符串"Hello"（包含'\0'）。  
//  2. 定义字符指针ptr，指向字符串常量"Hello"。  
//  3. 用sizeof分别计算str（数组）和ptr（指针）的大小。  
//  4. 输出结果，对比差异并解释原因。  

#include <stdio.h>

int main(void) {
    // 字符数组str：存储"Hello"，自动包含结束符'\0'，共6个字符
    char str[] = "Hello";  
    // 字符指针ptr：存储字符串常量"Hello"的首地址（指针变量）
    char *ptr = "Hello";  

    // 计算str的大小：整个数组的字节数（6个字符，每个1字节，共6字节）
    printf("str的大小：%zu\n", sizeof(str));  
    // 计算ptr的大小：指针变量本身的字节数（32位系统4字节，64位系统8字节）
    printf("ptr的大小：%zu\n", sizeof(ptr));  

    return 0;
}  


// ------------------------------
// 测试验证方案：  
//  1. 运行方式：  
//     - 编译：`gcc 7.c -o 7`（32位系统编译可加 `-m32` 选项）  
//     - 执行：`./7`（Windows下为 `7.exe`）  
//  2. 预期结果：  
//     - 64位系统：str的大小：6，ptr的大小：8  
//     - 32位系统：str的大小：6，ptr的大小：4  
//  3. 检查点：  
//     - 确认str的大小是6（包含'\0'），验证数组存储完整字符串。  
//     - 观察ptr的大小与系统位数的关系，理解指针变量大小的特性。  


// ------------------------------
// 易错点提醒：  
//  1. **混淆数组和指针的sizeof结果**：  
//     很多初学者会认为str和ptr都是“指向Hello”，sizeof结果应该相同，但实际数组计算的是整个数据大小，指针计算的是地址存储的大小，完全不同。  
//  2. **忘记字符串结束符**：  
//     计算str大小时，容易忽略'\0'，误以为"Hello"是5个字符，sizeof(str)就是5，实际应为6。  


// ------------------------------
// 拓展思考：  
//  1. 如果将str改为`char str[10] = "Hello";`，sizeof(str)会是多少？  
//     → 10字节。数组大小由声明时的长度决定，即使存储的字符串较短，也按声明长度计算。  
//  2. 指针ptr指向的字符串常量"Hello"可以被修改吗？  
//     → 不可以。字符串常量存储在只读内存区，修改会导致程序崩溃（如`ptr[0] = 'h'`是错误的）。  
//  3. 数组名str和指针ptr有哪些相似之处？  
//     → 都可以通过`[]`访问元素（如str[0]和ptr[0]都能获取'H'），都可以用`*`解引用（如*str和*ptr都是'H'），但本质是不同的（数组是容器，指针是地址变量）。  
