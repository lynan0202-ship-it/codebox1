```c
// ------------------------------
// 题干：9. 本章定义的 s_gets() 函数，用指针表示法代替数组表示法便可减少一个变量 i。请改写该函数。  
// （原s_gets函数用数组索引i遍历字符串，现在要求用指针操作，去掉i，实现同样功能：安全读取一行输入，处理换行符和输入溢出）
// 知识要点：  
//  1. 指针遍历字符串：通过指针移动（p++）访问数组元素，替代数组索引（i++）
//  2. fgets函数用法：从标准输入读取字符串，最多读n-1个字符，自动加'\0'，遇换行或EOF停止
//  3. 输入处理：若输入含换行符，替换为'\0'；若输入超长，清理缓冲区剩余字符
//  4. 函数返回值：返回fgets的结果（成功返回字符串首地址，失败/EOF返回NULL）
// 总体逻辑：  
//  1. 用fgets读取输入到字符数组，保存返回值
//  2. 若读取成功，用指针从数组开头遍历，找换行符'\n'或结束符'\0'
//  3. 找到换行符：替换为'\0'（截断字符串，去掉换行）
//  4. 没找到换行符：说明输入超长，用getchar()清空缓冲区剩余字符
//  5. 返回fgets的返回值，标记读取状态
#include <stdio.h>

// 用指针表示法改写的s_gets函数
char *s_gets(char *st, int n) {
    // 调用fgets读取输入：最多存n-1个字符（留1个位置给'\0'）
    // ret_val记录fgets的返回值（成功是st的地址，失败/EOF是NULL）
    char *ret_val = fgets(st, n, stdin);
    
    // 如果读取成功（ret_val不是NULL，即使输入空行也会进入）
    if (ret_val != NULL) {
        char *p = st;  // 定义指针p，指向数组st的第一个元素（代替原i=0）
        
        // 遍历字符串：直到找到换行符'\n'或结束符'\0'才停止
        // *p != '\n'：没找到换行符；*p != '\0'：没到字符串末尾（fgets自动加的）
        while (*p != '\n' && *p != '\0') {
            p++;  // 指针后移，访问下一个字符（代替i++）
        }
        
        // 如果找到换行符（说明输入没超长，正常包含换行）
        if (*p == '\n') {
            *p = '\0';  // 把换行符换成字符串结束符，去掉换行
        } else {
            // 没找到换行符：说明输入超长，缓冲区还有剩余字符
            // 用getchar()逐个读取剩余字符，直到遇到换行符（清空缓冲区）
            while (getchar() != '\n') {
                // 什么都不做，只是丢弃多余字符
                ;
            }
        }
    }
    
    // 返回fgets的结果：成功返回输入的字符串地址，失败返回NULL
    return ret_val;
}

// 测试用主函数：验证改写后的s_gets是否正常工作
int main() {
    char buffer[10];  // 定义一个小缓冲区，方便测试输入溢出
    printf("请输入内容（测试1：短输入，如\"abc\"+回车）：\n");
    
    // 第一次测试：短输入（长度小于buffer-1）
    if (s_gets(buffer, 10) != NULL) {
        printf("读取结果：%s（长度：%zu）\n", buffer, strlen(buffer));
    }
    
    printf("\n请输入内容（测试2：超长输入，如\"1234567890123\"+回车）：\n");
    
    // 第二次测试：超长输入（长度大于buffer-1）
    if (s_gets(buffer, 10) != NULL) {
        printf("读取结果：%s（长度：%zu）\n", buffer, strlen(buffer));
    }
    
    printf("\n请输入内容（测试3：直接回车，空输入）：\n");
    
    // 第三次测试：空输入（只按回车）
    if (s_gets(buffer, 10) != NULL) {
        printf("读取结果：%s（长度：%zu）\n", buffer, strlen(buffer));
    }
    
    return 0;
}

// ------------------------------
// 测试验证方案：  
//  1. 短输入测试：  
//     - 操作：输入"abc"然后按回车（长度3，小于buffer-1=9）  
//     - 预期：输出"读取结果：abc（长度：3）"，换行符被替换为'\0'，没有多余字符  
//  2. 超长输入测试：  
//     - 操作：输入"1234567890123"然后按回车（长度13，大于buffer-1=9）  
//     - 预期：buffer只存前9个字符"123456789"（长度9），剩余的"0123"和换行被清理，下次输入不受影响  
//  3. 空输入测试：  
//     - 操作：直接按回车（输入只有换行符）  
//     - 预期：输出"读取结果：（长度：0）"，换行符被替换为'\0'，字符串为空  
//  4. 运行方式：  
//     - 编译：gcc 9.c -o 9  
//     - 执行：./9（Windows下：9.exe），按提示输入内容，观察输出是否符合预期  
// 检查点：重点看超长输入后，缓冲区是否只存前n-1个字符，且后续输入正常（可多试几次）

// ------------------------------
// 易错点提醒：  
//  1. 指针未初始化：如果忘记写"char *p = st;"，p会指向随机地址，遍历或修改时会导致程序崩溃  
//  2. 循环条件错误：把"*p != '\n' && *p != '\0'"写成"*p != '\n' || *p != '\0'"（逻辑或），会导致死循环（因为任何字符都至少满足一个条件）  
//  3. 处理换行符时漏改：找到'\n'后忘记写"*p = '\0'"，会导致输出时带换行符  
//  4. 清理缓冲区不彻底：如果输入超长且最后没有换行符（比如文件结尾），getchar()会读到EOF，此时循环会一直执行，需补充判断：while(getchar() != '\n' && getchar() != EOF);

// ------------------------------
// 拓展思考：  
//  1. 如何让函数返回"是否发生了输入溢出"？  
//     - 可以添加一个输出参数：char *s_gets(char *st, int n, int *is_truncated)，在清理缓冲区时设置*is_truncated = 1，否则为0  
//  2. 对比指针遍历和数组索引遍历：  
//     - 指针遍历更接近计算机底层操作（直接移动地址），效率略高；数组索引更直观，适合初学者理解  
//  3. 如果输入的字符串中本身就包含'\0'（比如二进制数据），这个函数会有问题吗？  
//     - 会有问题，因为fgets和while循环都会把'\0'当作结束符，导致提前停止处理。这种场景需要用fread等二进制读取函数  
//  4. 如何修改函数，让它支持从文件（而非标准输入）读取？  
//     - 增加一个FILE*参数：char *s_gets(char *st, int n, FILE *stream)，然后用fgets(st, n, stream)代替fgets(st, n, stdin)即可  
```