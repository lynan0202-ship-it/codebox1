

// ------------------------------
// 题干：第5题 - 分析pr函数的行为（含a-h子问题）  
// 函数定义：  
// char *pr(char *str) {  
//     char *pc;  
//     pc = str;  
//     while (*pc) putchar(*pc++);  
//     do { putchar(*--pc); } while (pc - str);  
//     return pc;  
// }  
// 调用：x = pr("Ho Ho Ho!");  
// 知识要点：  
//  1. 指针操作：前缀自减（--pc） vs 后缀自减（pc--）的执行顺序  
//  2. 字符串遍历：通过 `while(*pc)` 遍历到末尾（'\0'）  
//  3. 循环结构：`do-while` 先执行再判断，`while` 先判断再执行  
//  4. 指针运算：`pc - str` 判断指针位置差（地址偏移量）  
// 总体逻辑：  
//  1. **正序输出**：遍历字符串，逐个输出字符，指针后移（`pc++`）。  
//  2. **逆序输出**：从字符串末尾（'\0' 前一位）开始，指针前移（`--pc`），逐个输出字符，直到回到起始位置（`pc == str`）。  
//  3. **返回值**：最终指针回到字符串起始位置（`str`）。  

#include <stdio.h>

// 题目中的pr函数
char *pr(char *str) {
    char *pc = str;  // pc指向字符串首字符
    
    // 1. 正序输出：遍历到'\0'（但不输出'\0'）
    while (*pc) {         // 当pc指向的字符不是'\0'时循环
        putchar(*pc++);  // 输出当前字符 → 指针后移一位
    }
    
    // 2. 逆序输出：从最后一个有效字符往回走
    do {
        putchar(*--pc);  // 指针先前移一位 → 输出字符
    } while (pc - str);  // 只要pc还没回到str的位置，就继续循环
    
    return pc;  // 返回最终的pc（此时pc == str，指向首字符）
}

int main(void) {
    char *x;  // 存储pr的返回值
    
    // 调用pr，传入测试字符串
    x = pr("Ho Ho Ho!");
    
    // 分析返回值（对应问题b、c）
    printf("\n--- 问题分析 ---\n");
    printf("b. x的类型：char*（指针类型，指向字符）\n");
    printf("c. x的值：%p（等于字符串首字符的地址，如\"Ho Ho Ho!\"的'H'地址）\n", x);
    printf("   验证：*x = '%c'（解引用x，输出首字符'H'）\n", *x);
    
    return 0;
}


// ------------------------------
// 测试验证方案（重点验证问题a的输出）：  
//  1. 运行方式：  
//     - 编译：`gcc 5.c -o 5`  
//     - 执行：`./5`  
//  2. 预期输出（问题a）：  
//     正序：`Ho Ho Ho!`（遍历到'\0'前，输出所有有效字符）  
//     逆序：`!oH oH oH`（从'!'往回输出到第一个'H'）  
//     完整输出：`Ho Ho Ho!!oH oH oH`（正序+逆序拼接）  
//  3. 检查点：  
//     - 正序部分是否完整（无遗漏字符）。  
//     - 逆序部分是否从'!'开始，逐字符往回输出（`! → o → H → 空格 → o → H → 空格 → o → H`）。  


// ------------------------------
// 易错点提醒：  
//  1. **指针操作顺序**：  
//     - `*--pc`：先移动指针（前移），再取值（输出）。  
//     - `--*pc`：先取值（修改字符值），再移动指针（无，因为--作用于值）。两者完全不同（对应问题d）。  
//  2. **空字符串风险**（问题g）：  
//     - 若传入空字符串`""`，`while(*pc)`不执行，`do`循环中`*--pc`会访问`str-1`（非法地址），导致程序崩溃。  
//  3. **返回值理解**（问题c）：  
//     - `pc`最终回到`str`的位置，所以`x`指向字符串首字符，而非末尾。  


// ------------------------------
// 拓展思考（对应子问题）：  
//  e. 若替换 `*--pc` 为 `*pc--`：  
//     - 行为变化：先取值（`*pc`，此时`pc`指向'\0'，输出空），再移动指针（`pc--`到最后一个有效字符）。  
//     - 输出结果：正序后，先输出空，再从最后一个字符往前输出（如 `Ho Ho Ho!` 后接 `!oH oH oH` 变成 `Ho Ho Ho!oH oH oH`，开头多空）。  
//  f. 循环的测试目的：  
//     - 第一个`while(*pc)`：遍历字符串内容（到'\0'）。  
//     - 第二个`while(pc - str)`：确保逆序输出覆盖整个字符串（从末尾回到开头）。  
//  h. 主调函数的准备：  
//     - 只需传递**有效字符串指针**（如字符串字面量、字符数组），但需避免空字符串（问题g的风险）。  
//     - 字符串字面量是只读的，但`pr`函数未修改字符串内容（仅移动指针），所以安全。  


// ------------------------------
// 问题d补充解释（*--pc vs --*pc）：  
// - `*--pc`：指针先减1（前移），再解引用（输出字符）→ **移动指针，访问新位置的值**。  
// - `--*pc`：先解引用（取当前字符的值），再把该值减1（如`'A'→'@'`）→ **修改字符值，不移动指针**。  
// 两者操作对象不同：前者改**指针位置**，后者改**字符内容**。