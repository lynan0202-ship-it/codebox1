
// ------------------------------
// 题干：11. 本章定义的 s_gets() 函数，可以用 strchr() 函数代替其中的 while 循环来查找换行符。请改写该函数。  
// 知识要点：  
//  1. strchr 函数：查找字符在字符串中首次出现的位置，返回指针（未找到则为NULL）  
//  2. s_gets 核心逻辑：处理 fgets 读取的换行符和超长输入，确保后续输入正常  
//  3. 指针操作：通过 strchr 返回的指针直接修改字符串（替换换行符为'\0'）  
// 总体逻辑：  
//  1. 调用 fgets 读取输入，保存返回值  
//  2. 若读取成功，用 strchr 定位换行符 '\n'  
//  3. 找到换行符：替换为 '\0'（截断字符串）  
//  4. 未找到换行符：清理缓冲区剩余字符（处理超长输入）  
//  5. 返回 fgets 结果（标记读取状态）  
#include <stdio.h>
#include <string.h>  // 必须包含，strchr在此头文件中

char *s_gets(char *st, int n) {
    // 步骤1：尝试读取一行，最多存储 n-1 个字符（留1位给'\0'）
    char *ret_val = fgets(st, n, stdin);
    
    // 步骤2：仅当读取成功时处理（ret_val非NULL，即使是空行也会进入）
    if (ret_val != NULL) {
        // 用strchr查找换行符'\n'的位置
        char *newline_ptr = strchr(st, '\n');
        
        if (newline_ptr != NULL) { 
            // 步骤3：找到换行符 → 替换为'\0'，去除换行
            *newline_ptr = '\0';
        } else { 
            // 步骤4：未找到换行符 → 输入超长，清理缓冲区
            while (getchar() != '\n') { 
                // 持续读取，直到遇到换行符（丢弃多余字符）
                ; 
            }
        }
    }
    
    // 步骤5：返回读取结果（NULL表示EOF或读取失败）
    return ret_val;
}

// 测试用主函数：验证改写后的s_gets行为
int main(void) {
    char test_buf[10];  // 小缓冲区，方便测试超长输入
    
    // 测试1：短输入（例：abc + 回车）
    printf("测试1：输入短字符串（如\"abc\"+回车）\n");
    if (s_gets(test_buf, 10) != NULL) {
        printf("读取内容：\"%s\"（长度：%zu）\n", test_buf, strlen(test_buf));
    }
    
    // 测试2：超长输入（例：1234567890 + 回车，共10字符）
    printf("\n测试2：输入超长字符串（如\"1234567890\"+回车）\n");
    if (s_gets(test_buf, 10) != NULL) {
        printf("读取内容：\"%s\"（长度：%zu）\n", test_buf, strlen(test_buf));
    }
    
    // 测试3：空输入（直接回车）
    printf("\n测试3：直接按回车（空输入）\n");
    if (s_gets(test_buf, 10) != NULL) {
        printf("读取内容：\"%s\"（长度：%zu）\n", test_buf, strlen(test_buf));
    }
    
    return 0;
}

// ------------------------------
// 测试验证方案：  
//  1. 短输入测试：  
//     - 操作：输入"abc"后回车（长度3 < 9）  
//     - 预期：输出"读取内容："abc"（长度：3）"，换行符被替换为'\0'。  
//  2. 超长输入测试：  
//     - 操作：输入"1234567890"后回车（长度10 > 9）  
//     - 预期：test_buf存前9字符"123456789"（长度9），剩余字符被清理。  
//  3. 空输入测试：  
//     - 操作：直接回车（仅换行符）  
//     - 预期：输出"读取内容：""（长度：0）"，换行符被替换为'\0'。  
//  4. 运行方式：  
//     - 编译：gcc 11.c -o 11  
//     - 执行：./11（Windows下为11.exe），观察输出是否符合预期。  

// ------------------------------
// 易错点提醒：  
//  1. 遗漏头文件：strchr定义在<string.h>中，未包含会导致编译错误。  
//  2. 空指针风险：虽fgets保证st有效（ret_val非NULL时），但需注意传入参数合法性。  
//  3. strchr逻辑误解：若字符串无'\n'，需进入清理逻辑，否则超长输入会残留。  

// ------------------------------
// 拓展思考：  
//  1. 处理Windows换行符（\r\n）：  
//     → 先找'\n'，若没找到再找'\r'：  
//        char *nl = strchr(st, '\n');  
//        if (!nl) nl = strchr(st, '\r');  
//        if (nl) *nl = '\0';  
//  2. strchr与strrchr对比：  
//     → strchr找首次出现，strrchr找最后一次出现（如处理文件扩展名）。  
//  3. 二进制数据场景：  
//     → 若字符串含'\0'（非结束符），strchr会提前终止，需用fread等二进制函数。  
