
// ------------------------------
// 题干：13. 编写一个名为 my_strcmp() 的函数，其功能类似于 strcmp() 函数，用于比较两个字符串。  
// （要求：比较规则为逐个字符对比ASCII值，直到遇到不同字符或其中一个字符串的'\0'；返回值：两串相等返回0，第一个串大于第二个串返回正整数，否则返回负整数）
// 知识要点：  
//  1. 字符串比较原理：逐个字符对比ASCII码值，首个不同字符的差值决定结果  
//  2. 指针遍历：通过指针同步移动，访问两个字符串的对应字符  
//  3. 结束条件：遇到不同字符 或 两个字符串同时结束（均为'\0'）  
//  4. const修饰：参数用const，确保函数不修改原字符串，增强安全性  
// 总体逻辑：  
//  1. 用指针同步遍历两个字符串，逐个获取对应位置的字符  
//  2. 对比当前字符：若不同，返回两字符ASCII值的差值（第一个减第二个）  
//  3. 若相同，继续遍历下一个字符；若两字符串同时结束（均为'\0'），返回0  
//  4. 若其中一个先结束（为'\0'），返回两字符差值（非'\0'减'\0'为正，反之负）  
#include <stdio.h>

// 自定义字符串比较函数，功能类似strcmp
int my_strcmp(const char *s1, const char *s2) {  // const修饰：不修改原字符串
    // 遍历两个字符串，直到遇到不同字符或其中一个结束
    while (*s1 != '\0' && *s2 != '\0') {
        // 若当前字符不同，直接返回差值（s1字符 - s2字符）
        if (*s1 != *s2) {
            return *s1 - *s2;  // 正表示s1大，负表示s2大
        }
        // 字符相同，指针都后移一位，继续比较下一个
        s1++;
        s2++;
    }
    // 循环结束：至少有一个字符串已结束，返回当前字符差值
    return *s1 - *s2;  // 若都结束，*s1和*s2都是'\0'，差值为0；否则非结束符减'\0'为正
}

// 测试用主函数
int main(void) {
    // 测试用例：覆盖各种比较场景
    const char *str1 = "apple";
    const char *str2 = "apple";    // 两串相等
    const char *str3 = "app";      // 前3个字符相同，str3短
    const char *str4 = "apricot";  // 第3个字符不同（'p' vs 'r'）
    const char *str5 = "";         // 空字符串
    const char *str6 = "banana";   // 首字符不同（'a' vs 'b'）

    // 打印测试结果
    printf("比较\"%s\"和\"%s\"：%d（预期0）\n", str1, str2, my_strcmp(str1, str2));
    printf("比较\"%s\"和\"%s\"：%d（预期正，因str1更长）\n", str1, str3, my_strcmp(str1, str3));
    printf("比较\"%s\"和\"%s\"：%d（预期负，因str3更短）\n", str3, str1, my_strcmp(str3, str1));
    printf("比较\"%s\"和\"%s\"：%d（预期负，'p' < 'r'）\n", str1, str4, my_strcmp(str1, str4));
    printf("比较\"%s\"和\"%s\"：%d（预期正，非空 > 空）\n", str1, str5, my_strcmp(str1, str5));
    printf("比较\"%s\"和\"%s\"：%d（预期负，'a' < 'b'）\n", str1, str6, my_strcmp(str1, str6));

    return 0;
}

// ------------------------------
// 测试验证方案：  
//  1. 运行方式：  
//     - 编译：gcc 13.c -o 13  
//     - 执行：./13（Windows下为13.exe）  
//  2. 预期结果：  
//     比较"apple"和"apple"：0（预期0）  
//     比较"apple"和"app"：112（'l'的ASCII值，因str1更长）  
//     比较"app"和"apple"：-112（与上相反）  
//     比较"apple"和"apricot"：-14（'p'比'r'小14）  
//     比较"apple"和""：97（'a' - '\0' = 97）  
//     比较"apple"和"banana"：-1（'a'比'b'小1）  
//  3. 检查点：  
//     - 相等字符串是否返回0  
//     - 不同位置的字符是否按ASCII差值返回正确正负  
//     - 长度不同但前缀相同的字符串，是否返回非结束符与'\0'的差值  

// ------------------------------
// 易错点提醒：  
//  1. 循环条件错误：写成`while (*s1 && *s2 && *s1 == *s2)`，会漏掉“其中一个结束后仍需比较”的情况（如"app"和"apple"）  
//  2. 返回值符号颠倒：误写为`*s2 - *s1`，导致结果正负相反  
//  3. 忘记处理同时结束的情况：循环内只判断字符不同，没考虑两串同时到'\0'（实际循环结束后`*s1 - *s2`自然为0，无需额外处理）  
//  4. 空指针未处理：若传入NULL，`*s1`或`*s2`会导致程序崩溃（实际使用需提前判断，如`if (s1 == NULL || s2 == NULL) { ... }`）  

// ------------------------------
// 拓展思考：  
//  1. 如何实现不区分大小写的比较（如"Apple"和"apple"视为相等）？  
//     → 比较前先将字符转为统一大小写（用toupper或tolower函数）：  
//        while (*s1 && *s2) {  
//            if (toupper(*s1) != toupper(*s2)) return toupper(*s1) - toupper(*s2);  
//            s1++; s2++;  
//        }  
//  2. 如何限制比较的最大长度（如只比较前n个字符）？  
//     → 增加参数n，循环条件加`n-- > 0`：  
//        int my_strncmp(const char *s1, const char *s2, int n) {  
//            while (n-- > 0 && *s1 && *s2 && *s1 == *s2) { s1++; s2++; }  
//            return *s1 - *s2;  
//        }  
//  3. 返回值一定是1或-1吗？  
//     → 不一定，标准strcmp返回“非零值”，差值的绝对值可能大于1（如'm' - 'a' = 12），自定义函数也遵循此规则  
