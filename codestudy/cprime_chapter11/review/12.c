
// ------------------------------
// 题干：12. 编写一个名为 my_strcat() 的函数，其功能类似于 strcat() 函数，将源字符串追加到目标字符串的末尾。  
// （要求：目标字符串必须以 '\0' 结尾，源字符串也必须以 '\0' 结尾；函数返回目标字符串的首地址；目标字符串需有足够空间容纳拼接后的结果）
// 知识要点：  
//  1. 字符串追加原理：找到目标字符串的 '\0' 位置，将源字符串的字符从该位置开始复制  
//  2. 指针操作：通过指针遍历目标字符串找末尾，遍历源字符串复制字符  
//  3. 函数参数：目标字符串为可修改的 char*（需写入），源字符串为 const char*（只读，不修改）  
//  4. 字符串结束符：复制完成后，在目标字符串新末尾添加 '\0'  
// 总体逻辑：  
//  1. 定义临时指针保存目标字符串首地址（用于最后返回）  
//  2. 遍历目标字符串，找到其末尾的 '\0' 位置  
//  3. 从目标字符串的 '\0' 位置开始，逐个复制源字符串的字符（包括源字符串的 '\0'）  
//  4. 返回目标字符串的首地址  
#include <stdio.h>

// 自定义字符串追加函数，功能类似strcat
char *my_strcat(char *dest, const char *src) {
    // 步骤1：保存目标字符串的首地址（最后要返回这个地址）
    char *original_dest = dest;  // 临时指针，不修改原始首地址

    // 步骤2：找到目标字符串的末尾（即'\0'的位置）
    while (*dest != '\0') {  // 只要当前字符不是'\0'，就继续后移指针
        dest++;
    }
    // 循环结束后，dest指向目标字符串的'\0'位置

    // 步骤3：将源字符串的字符逐个复制到目标字符串的末尾
    while (*src != '\0') {  // 遍历源字符串，直到遇到'\0'
        *dest = *src;       // 复制源字符串当前字符到目标字符串位置
        dest++;             // 目标指针后移一位
        src++;              // 源指针后移一位
    }
    // 步骤4：复制源字符串的'\0'到目标字符串末尾，确保新字符串正确结束
    *dest = '\0';

    // 返回目标字符串的原始首地址
    return original_dest;
}

// 测试用主函数
int main(void) {
    // 测试1：正常情况（目标有足够空间）
    char dest1[20] = "Hello, ";  // 目标字符串，预留足够空间
    const char *src1 = "World!";
    my_strcat(dest1, src1);
    printf("测试1：%s\n", dest1);  // 预期：Hello, World!

    // 测试2：目标是空字符串
    char dest2[20] = "";          // 目标初始为空
    const char *src2 = "Test";
    my_strcat(dest2, src2);
    printf("测试2：%s\n", dest2);  // 预期：Test

    // 测试3：源是空字符串
    char dest3[20] = "ABC";
    const char *src3 = "";        // 源为空
    my_strcat(dest3, src3);
    printf("测试3：%s\n", dest3);  // 预期：ABC（目标不变）

    // 测试4：多次追加
    char dest4[30] = "I ";
    my_strcat(dest4, "love ");
    my_strcat(dest4, "C!");
    printf("测试4：%s\n", dest4);  // 预期：I love C!

    return 0;
}

// ------------------------------
// 测试验证方案：  
//  1. 运行方式：  
//     - 编译：gcc 12.c -o 12  
//     - 执行：./12（Windows下为12.exe）  
//  2. 预期结果：  
//     测试1：Hello, World!  
//     测试2：Test  
//     测试3：ABC  
//     测试4：I love C!  
//  3. 检查点：  
//     - 拼接后的字符串是否完整，无缺失字符  
//     - 字符串是否以'\0'正确结束（printf能正常输出，无乱码）  
//     - 多次追加是否正确累积结果  

// ------------------------------
// 易错点提醒：  
//  1. 目标字符串空间不足：如果dest的数组长度不够容纳拼接后的结果，会导致缓冲区溢出（程序可能崩溃或数据错乱），需提前确保dest有足够空间  
//  2. 忘记复制源字符串的'\0'：如果漏写`*dest = '\0'`，目标字符串会缺少结束符，后续操作（如printf）可能输出乱码  
//  3. 源或目标不是以'\0'结尾：如果src或dest没有'\0'，遍历会越界，导致不可预期的结果  
//  4. 源和目标字符串重叠：如果src指向dest的一部分（如my_strcat(dest, dest+2)），会导致逻辑错误（标准strcat也不处理这种情况）  

// ------------------------------
// 拓展思考：  
//  1. 如何实现my_strncat（限制追加的最大字符数，避免溢出）？  
//     → 增加一个参数n，控制最多复制n个字符，最后手动加'\0'：  
//        char *my_strncat(char *dest, const char *src, int n) {  
//            char *orig = dest;  
//            while (*dest) dest++;  
//            while (n-- > 0 && *src) { *dest++ = *src++; }  
//            *dest = '\0';  
//            return orig;  
//        }  
//  2. 如何检查目标字符串是否有足够空间容纳拼接结果？  
//     → 可先计算dest和src的长度（用my_strlen），判断dest的剩余空间（总长度 - 当前长度）是否大于src的长度  
//  3. 为什么源字符串要用const修饰？  
//     → 告诉编译器和使用者：该参数是输入，函数不会修改它，增强代码可读性和安全性  
