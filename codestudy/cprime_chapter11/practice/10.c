// ------------------------------
// 题干：编写一个函数接受一个字符串作为参数，并删除字符串中的空格。在一个程序中测试该函数，使用循环读取输入行，直到用户输入一行空行。该程序应该应用该函数读取每个输入的字符串，并显示处理后的结果。
// 知识要点：
//  1. 字符串的指针操作：通过指针传递字符串，函数内直接修改原字符串内容（指针传递实现“引用修改”）。
//  2. 循环读取输入：利用 fgets 读取整行输入，通过判断首字符是否为换行符识别空行。
//  3. 字符串遍历与修改：双索引法原地重构字符串（一个索引遍历，一个索引记录有效字符位置）。
// 总体逻辑：
//  1. 主函数定义字符数组存储输入，循环调用 fgets 读取行数据。
//  2. 每次读取后检查是否为空行（首字符是 '\n' ），若是则终止循环。
//  3. 非空行调用 remove_spaces 函数：遍历字符串，仅复制非空格字符到前方，最后补充字符串结束符。
//  4. 输出处理后的字符串，重复流程直到输入空行。
#include <stdio.h>

// 函数声明：删除字符串中的空格（指针参数，直接修改原字符串）
void remove_spaces(char *str);

int main() {
    char line[1000]; // 定义字符数组存输入行（假设长度足够，实际可优化）
    printf("请输入字符串（输入空行结束）：\n");
    while (1) { // 无限循环，直到遇到空行
        fgets(line, sizeof(line), stdin); // 读一行，包括末尾换行符
        // 判断是否空行：若首字符是换行符，说明用户没输入内容直接回车
        if (line[0] == '\n') {
            break; // 空行，结束循环
        }
        remove_spaces(line); // 处理空格
        printf("处理后：%s\n", line); // 输出结果
    }
    return 0;
}

// 函数定义：删除字符串中的空格
void remove_spaces(char *str) {
    int i = 0; // i：遍历原字符串的索引
    int j = 0; // j：记录“无空格字符串”的当前位置
    while (str[i] != '\0') { // 遍历到字符串末尾
        if (str[i] != ' ') { // 只处理非空格字符
            str[j] = str[i]; // 把非空格字符移到j的位置
            j++; // j向后移动，准备存下一个字符
        }
        i++; // 无论是否是空格，i都向后遍历
    }
    str[j] = '\0'; // 在新末尾加结束符，截断原字符串
}

// 测试验证方案：
//  1. 怎么运行：  
//     - 编译：gcc 10.c -o 10（或其他编译器），运行 ./10 。  
//     - 输入示例：  
//       → 输入 "  hello   world  " → 输出 "helloworld"  
//       → 输入 "a b c d" → 输出 "abcd"  
//       → 直接按回车（空行）→ 程序退出。  
//  2. 预期结果：  
//     - 所有输入行的空格被删除，空行正确终止程序。  
//  3. 检查点：  
//     - 观察输出是否无空格，空行时程序是否退出。  
// 易错点提醒：  
//  1. 忘记写 `str[j] = '\0';` → 字符串未正确截断，会残留原字符串的后续内容（如空格后的字符）。  
//  2. fgets 读取的换行符：若输入行非空，末尾的 '\n' 会被保留（题目只删空格，所以换行符会留在结果里，属于正常逻辑）。  
//  3. 数组越界：若输入行超长（超过1000字符），可能导致溢出，实际需优化存储方式（如动态分配）。  
// 拓展思考：  
//  1. 扩展功能：若要删除所有空白符（空格、制表符、换行符），可改条件为 `if (!isspace(str[i]))`（需包含 <ctype.h> ）。  
//  2. 输入行超长处理：用循环分段读取，或通过 malloc 动态分配足够内存。  
//  3. 对比值传递 vs 指针传递：  
//     - 若函数参数是 `char str[]`（本质还是指针），效果和 `char *str` 一致；若传“字符串拷贝”（如用临时数组），则无法修改原字符串。  
//     - 指针传递直接操作原内存，实现“修改外部变量”，值传递是拷贝，无法影响外部。