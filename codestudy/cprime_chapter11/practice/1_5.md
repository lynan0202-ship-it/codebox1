// ------------------------------
// 题干：1. 设计并测试一个函数，从输入中获取 n 个字符（包括空白、制表符、换行符），把结果存储在一个数组里，它的地址被传递作为一个参数。  
// 知识要点：  
//  1. 数组传址调用：通过指针修改主函数的数组内容  
//  2. getchar() 用法：读取任意字符（包括空白、换行）  
//  3. 循环控制：固定读取n个字符，不提前终止  
// 总体逻辑：  
//  1. 定义函数接收数组指针和n，循环n次读字符存入数组  
//  2. 主函数定义数组，调用函数后输出验证  

#include <stdio.h>

// 读取n个字符到arr（包括空白、换行）
void get_n_chars(char *arr, int n) {
    for (int i = 0; i < n; i++) {
        arr[i] = getchar();  // 逐个读字符，包括空白
    }
}

int main() {
    char buf[20];
    int n = 10;
    printf("输入10个字符（含空白/换行）：\n");
    get_n_chars(buf, n);
    
    printf("读取结果：\n");
    for (int i = 0; i < n; i++) {
        printf("第%d个：%c（ASCII：%d）\n", i+1, buf[i], buf[i]);
    }
    return 0;
}

// 测试验证方案：  
//  1. 运行：编译后输入 "a b\n123"（共10字符）  
//  2. 预期：输出10个字符，包含空格、换行  
//  3. 检查点：数组内容与输入一致，循环严格执行n次  
// 易错点提醒：  
//  1. 数组溢出：n不能超过数组长度  
//  2. getchar阻塞：输入不足n个时程序会等待  
// 拓展思考：  
//  1. 如何处理EOF？可在函数内判断getchar() != EOF  


// ------------------------------
// 题干：2. 修改题1函数，在n个字符或遇到空白/制表/换行时停止（先到先停）。  
// 知识要点：  
//  1. 多条件循环：同时判断字符数和终止符  
//  2. 字符分类：识别空格、制表、换行  
//  3. 输入控制：灵活终止读取逻辑  
// 总体逻辑：  
//  1. 函数循环读字符，遇终止符或读够n个则停  
//  2. 给数组加'\0'，主函数输出结果  

#include <stdio.h>

// 读取字符，遇空白/制表/换行或n个则停，返回实际读取数
int read_until_blank(char *arr, int n) {
    int cnt = 0;
    char ch;
    while (cnt < n) {
        ch = getchar();
        if (ch == ' ' || ch == '\t' || ch == '\n') break; // 遇终止符
        arr[cnt++] = ch;
    }
    arr[cnt] = '\0'; // 字符串结束符
    return cnt;
}

int main() {
    char buf[20];
    int n = 10;
    printf("输入字符（遇空白/读够10个停）：\n");
    int len = read_until_blank(buf, n);
    
    printf("读取% d个字符：%s\n", len, buf);
    return 0;
}

// 测试验证方案：  
//  1. 运行：输入"abc def"（空格处停，读3个）；输入"1234567890"（读10个）  
//  2. 预期：输出符合终止条件的字符数和内容  
//  3. 检查点：终止符触发、n生效、数组含'\0'  
// 易错点提醒：  
//  1. 忘记加'\0'：后续用%s输出会乱码  
//  2. 终止符判断遗漏（如忘判'\t'）  
// 拓展思考：  
//  1. 如何让用户自定义终止符？传入终止符集合  


// ------------------------------
// 题干：3. 读取一个单词（跳过前导空白，读非空白直到空白，丢弃剩余字符）。  
// 知识要点：  
//  1. 跳过前导空白：循环读直到非空白  
//  2. 读取单词：读非空白直到空白/EOF  
//  3. 丢弃剩余字符：清理输入行剩余内容  
// 总体逻辑：  
//  1. 函数先跳前导空白，再读单词字符，最后丢弃剩余  
//  2. 主函数调用后输出单词  

#include <stdio.h>

// 读取单词（跳前导空白，读非空白，丢弃剩余）
void read_word(char *word, int max_len) {
    char ch;
    int i = 0;
    
    // 跳前导空白
    while ((ch = getchar()) != EOF && (ch == ' ' || ch == '\t' || ch == '\n'));
    if (ch == EOF) {
        word[0] = '\0';
        return;
    }
    
    // 读单词字符（最多max_len-1个）
    word[i++] = ch;
    while (i < max_len - 1) {
        ch = getchar();
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == EOF) break;
        word[i++] = ch;
    }
    word[i] = '\0';
    
    // 丢弃剩余字符
    while (ch != '\n' && ch != EOF) ch = getchar();
}

int main() {
    char word[50];
    printf("输入一行文本（含前导空白和单词）：\n");
    read_word(word, 50);
    
    printf("读取的单词：%s\n", word);
    return 0;
}

// 测试验证方案：  
//  1. 运行：输入"   hello world" → 读"hello"；输入"\tfoo bar" → 读"foo"  
//  2. 预期：跳过前导空白，正确读取第一个单词  
//  3. 检查点：前导空白跳过、单词截断、剩余字符丢弃  
// 易错点提醒：  
//  1. 数组溢出：max_len需≥1，留'\0'位置  
//  2. EOF处理：全空白输入需返回空字符串  
// 拓展思考：  
//  1. 如何返回单词长度？添加输出参数记录i  


// ------------------------------
// 题干：4. 类似题3，但限制单词最大长度（防止溢出）。  
// 知识要点：  
//  1. 增加max_len参数：控制单词最大长度（含'\0'）  
//  2. 结合前导空白跳过和长度限制，增强安全性  
// 总体逻辑：  
//  1. 函数读单词时，最多存储max_len-1个字符  
//  2. 主函数测试长度限制效果  

#include <stdio.h>

// 读取单词，限制最大长度max_len（含'\0'）
void read_limited_word(char *word, int max_len) {
    char ch;
    int i = 0;
    
    // 跳前导空白
    while ((ch = getchar()) != EOF && (ch == ' ' || ch == '\t' || ch == '\n'));
    if (ch == EOF) {
        word[0] = '\0';
        return;
    }
    
    // 读单词（最多max_len-1个字符）
    word[i++] = ch;
    while (i < max_len - 1) {
        ch = getchar();
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == EOF) break;
        word[i++] = ch;
    }
    word[i] = '\0';
    
    // 丢弃剩余字符
    while (ch != '\n' && ch != EOF) ch = getchar();
}

int main() {
    char word[10]; // 最多9个字符 + '\0'
    printf("输入单词（最多9字符）：\n");
    read_limited_word(word, 10);
    
    printf("单词：%s（长度：%zu）\n", word, strlen(word));
    return 0;
}

// 测试验证方案：  
//  1. 运行：输入"longword123"（10字符）→ 读"longword1"（9字符）  
//  2. 预期：单词长度≤9，前导空白跳过  
//  3. 检查点：数组截断、边界处理正确  
// 易错点提醒：  
//  1. max_len传0/1：导致数组溢出（主函数需保证max_len≥1）  
//  2. 忘记留'\0'：循环条件应为i < max_len-1  
// 拓展思考：  
//  1. 如何返回实际读取长度？添加int *len参数  


// ------------------------------
// 题干：5. 实现类似strchr的函数，查找字符首次出现位置，循环测试。  
// 知识要点：  
//  1. 指针遍历字符串：通过指针移动对比字符  
//  2. 函数返回值：找到返回字符指针，否则NULL  
//  3. 循环测试：主函数循环输入字符串和字符验证  
// 总体逻辑：  
//  1. 函数my_strchr遍历字符串，找到则返回指针，否则NULL  
//  2. 主函数循环输入，调用函数并输出结果  

#include <stdio.h>

// 查找c在str中首次出现的位置，返回指针或NULL
char *my_strchr(const char *str, char c) {
    while (*str != '\0') {
        if (*str == c) return (char *)str; // 找到，转换为char*
        str++;
    }
    return NULL; // 未找到
}

int main() {
    char str[100], ch;
    char *res;
    
    while (1) {
        printf("输入字符串（空行退出）：");
        if (fgets(str, 100, stdin) == NULL) break;
        // 去掉fgets的换行符
        char *nl = strchr(str, '\n');
        if (nl) *nl = '\0';
        if (str[0] == '\0') break; // 空字符串退出
        
        printf("输入查找字符：");
        scanf("%c", &ch);
        while (getchar() != '\n'); // 清理换行符
        
        res = my_strchr(str, ch);
        if (res) {
            printf("找到'%c'，位置：%ld，截取：%s\n", 
                   ch, res - str, res);
        } else {
            printf("未找到'%c'\n", ch);
        }
    }
    return 0;
}

// 测试验证方案：  
//  1. 运行：输入"hello"和'l' → 找到位置1，截取"llo"  
//  2. 预期：正确判断存在性，指针运算和截取正确  
//  3. 检查点：NULL判断、指针位置计算、输入清理  
// 易错点提醒：  
//  1. 指针类型转换：const char*转char*避免警告  
//  2. 输入缓冲区清理：scanf后必须清换行，否则影响fgets  
// 拓展思考：  
//  1. 如何实现strrchr（最后一次出现）？反向遍历  
//  2. 对比标准strchr：逻辑一致，效率可优化（汇编级）  