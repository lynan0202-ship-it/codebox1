// ------------------------------
// 题干：7. strncpy(s1, s2, n)函数把s2中的n个字符拷贝至s1中，截断s2，或者有必要的话在末尾添加空字符。如果s2的长度是n或多于n，目标字符串不能以空字符结尾。该函数返回s1。自己编写一个这样的函数，名为mystrncpy()。在一个完整的程序中测试该函数，使用一个循环给函数提供输入值。  
// 知识要点：  
//  1. 指针操作：遍历源字符串，复制最多 `n` 个字符到目标  
//  2. 边界处理：  
//     - 源字符串长度 ≥ n：目标不自动补 `\0`；  
//     - 源字符串长度 < n：目标补 `\0` 至 `n` 个字符。  
//  3. 函数返回值：目标字符串的首地址（同 `strncpy`）  
// 总体逻辑：  
//  1. 复制源字符串的前 `n` 个字符到目标（或源结束时停止）；  
//  2. 若源长度不足 `n`，补 `\0` 填充剩余位置；  
//  3. 主函数循环测试，验证拷贝结果。  

#include <stdio.h>
#include <string.h>  // 用于 `strlen`，辅助调试

// 模仿 strncpy 的功能：将 s2 的前 n 个字符拷贝到 s1
char *mystrncpy(char *s1, const char *s2, int n) {
    char *original_s1 = s1;  // 保存目标字符串首地址，用于返回

    // 步骤1：复制源字符串的字符（最多 n 个）
    for (int i = 0; i < n && *s2 != '\0'; i++) {
        *s1 = *s2;  // 复制当前字符
        s1++;       // 目标指针后移
        s2++;       // 源指针后移
    }

    // 步骤2：若源字符串提前结束（长度 < n），补 '\0' 到 n 个字符
    while (n > 0) {  // 剩余需要填充的位置：n - 已复制的字符数
        *s1 = '\0';  // 填充空字符
        s1++;
        n--;
    }

    return original_s1;  // 返回目标字符串首地址
}

int main() {
    char s1[50];  // 目标字符串（需足够大，避免溢出）
    char s2[50];  // 源字符串
    int n;        // 要复制的字符数

    printf("=== 测试 mystrncpy 函数 ===\n");
    printf("输入空字符串可退出程序。\n\n");

    while (1) {
        // 步骤1：输入源字符串 s2
        printf("请输入源字符串 s2：");
        if (fgets(s2, 50, stdin) == NULL) {
            break;  // EOF 退出
        }
        // 去掉换行符
        char *newline = s2;
        while (*newline != '\n' && *newline != '\0') {
            newline++;
        }
        *newline = '\0';

        if (s2[0] == '\0') {  // 空字符串，退出循环
            break;
        }

        // 步骤2：输入目标字符串 s1 的初始值（可空）
        printf("请输入目标字符串 s1 的初始值（可直接回车，代表空）：");
        fgets(s1, 50, stdin);
        newline = s1;
        while (*newline != '\n' && *newline != '\0') {
            newline++;
        }
        *newline = '\0';

        // 步骤3：输入要复制的字符数 n
        printf("请输入要复制的字符数 n：");
        scanf("%d", &n);
        // 清理换行符
        while (getchar() != '\n');

        // 步骤4：调用 mystrncpy 并输出结果
        char *result = mystrncpy(s1, s2, n);
        printf("→ 拷贝后 s1：\"%s\"（长度：%zu）\n\n", 
               result, strlen(result));
    }

    return 0;
}

// 测试验证方案：  
//  1. 怎么运行：  
//     • 编译：`gcc 7.c -o 7`  
//     • 执行：`./7`，输入测试用例（如：  
//       - 案例1：s2="hello", s1初始为"ABCDE", n=3 → s1 变为 "hel\0\0"（长度 5，前 3 个是 hel，后 2 个是 \0）；  
//       - 案例2：s2="abcdef", n=4 → s1 变为 "abcd"（长度 4，无结尾 \0，因为源长度 ≥ n）；  
//       - 案例3：s2="ab", n=5 → s1 变为 "ab\0\0\0"（长度 5，补 3 个 \0）。）  
//  2. 预期结果：  
//     • 源长度 ≥ n：目标前 n 个字符与源一致，无结尾 \0；  
//     • 源长度 < n：目标前源长度个字符与源一致，剩余补 \0。  
//  3. 检查点：  
//     • 复制的字符数是否正确（前 n 个或源全部）；  
//     • 补 \0 是否正确（源短于 n 时）；  
//     • 返回值是否为 s1 的首地址。  

// 易错点提醒：  
//  1. **缓冲区溢出**：目标字符串 s1 必须有至少 n 个字符的空间（如示例中 s1[50]），否则会导致未定义行为。  
//  2. **补 \0 逻辑**：循环需确保填充足够的 \0（剩余 n - 已复制字符数）。  
//  3. **源指针只读**：s2 是 `const char*`，确保函数不修改源字符串。  

// 拓展思考：  
//  1. **对比标准 `strncpy`**：标准函数行为与本实现一致，但需注意“源长度 ≥ n 时目标无 \0”的风险（需手动添加 \0）。  
//  2. **安全性增强**：添加参数检查（如 n ≤ 0 时直接返回，或检查 s1/s2 是否为 NULL）。  
//  3. **优化效率**：用指针直接操作内存（如 `memcpy` 批量复制），但需处理边界情况。  