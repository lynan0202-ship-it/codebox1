// ------------------------------
// 题干：编写一个程序，反序显示命令行参数的单词。例如，命令行参数是 see you later，该程序应打印 later you see。
// 知识要点：
//  1. main函数的命令行参数：`argc` 记录参数总数（含程序名），`argv` 是字符串数组，`argv[0]` 存程序名，`argv[1]` 起是用户参数。  
//  2. 循环遍历技巧：从最后一个参数（`argv[argc-1]`）往前遍历到 `argv[1]`，实现反序。  
//  3. 字符串输出控制：通过“先打首元素，后补空格”的方式，避免末尾多余空格。  
// 总体逻辑：  
//  1. 检查参数数量：若仅含程序名（`argc==1`），提示用户输入参数；否则进入反序处理。  
//  2. 打印最后一个参数（无前置空格），作为反序结果的开头。  
//  3. 从倒数第二个参数遍历到第一个用户参数（`argv[1]`），每个参数前加空格后打印。  
//  4. 末尾输出换行，保证格式规范。  

#include <stdio.h>

int main(int argc, char *argv[]) {
    // 情况1：用户未提供任何参数（仅运行程序）
    if (argc == 1) {
        printf("请在运行时传入参数，例如：./program see you later\n");
        return 0;
    }

    // 先打印最后一个参数（反序后的第一个单词，无前置空格）
    printf("%s", argv[argc - 1]);

    // 从倒数第二个参数遍历到第一个用户参数（argv[1]）
    for (int i = argc - 2; i >= 1; i--) {
        // 每个后续参数前加空格，保证单词间仅一个空格
        printf(" %s", argv[i]);
    }

    // 换行符收尾，让输出更整洁
    printf("\n");

    return 0;
}


// ------------------------------
// 测试验证方案：  
//  1. 怎么运行：  
//     - 编译：`gcc 13.c -o reverse_args`（或其他C编译器）。  
//     - 测试用例1（正常反序）：  
//       运行 `./reverse_args see you later` → 预期输出 `later you see`。  
//     - 测试用例2（单参数）：  
//       运行 `./reverse_args hello` → 预期输出 `hello`。  
//     - 测试用例3（无参数）：  
//       运行 `./reverse_args` → 预期输出提示文字。  
//  2. 预期结果：  
//     - 带参数时，严格反序输出，单词间一个空格，末尾无多余空格。  
//     - 无参数时，提示信息清晰，程序正常退出。  
//  3. 检查点：  
//     - 反序逻辑是否正确（如输入`a b c d` → 输出`d c b a`）。  
//     - 空格是否仅存在于单词之间（用文本编辑器查看末尾是否有空格）。  


// ------------------------------
// 易错点提醒：  
//  1. 循环范围错误：  
//     - 若把循环起始写成 `argc-1`，会重复打印最后一个参数（如 `later later you see`）。  
//     - 若循环结束条件写成 `i > 0`，会漏掉 `argv[1]`（如输入3个参数，只打2个）。  
//  2. 空格处理失误：  
//     - 直接用 `for` 循环打印 `"%s "`，会导致末尾多一个空格（如 `later you see `）。  
//  3. 忽略边缘情况：  
//     - 忘记处理 `argc==1`，程序无参数时可能让新手困惑（虽然不会崩溃，但体验差）。  


// ------------------------------
// 拓展思考：  
//  1. 处理带空格的参数：  
//     - 若用户想传入含空格的参数（如`"hello world"`），需用引号包裹，例如：  
//       `./reverse_args "hello world" foo` → 反序后输出 `foo "hello world"`（程序会正确识别`argv[1]`为`"hello world"`，`argv[2]`为`foo`）。  
//  2. 统计反序后的单词数：  
//     - 可在反序时增加计数器，输出如 `共3个单词：later you see`。  
//  3. 支持“忽略程序名”外的特定参数：  
//     - 比如过滤掉以`-`开头的选项（如`./reverse_args -v see you` → 只反序`see you`，忽略`-v`），可在循环时判断`argv[i]`的首字符。  


// ------------------------------
// 对比总结（命令行参数 vs 标准输入）：  
//  - **命令行参数**：  
//    ✔️ 优点：参数在程序启动时确定，适合简单、固定的输入。  
//    ✖️ 缺点：无法动态输入（运行后不能改参数），参数含空格时需用引号包裹。  
//  - **标准输入**（如`scanf`/`fgets`）：  
//    ✔️ 优点：支持运行中动态输入，适合交互场景。  
//    ✖️ 缺点：代码稍复杂，需处理输入结束（如Ctrl+D）。  
//  本题用命令行参数，更直接处理“启动时的单词列表”，逻辑更简洁。