

// ------------------------------
// 题干：16. 编写一个程序读取输入，直至读到文件结尾，然后把字符串打印出来。该程序识别和实现下面的命令行参数：  
//        -p  按原样打印  
//        -u  把输入全部转换成大写  
//        -l  把输入全部转换成小写  
//        如果没有命令行参数，则让程序像是使用了-p参数那样运行。  
// 知识要点：  
//  1. 命令行参数处理（argc统计参数个数，argv访问参数内容）  
//  2. 字符大小写转换（toupper/tolower函数，需包含<ctype.h>）  
//  3. 行读取（fgets函数，安全处理输入，避免缓冲区溢出）  
//  4. 循环控制（while循环处理输入，for循环处理字符转换）  
// 总体逻辑：  
//  1. 解析命令行参数，确定处理模式（默认-p，识别-u/-l）  
//  2. 循环读取输入行（直到EOF），每次读取一行内容  
//  3. 根据模式转换行内字符（大写、小写或原样）  
//  4. 输出转换后的行内容  

#include <stdio.h>
#include <ctype.h>  // 提供toupper、tolower函数

int main(int argc, char *argv[]) {
    // 定义处理模式：0=原样(-p)，1=转大写(-u)，2=转小写(-l)
    int mode = 0;  

    // 解析命令行参数（只处理第一个有效参数：-u或-l）
    if (argc >= 2) {  
        // 检查参数格式：必须是"-u"或"-l"（长度为2，首字符是'-'）
        if (argv[1][0] == '-' && argv[1][1] != '\0') {  
            if (argv[1][1] == 'u') {  
                mode = 1;  // 匹配-u，设为大写模式
            } else if (argv[1][1] == 'l') {  
                mode = 2;  // 匹配-l，设为小写模式
            }
            // 其他参数（如"-a"）视为无效，保持默认mode=0
        }
    }

    char line[1024];  // 存储每行输入（假设行长度≤1023）
    // 循环读取输入，直到文件结束（EOF）
    while (fgets(line, sizeof(line), stdin) != NULL) {  
        // 根据模式转换字符
        if (mode == 1) {  // 大写模式：逐个字符转大写
            for (int i = 0; line[i] != '\0'; i++) {  
                line[i] = toupper(line[i]);  // 小写字母转大写，其他字符不变
            }
        } else if (mode == 2) {  // 小写模式：逐个字符转小写
            for (int i = 0; line[i] != '\0'; i++) {  
                line[i] = tolower(line[i]);  // 大写字母转小写，其他字符不变
            }
        }
        // mode=0时不处理，直接输出

        printf("%s", line);  // 输出处理后的行（fgets已包含换行符）
    }

    return 0;
}


// 测试验证方案：  
//  1. 运行方式：  
//     • 编译：gcc -o prog16 prog16.c（或其他C编译器）  
//     • 直接运行：  
//       - 无参数：./prog16，输入内容后按回车，Ctrl+D（Linux）或Ctrl+Z（Windows）结束输入。  
//       - 指定参数：./prog16 -u （转大写）、./prog16 -l （转小写）。  
//     • 管道测试：echo "Hello 123" | ./prog16 -u → 应输出"HELLO 123"。  
//  2. 预期结果：  
//     • -p（默认）：输入内容原样输出（如输入"AbC"，输出"AbC"）。  
//     • -u：所有字母转大写（如输入"AbC"，输出"ABC"）。  
//     • -l：所有字母转小写（如输入"AbC"，输出"abc"）。  
//     • 特殊字符（数字、符号、换行）保持不变。  
//  3. 检查点：  
//     • 命令行参数是否正确识别（-u/-l生效，无效参数 fallback 到-p）。  
//     • 换行符是否保留（输入多行时，输出格式与输入一致）。  


// 易错点提醒：  
//  1. 忘记包含<ctype.h>：导致toupper/tolower未定义，编译报错。  
//  2. 参数越界访问：若参数是"-"（长度1），访问argv[1][1]会触发未定义行为。可通过`argv[1][1] != '\0'`提前判断。  
//  3. 缓冲区溢出：若输入行超过1023字符，fgets会截断内容。实际应用需动态扩容，练习中可忽略。  


// 拓展思考：  
//  1. 支持多参数优先级：若输入`./prog16 -u -l`，可修改代码遍历所有参数，取最后一个有效模式（如示例中最终模式为-l）。  
//  2. 处理空行：当前逻辑已支持（空行也会被读取和输出，符合题意）。  
//  3. 性能优化：对于超长行，可改用指针遍历字符（`char *p = line; *p; p++`），减少数组索引计算。  


// 对比说明：  
//  fgets vs gets：  
//  • fgets：安全，需指定缓冲区大小，会保留换行符，适合行读取。  
//  • gets：危险，无法限制输入长度，已被废弃（C11标准移除）。  
//  实际开发必须用fgets。  

//  toupper/tolower 细节：  
//  • 只转换ASCII字母（A-Z/a-z），对数字、符号、非ASCII字符（如中文）无影响。  
//  • 函数参数是int类型（实际是字符的ASCII值），需确保输入是有效字符（否则行为未定义）。