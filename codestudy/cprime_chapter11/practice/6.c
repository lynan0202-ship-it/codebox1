// ------------------------------
// 题干：6. 编写一个名为 is_within() 的函数，接受一个字符和一个指向字符串的指针作为两个函数形参。如果指定字符在字符串中，该函数返回一个非零值（即为真）。否则，返回 0（即为假）。在一个完整的程序中测试该函数，使用一个循环给函数提供输入值。  
// 知识要点：  
//  1. 指针遍历字符串：通过 `str++` 移动指针，访问每个字符  
//  2. 函数返回值：非零表示“真”，零表示“假”（C 语言布尔逻辑）  
//  3. 循环测试：主函数循环接收输入，验证函数逻辑  
// 总体逻辑：  
//  1. 函数遍历字符串指针，逐个对比目标字符  
//  2. 找到字符则返回 `1`，遍历结束未找到则返回 `0`  
//  3. 主函数循环输入字符串和字符，调用函数并输出结果  

#include <stdio.h>

// 判断字符 ch 是否在字符串 str 中
int is_within(char ch, const char *str) {
    while (*str != '\0') {  // 遍历到字符串结束符 '\0'
        if (*str == ch) {   // 找到目标字符
            return 1;       // 返回非零值（真）
        }
        str++;  // 指针后移，检查下一个字符
    }
    return 0;  // 遍历结束，未找到（假）
}

int main() {
    char input_str[100];  // 存储输入的字符串
    char target_ch;       // 存储要查找的字符
    int result;           // 存储函数返回值

    printf("=== 测试 is_within 函数 ===\n");
    printf("输入空字符串可退出程序。\n\n");

    while (1) {
        // 步骤1：输入字符串
        printf("请输入字符串：");
        if (fgets(input_str, 100, stdin) == NULL) {
            break;  // EOF 退出
        }
        // 去掉 fgets 自动添加的换行符
        char *newline = input_str;
        while (*newline != '\n' && *newline != '\0') {
            newline++;
        }
        *newline = '\0';  // 替换换行符为结束符

        if (input_str[0] == '\0') {  // 空字符串，退出循环
            break;
        }

        // 步骤2：输入目标字符
        printf("请输入要查找的字符：");
        scanf("%c", &target_ch);
        // 清理输入缓冲区的换行符（否则会影响下次输入）
        while (getchar() != '\n');

        // 步骤3：调用函数并输出结果
        result = is_within(target_ch, input_str);
        if (result) {
            printf("→ 字符 '%c' 在字符串 \"%s\" 中\n\n", target_ch, input_str);
        } else {
            printf("→ 字符 '%c' 不在字符串 \"%s\" 中\n\n", target_ch, input_str);
        }
    }

    return 0;
}

// 测试验证方案：  
//  1. 怎么运行：  
//     • 编译：`gcc 6.c -o 6`  
//     • 执行：`./6`，输入字符串和字符（如：  
//       - 输入字符串 `hello`，字符 `l` → 预期“存在”；  
//       - 输入字符串 `world`，字符 `x` → 预期“不存在”；  
//       - 输入空字符串 → 退出程序。）  
//  2. 预期结果：  
//     • 找到字符时输出“存在”，未找到时输出“不存在”。  
//  3. 检查点：  
//     • 函数是否遍历到字符串末尾（包括最后一个有效字符）；  
//     • 输入的换行符是否被正确清理（避免影响下次输入）。  

// 易错点提醒：  
//  1. **输入缓冲区残留**：`scanf` 后如果不清理换行符，下次 `fgets` 会读取到换行符，导致逻辑错误。  
//  2. **指针遍历逻辑**：`while (*str != '\0')` 等价于 `while (*str)`，但初学者易漏写结束条件。  
//  3. **返回值混淆**：记得“找到返回 `1`，未找到返回 `0`”，不要写反。  

// 拓展思考：  
//  1. **忽略大小写**：引入 `<ctype.h>`，将字符转成小写后对比（如 `tolower(*str) == tolower(ch)`）。  
//  2. **对比 `strchr`**：`strchr` 返回字符指针，`is_within` 返回布尔值，逻辑相似但用途不同。  


