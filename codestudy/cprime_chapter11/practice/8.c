
// ------------------------------
// 题干：8. 编写一个名为 string_in() 的函数，接受两个指向字符串的指针作为参数。如果第2个字符串包含在第1个字符串中，该函数将返回第1个字符串开始的地址。例如，string_in("hats", "at") 将返回 hats 中 a 的地址。否则，该函数返回空指针。在一个完整的程序中测试该函数，使用一个循环给函数提供输入值。  
// 知识要点：  
//  1. 字符串匹配（暴力匹配算法）：逐字符对比主串和子串  
//  2. 指针遍历：通过指针移动访问字符串的每个字符  
//  3. 函数返回值：匹配成功返回主串中匹配位置的指针，失败返回 NULL  
//  4. 循环测试：主函数循环接收输入，验证匹配逻辑  
// 总体逻辑：  
//  1. 函数遍历主串（s1）的每个字符，作为匹配起始点  
//  2. 对每个起始点，同时遍历主串和子串（s2），逐字符对比  
//  3. 若子串遍历完成（匹配成功），返回主串的起始匹配指针  
//  4. 若主串遍历完仍未匹配，返回 NULL  
//  5. 主函数循环输入两个字符串，调用函数并输出结果  

#include <stdio.h>
#include <string.h>  // 用于 strlen 辅助计算（可选，优化判断）

// 判断 s2 是否包含在 s1 中，返回匹配起始地址或 NULL
char *string_in(const char *s1, const char *s2) {
    // 子串为空时，约定返回 s1 首地址（题目未明确，此处处理为特殊情况）
    if (*s2 == '\0') {
        return (char *)s1;
    }

    // 遍历主串 s1，每个字符作为匹配起始点
    while (*s1 != '\0') {
        const char *p1 = s1;  // 主串当前起始指针（会移动）
        const char *p2 = s2;  // 子串指针（会移动）

        // 逐字符对比，直到子串结束或字符不匹配
        while (*p1 == *p2) {
            p1++;
            p2++;
            if (*p2 == '\0') {  // 子串遍历完成 → 匹配成功
                return (char *)s1;  // 返回主串的起始匹配位置
            }
        }

        s1++;  // 主串指针后移，尝试下一个起始点
    }

    return NULL;  // 主串遍历完，未找到匹配
}

int main() {
    char s1[100], s2[100];  // 存储输入的两个字符串
    char *result;           // 存储函数返回值

    printf("=== 测试 string_in 函数 ===\n");
    printf("输入空字符串可退出程序（先输 s1，再输 s2）。\n\n");

    while (1) {
        // 步骤1：输入主串 s1
        printf("请输入主串 s1：");
        if (fgets(s1, 100, stdin) == NULL) {
            break;  // EOF 退出
        }
        // 去掉 fgets 自动添加的换行符
        char *newline = s1;
        while (*newline != '\n' && *newline != '\0') {
            newline++;
        }
        *newline = '\0';

        if (s1[0] == '\0') {  // 空字符串，退出循环
            break;
        }

        // 步骤2：输入子串 s2
        printf("请输入子串 s2：");
        if (fgets(s2, 100, stdin) == NULL) {
            break;
        }
        newline = s2;
        while (*newline != '\n' && *newline != '\0') {
            newline++;
        }
        *newline = '\0';

        if (s2[0] == '\0') {  // 子串为空，特殊处理（按约定返回 s1 首地址）
            result = string_in(s1, s2);
        } else {
            // 步骤3：调用函数，判断子串是否过长（优化：提前终止）
            if (strlen(s2) > strlen(s1)) {
                result = NULL;
            } else {
                result = string_in(s1, s2);
            }
        }

        // 步骤4：输出结果
        if (result != NULL) {
            printf("→ 子串 \"%s\" 匹配主串，起始位置：%ld，匹配内容：\"%s\"\n\n", 
                   s2, result - s1, result);
        } else {
            printf("→ 子串 \"%s\" 未在主串 \"%s\" 中找到\n\n", s2, s1);
        }
    }

    return 0;
}

// 测试验证方案：  
//  1. 怎么运行：  
//     • 编译：`gcc 8.c -o 8`  
//     • 执行：`./8`，输入测试用例（示例）：  
//       - 案例1：s1="hats"，s2="at" → 预期返回 `a` 的地址（偏移1），输出 `匹配内容："ats"`；  
//       - 案例2：s1="hello"，s2="world" → 预期未找到；  
//       - 案例3：s1="abcabc"，s2="abc" → 匹配起始位置0，输出 `"abcabc"`；  
//       - 案例4：s2为空 → 按约定返回 s1 首地址，输出 `匹配内容："（s1内容）"`。  
//  2. 预期结果：  
//     • 匹配成功时，输出起始偏移和后续内容；  
//     • 匹配失败时，提示未找到。  
//  3. 检查点：  
//     • 指针运算是否正确（`result - s1` 计算偏移）；  
//     • 子串为空的特殊处理是否符合预期；  
//     • 主串剩余长度小于子串时，是否提前终止（优化逻辑）。  

// 易错点提醒：  
//  1. **指针越界**：遍历主串时未检查剩余长度，可能导致子串访问越界（通过 `strlen` 提前判断可避免）。  
//  2. **子串为空的处理**：题目未明确，需约定逻辑（此处返回主串首地址）。  
//  3. **输入清理**：`fgets` 会读取换行符，必须手动替换为 `\0`，否则影响字符串匹配。  

// 拓展思考：  
//  1. **优化匹配效率**：使用 KMP 算法减少重复对比（适合长字符串），但实现更复杂。  
//  2. **忽略大小写**：引入 `<ctype.h>`，将字符转小写后对比（如 `tolower(*p1) == tolower(*p2)`）。  
//  3. **多匹配位置**：若需返回所有匹配位置，可修改函数返回数组或链表存储结果。  
