// ------------------------------
// 题干：编写一个通过命令行运行的程序计算幂。第1个命令行参数是double类型的数，作为幂的底数，第2个参数是整数，作为幂的指数。
// 知识要点：
//  1. 命令行参数处理（argc统计参数个数，argv存储参数字符串）
//  2. 字符串转数值（atof解析double，atoi解析int）
//  3. 循环结构实现幂运算（分正、负、零指数处理）
//  4. 条件判断（参数合法性检查、指数符号判断）
// 总体逻辑：
//  1. 检查命令行参数数量：必须输入2个参数（程序名+2参数，共3个），否则提示用法
//  2. 转换参数：将字符串参数转为double底数和int指数
//  3. 计算幂： 
//     - 正指数：循环乘底数exponent次 
//     - 负指数：先算绝对值的幂，再取倒数 
//     - 零指数：结果默认1（简单处理，忽略0^0矛盾）
//  4. 输出计算结果
#include <stdio.h>
#include <stdlib.h> // 提供atof、atoi函数

int main(int argc, char *argv[]) {
    // 步骤1：检查命令行参数是否足够
    if (argc != 3) { 
        // argv[0]是程序本身的名字，提示用户正确用法
        printf("用法：%s <底数(小数或整数)> <指数(整数)>\n", argv[0]); 
        return 1; // 非0返回值表示程序异常退出
    }

    // 步骤2：转换命令行参数为数值类型
    double base = atof(argv[1]); // 把第一个参数转成double，比如"2.5"→2.5
    int exponent = atoi(argv[2]); // 把第二个参数转成int，比如"-3"→-3

    double result = 1.0; // 结果初始值，因为任何数^0=1（后续覆盖计算）

    // 步骤3：根据指数符号计算幂
    if (exponent > 0) { 
        // 正指数：循环相乘exponent次
        for (int i = 0; i < exponent; i++) {
            result *= base; 
        }
    } else if (exponent < 0) { 
        // 负指数：先算绝对值的幂，再取倒数
        int abs_exp = -exponent; // 转成正数，比如-2→2
        for (int i = 0; i < abs_exp; i++) {
            result *= base; 
        }
        result = 1.0 / result; // 负数指数是倒数，比如2^-2=1/(2^2)
    }
    // 指数为0时，result保持1.0（已初始化）

    // 步骤4：输出结果
    printf("%lf ^ %d = %lf\n", base, exponent, result);

    return 0; // 正常退出
}

// 测试验证方案：
//  1. 怎么运行： 
//     - 编译：gcc -o power power.c（或其他编译器）
//     - 运行示例：
//       ./power 2 3       → 测试正整数指数
//       ./power 5 -2      → 测试负整数指数
//       ./power 3.5 0     → 测试零指数
//       ./power 0.5 4     → 测试小数底数
//  2. 预期结果： 
//     - 2^3 → 8.000000
//     - 5^-2 → 0.040000（1/(5*5)）
//     - 3.5^0 → 1.000000
//     - 0.5^4 → 0.062500（0.5*0.5*0.5*0.5）
//  3. 检查点： 
//     - 负指数是否正确取倒数 
//     - 小数底数计算是否准确 
//     - 零指数是否输出1 

// 易错点提醒：
//  1. 忘记检查argc：如果用户没传参数，程序会访问argv[1]/argv[2]导致崩溃 
//  2. 类型转换陷阱：atoi会把非数字开头的字符串转0（比如"abc3"→0），但程序不会报错，需保证输入合法 
//  3. 0^0处理：程序输出1，但数学上无意义，实际场景需添加判断（如if(base==0 && exponent==0)提示错误） 

// 拓展思考：
//  1. 支持小数指数：把exponent用atof转换（如double exp = atof(argv[2])），然后调用math.h的pow(base, exp)（自己实现小数指数极复杂） 
//  2. 处理非法输入：比如底数为0且指数为负（0^-1），会导致除以0错误，需添加if(base==0 && exponent<0)提示错误 
//  3. 优化计算效率：用“快速幂”算法（二分法）替代循环，减少乘法次数（比如计算2^8，只需3次乘法：2^2→2^4→2^8） 

// 对比说明：
//  手动循环 vs 库函数pow： 
//  - 手动循环：逻辑直观，适合学习，但效率低（指数大时慢），且需处理边界（如负指数、0^0） 
//  - 库函数pow：效率高（内部用数学优化），处理所有边界情况（如0^0返回NaN），但需包含math.h并链接数学库（编译时加-lm）