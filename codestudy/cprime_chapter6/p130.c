#include <stdio.h>

int main(void) {
    // ———— 用法 1：基础计数（固定步长递增） ————
    // 初始化 n=1 → 测试 n<=5 → 每次 n++
    for (int n = 1; n <= 5; n++) {
        // 输出: 1 2 3 4 5 
        printf("用法1: 基础计数 → n = %d\n", n);
    }


    // ———— 用法 2：自定义步长（递增 2） ————
    // 初始化 n=2 → 测试 n<10 → 每次 n += 2（步长 2）
    for (int n = 2; n < 10; n += 2) {
        // 输出: 2 4 6 8 
        printf("用法2: 自定义步长 → n = %d\n", n);
    }


    // ———— 用法 3： I 整数存储） ————
    // 初始化 ch='A' → 测试 ch<='E' → 每次 ch++
    // 字符本质是整数（ASCII 码），所以能像数字一样递增
    for (char ch = 'A'; ch <= 'E'; ch++) {
        // 输出: A(65) B(66) C(67) D(68) E(69)
        printf("用法3: 字符遍历 → ch = %c (ASCII: %d)\n", ch, ch);
    }


    // ———— 用法 4：递减循环（从大到小计数） ————
    // 初始化 n=5 → 测试 n>=1 → 每次 n--
    for (int n = 5; n >= 1; n--) {
        // 输出: 5 4 3 2 1 
        printf("用法4: 递减循环 → n = %d\n", n);
    }


    // ———— 用法 5：倍数增长（乘法代替加法） ————
    // 初始化 debt=100 → 测试 debt<200 → 每次 debt *= 1.1（增长 10%）
    for (double debt = 100.0; debt < 200.0; debt *= 1.1) {
        // 输出: 100.00 → 110.00 → 121.00 → ...（直到接近 200）
        printf("用法5: 倍数增长 → debt = %.2f\n", debt);
    }


    // ———— 用法 6：省略初始化（外部赋值） ————
    int x = 1; // 提前在循环外初始化
    // 省略第一个表达式（初始化），直接用外部定义的 x
    for (; x <= 3; x++) {
        // 输出: x=1 → x=2 → x=3 
        printf("用法6: 省略初始化 → x = %d\n", x);
    }


    // ———— 用法 7：省略更新（内部手动控制） ————
    int y = 1;
    // 省略第三个表达式（更新），循环内手动处理 y++
    for (y = 1; y <= 3; ) {
        printf("用法7: 省略更新 → y = %d\n", y);
        y++; // 必须手动更新，否则死循环！
    }


    // ———— 用法 8：省略测试条件（用 break 控制退出） ————
    // 三个表达式全写，但测试条件恒为 1（永真）
    for (int z = 1; 1; z++) { 
        printf("用法8: 省略测试（break 控制）→ z = %d\n", z);
        if (z == 3) {
            break; // 手动 break 退出，否则无限循环
        }
    }


    // ———— 用法 9：复杂表达式（多变量关联） ————
    int a = 1, b = 10;
    // 初始化、测试、更新都用复杂逻辑：
    //  - 初始化：a=1, b=10
    //  - 测试：a < 5 且 b > 5
    //  - 更新：a 自增，b 自减
    for (; a < 5 && b > 5; a++, b--) {
        // 输出: 
        // a=1, b=10 
        // a=2, b=9 
        // a=3, b=8 
        // a=4, b=7 
        printf("用法9: 复杂表达式 → a = %d, b = %d\n", a, b);
    }


    return 0;
}
/*
核心逻辑对照表（和教程知识点一一对应）
用法编号	教程知识点对应	关键注释说明
用法 1	基础 for 语法	标准三段式：初始化; 测试; 更新，最基础的 “固定次数循环”
用法 2	自定义步长	用 n += 2 代替 n++，实现 “非 1 步长” 递增
用法 3	字符遍历	利用 “字符本质是 ASCII 整数”，用 char 做循环变量
用法 4	递减循环	测试条件 n >= 1 + 更新 n--，实现 “从大到小” 计数
用法 5	倍数增长	用 debt *= 1.1 代替加法，体现 “几何增长”（教程里的债务示例逻辑）
用法 6	省略初始化	初始化放到循环外，for(; 测试; 更新)，灵活处理 “外部已有变量” 场景
用法 7	省略更新	更新逻辑写在循环内，for(初始化; 测试; ) + 手动 y++，适合 “复杂更新逻辑”
用法 8	省略测试条件	测试条件写 1（永真），用 break 手动退出，教程里 “无限循环 + 手动控制” 场景
用法 9	复杂表达式	测试条件用 && 关联多变量，更新用 a++, b--，体现 for 表达式的灵活性
教程核心知识点强化
for 语法本质：
for(初始化; 测试; 更新) 是 “入口条件循环”，先判断测试条件，再执行循环体，所以可能一次都不执行。
省略表达式的风险：
省略初始化 / 更新：必须手动处理变量，否则容易死循环（如用法 7 漏写 y++ 就会无限循环）。
省略测试条件：必须用 break 控制退出，否则永远跑下去（用法 8 示例）。
字符与整数的关联：
教程强调 “字符内部是整数存储（ASCII 码）”，所以 for(char ch='A'; ...) 本质和数字循环一样，只是表现为字符（用法 3 验证这一点）。
灵活控制循环：
for 不是只能 “固定次数 + 简单递增”，通过省略表达式、break、复杂条件，能处理倍数增长、手动更新、多变量关联等场景（用法 5 - 9 覆盖这些灵活用法）。
把代码跑一遍，结合注释和对照表，就能彻底掌握 for 循环的 9 种典型用法啦，遇到类似场景直接 “对号入座”～
*/
/*
用法1: 基础计数 → n = 1
用法1: 基础计数 → n = 2
用法1: 基础计数 → n = 3
用法1: 基础计数 → n = 4
用法1: 基础计数 → n = 5
用法2: 自定义步长 → n = 2
用法2: 自定义步长 → n = 4
用法2: 自定义步长 → n = 6
用法2: 自定义步长 → n = 8
用法3: 字符遍历 → ch = A (ASCII: 65)
用法3: 字符遍历 → ch = B (ASCII: 66)
用法3: 字符遍历 → ch = C (ASCII: 67)
用法3: 字符遍历 → ch = D (ASCII: 68)
用法3: 字符遍历 → ch = E (ASCII: 69)
用法4: 递减循环 → n = 5
用法4: 递减循环 → n = 4
用法4: 递减循环 → n = 3
用法4: 递减循环 → n = 2
用法4: 递减循环 → n = 1
用法5: 倍数增长 → debt = 100.00
用法5: 倍数增长 → debt = 110.00
用法5: 倍数增长 → debt = 121.00
用法5: 倍数增长 → debt = 133.10
用法5: 倍数增长 → debt = 146.41
用法5: 倍数增长 → debt = 161.05
用法5: 倍数增长 → debt = 177.16
用法5: 倍数增长 → debt = 194.87
用法6: 省略初始化 → x = 1
用法6: 省略初始化 → x = 2
用法6: 省略初始化 → x = 3
用法7: 省略更新 → y = 1
用法7: 省略更新 → y = 2
用法7: 省略更新 → y = 3
用法8: 省略测试（break 控制）→ z = 1
用法8: 省略测试（break 控制）→ z = 2
用法8: 省略测试（break 控制）→ z = 3
用法9: 复杂表达式 → a = 1, b = 10
用法9: 复杂表达式 → a = 2, b = 9
用法9: 复杂表达式 → a = 3, b = 8
用法9: 复杂表达式 → a = 4, b = 7
*/