#include <stdio.h>

int main() {
    // 存储 2 的幂：2^0 ~ 2^7
    int arr[8];  

    // for 循环赋值：arr[i] = 2^i
    for (int i = 0; i < 8; i++) {  
        // 2^0=1，2^1=2，... 2^7=128
        arr[i] = 1 << i; // 等价于 pow(2, i)，效率更高（整数幂推荐位运算 ）

        /*
        这句代码 arr[i] = 1 << i; 利用了位运算来高效计算 2 的 i 次方，我们来详细解释：
核心原理：左移运算（<<）
在二进制中，将一个数向左移动 n 位，等价于将这个数乘以 2 的 n 次方。
例如：
二进制 1（十进制 1）左移 1 位 → 10（十进制 2 = 1×2¹）
二进制 10（十进制 2）左移 1 位 → 100（十进制 4 = 2×2¹ = 1×2²）
二进制 1 左移 i 位 → 结果是 2 的 i 次方
代码拆解：1 << i
1 是初始值（二进制为 000...0001）
<< i 表示将 1 向左移动 i 位
结果等价于数学中的 2ⁱ（2 的 i 次方）
举例：
当 i=0 时：1 << 0 → 1（不移动，2⁰=1）
当 i=1 时：1 << 1 → 2（2¹=2）
当 i=2 时：1 << 2 → 4（2²=4）
当 i=3 时：1 << 3 → 8（2³=8）
... 以此类推
为什么比 pow(2, i) 更好？
效率更高：
位运算（<<）是 CPU 直接支持的底层操作，执行速度远快于 pow 函数（数学库函数，需要复杂计算）。
避免类型问题：
pow 函数返回 double 类型，可能有精度误差（如 pow(2, 3) 理论上是 8，但实际可能是 7.999999...），而 1 << i 直接得到整数，无误差。
代码更简洁：
对于整数幂的场景，1 << i 比 pow(2, i) 更直观，且无需引入数学库（#include <math.h>）。
        */
    }

    int i = 0;
    // do-while 循环输出（至少执行一次 ）
    do {  
        printf("%d ", arr[i]);
        i++;
    } while (i < 8); // 条件：i < 8 

    printf("\n");
    return 0;
}

/*
1 2 4 8 16 32 64 128 
*/