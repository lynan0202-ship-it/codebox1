### 1. 总结主题（C11 对齐特性核心知识要点）
- **对齐的本质**：变量在内存中的存储位置规则，系统为提升访问效率，会让变量按“特定字节数”对齐（如 `double` 常按 8 字节对齐，`char` 按 1 字节对齐）。
- **`_Alignof` 运算符**：用于查询**类型**的对齐要求（返回该类型相邻地址的字节数，通常是 2 的非负整数次幂）。
- **`_Alignas` 说明符**：用于指定**变量/类型**的对齐值，但指定值不能小于类型的“基本对齐值”。
- **对齐的动态内存分配**：`aligned_alloc(size_t alignment, size_t size)` 函数可分配满足“指定对齐要求”的动态内存，要求 `size` 是 `alignment` 的倍数，分配后需用 `free()` 释放。


### 2. 内容逻辑梳理（从“对齐基础”到“工具与实践”）
1. **对齐的必要性**：
   - 为最大化效率，系统会对变量做对齐（如 `double` 按 8 字节对齐时，CPU 可一次读取完整数据）。
   - 硬件交互（如设备寄存器读写）、特殊指令（如 SIMD）等场景，对内存对齐有强制要求。
2. **查询对齐：`_Alignof`**：
   通过 `_Alignof(类型)` 可获取该类型的对齐字节数（如 `_Alignof(double)` 在多数系统中返回 `8`）。
3. **指定对齐：`_Alignas`**：
   在变量或类型声明时，用 `_Alignas(对齐值)` 修饰，让其内存地址满足指定对齐（如 `char _Alignas(double) c;` 让 `char` 变量 `c` 按 `double` 的对齐要求存储）。
4. **动态内存的对齐分配**：
   普通 `malloc` 无法保证特殊对齐，`aligned_alloc` 则可通过“对齐值（需为 2 的幂）”和“字节数（需是对齐值的倍数）”，分配满足严格对齐的内存，适配硬件/高性能场景。


### 3. 编程知识点：`_Alignof`、`_Alignas` 与 `aligned_alloc` 示例
```c
#include <stdio.h>
#include <stdalign.h>  // 提供 _Alignas、_Alignof 的标准支持
#include <stdlib.h>    // 提供 aligned_alloc、free

int main(void) {
    // ---------- 1. 用 _Alignof 查询类型对齐 ----------
    printf("char 对齐要求: %zu\n", _Alignof(char));
    printf("int 对齐要求: %zu\n", _Alignof(int));
    printf("double 对齐要求: %zu\n", _Alignof(double));

    // ---------- 2. 用 _Alignas 指定变量对齐 ----------
    char c_normal;                // 普通 char，对齐为 1
    char _Alignas(double) c_align; // 按 double 对齐（通常为 8）
    double d_normal;              // 普通 double，对齐为 8

    printf("c_normal 地址: %p\n", (void *)&c_normal);
    printf("c_align 地址: %p\n", (void *)&c_align);
    printf("d_normal 地址: %p\n", (void *)&d_normal);

    // ---------- 3. 用 aligned_alloc 分配对齐内存 ----------
    // 分配 32 字节，要求 16 字节对齐（16 是 2 的幂，且 32 是 16 的倍数）
    void *ptr = aligned_alloc(16, 32);
    if (ptr != NULL) {
        printf("对齐内存地址: %p\n", ptr);
        free(ptr); // 释放内存
    } else {
        printf("aligned_alloc 分配失败\n");
    }

    return 0;
}
```
**说明**：
- `_Alignof(类型)` 直接返回类型的对齐字节数，帮助开发者了解系统对齐规则。
- `_Alignas(对齐值)` 修饰变量后，变量地址会满足指定对齐（如 `c_align` 的地址通常是 8 的倍数）。
- `aligned_alloc` 解决了“动态内存需特殊对齐”的需求（如硬件驱动、高性能计算场景），分配后需用 `free` 释放。


### 4. 对比表格（普通内存分配 vs 对齐内存分配）
| 对比项                | 普通内存分配（`malloc`）| 对齐内存分配（`aligned_alloc`）|
|-----------------------|------------------------------------------|-----------------------------------------------|
| **对齐保证**          | 仅保证“基本对齐”（可能不满足特殊需求，如 `double` 8 字节对齐） | 严格保证“指定对齐值”（由第一个参数控制）|
| **参数要求**          | 仅需指定总字节数 `size`                     | 需指定 `alignment`（2 的幂）和 `size`（需是 `alignment` 的倍数） |
| **适用场景**          | 无特殊对齐要求的普通内存分配                 | 硬件交互、SIMD 指令、需要严格内存布局的场景       |
| **头文件**            | `<stdlib.h>`                              | `<stdlib.h>`                                  |
| **释放方式**          | `free()`                                  | `free()`                                      |


### 5. 扩展知识点
- **对齐与性能**：对齐的内存访问（如 CPU 读取 8 字节对齐的 `double`）比非对齐访问快得多，因为 CPU 可“一次性读取完整数据”，避免多次访问和数据拼接。
- **编译器扩展**：GCC 等编译器有非标准对齐扩展（如 `__attribute__((aligned(8)))`），但 C11 的 `_Alignas`/`_Alignof` 是**标准特性**，可移植性更好。
- **结构体的对齐**：结构体的整体对齐值由“成员中最大的对齐值”决定；若需自定义结构体对齐，可使用 `_Alignas` 修饰结构体（如 `struct _Alignas(16) MyStruct { ... };`）。
- **`stdalign.h` 的宏别名**：该头文件为 `_Alignas`/`_Alignof` 提供了更简洁的宏 `alignas`/`alignof`（需编译器支持），代码可写成 `alignof(double)` 或 `alignas(double) char c;`。