```c
/*
代码名称：位操作综合示例
知识要点总结：
- 位运算：包含按位与（&）、或（|）、非（~）、异或（^）、左移（<<）、右移（>>）的基本操作。
- 位字段：通过结构体定义位字段，实现数据的紧凑存储（如用1位存布尔值、3位存颜色索引等）。
- 对齐特性（C11）：使用`_Alignof`查询类型的对齐要求，使用`_Alignas`指定变量的对齐值。
代码总体逻辑说明：
1. 演示位运算：对一个整数进行按位与、或、非、异或、移位操作，并打印二进制与十进制结果。
2. 定义位字段结构体：封装“透明度、填充色、边框样式、边框厚度”等属性，展示位字段的紧凑存储与访问。
3. 展示对齐特性：用`_Alignof`查询不同类型的对齐要求，用`_Alignas`指定变量对齐并打印地址验证。
*/

#include <stdio.h>
#include <stdalign.h>  // 用于C11的_Alignas和_Alignof

// ---------- 位运算演示函数 ----------
void bit_operations_demo() {
    unsigned int num = 0b10101010;  // 二进制数，十进制为170
    unsigned int mask = 0b00001111; // 低4位掩码

    printf("=== 位运算演示 ===\n");
    printf("原始数 num = 0b10101010 (十进制: %u)\n", num);
    printf("掩码 mask = 0b00001111 (十进制: %u)\n", mask);

    // 按位与：保留低4位
    unsigned int and_result = num & mask;
    printf("num & mask = 0b%08b (十进制: %u) —— 保留低4位\n", and_result, and_result);

    // 按位或：低4位置1
    unsigned int or_result = num | mask;
    printf("num | mask = 0b%08b (十进制: %u) —— 低4位置1\n", or_result, or_result);

    // 按位非：所有位取反（unsigned避免符号位问题）
    unsigned int not_result = ~num;
    printf("~num = 0b%08b (十进制: %u) —— 所有位取反\n", not_result, not_result);

    // 按位异或：低4位翻转
    unsigned int xor_result = num ^ mask;
    printf("num ^ mask = 0b%08b (十进制: %u) —— 低4位翻转\n", xor_result, xor_result);

    // 左移2位：低位补0
    unsigned int shift_left = num << 2;
    printf("num << 2 = 0b%08b (十进制: %u) —— 左移2位，低位补0\n", shift_left, shift_left);

    // 右移2位：无符号，高位补0
    unsigned int shift_right = num >> 2;
    printf("num >> 2 = 0b%08b (十进制: %u) —— 右移2位，高位补0\n\n", shift_right, shift_right);
}

// ---------- 位字段演示函数 ----------
// 边框样式常量
#define SOLID 0
#define DOTTED 1
#define DASHED 2

// 颜色索引常量
#define BLACK 0
#define RED 1
#define GREEN 2
#define YELLOW 3
#define BLUE 4
#define MAGENTA 5
#define CYAN 6
#define WHITE 7

// 位字段结构体：紧凑存储方框属性
struct BoxProps {
    unsigned int opaque : 1;           // 1位：1=不透明，0=透明
    unsigned int fill_color : 3;       // 3位：0-7对应8种颜色
    unsigned int border_style : 2;     // 2位：0-2对应3种边框样式
    unsigned int : 0;                  // 宽度为0，使下一字段对齐到新的unsigned int
    unsigned int border_thickness : 4; // 4位：边框厚度（0-15）
};

void bitfield_demo() {
    // 初始化位字段结构体
    struct BoxProps box = {1, CYAN, DASHED, 3}; 

    printf("=== 位字段演示 ===\n");
    printf("透明度：%s\n", box.opaque ? "不透明" : "透明");
    // 颜色名称映射（简化版）
    const char *colors[] = {"黑", "红", "绿", "黄", "蓝", "品红", "青", "白"};
    printf("填充色：%s\n", colors[box.fill_color]);
    // 边框样式名称映射
    const char *styles[] = {"实线", "点线", "虚线"};
    printf("边框样式：%s\n", styles[box.border_style]);
    printf("边框厚度：%u\n\n", box.border_thickness);
}

// ---------- 对齐特性演示函数（C11） ----------
void alignment_demo() {
    printf("=== 对齐特性演示（C11）===\n");
    // 查询不同类型的对齐要求
    printf("char 类型的对齐要求：%zu 字节\n", _Alignof(char));
    printf("int 类型的对齐要求：%zu 字节\n", _Alignof(int));
    printf("double 类型的对齐要求：%zu 字节\n", _Alignof(double));

    // 指定变量的对齐（让char按double的对齐要求存储）
    char c_normal;
    char _Alignas(double) c_aligned; // 强制c_aligned按double的对齐值存储
    double d_normal;

    printf("普通char变量地址：%p\n", (void *)&c_normal);
    printf("按double对齐的char变量地址：%p\n", (void *)&c_aligned);
    printf("普通double变量地址：%p\n\n", (void *)&d_normal);
    // 提示：按double对齐的char地址通常是double对齐值的倍数（如系统中double对齐为8，则地址末3位为000）
}

int main() {
    bit_operations_demo();   // 执行位运算演示
    bitfield_demo();         // 执行位字段演示
    alignment_demo();        // 执行对齐特性演示
    return 0;
}
```

/*
代码测试及验证建议方案：
1. 位运算部分：
   - 编译运行后，检查各按位运算的二进制和十进制输出是否符合预期（如“num & mask”是否仅保留低4位）。
   - 修改`num`和`mask`的二进制值（如`num = 0b11001100`），重新编译运行，验证运算结果。

2. 位字段部分：
   - 确认初始化的位字段值（不透明、青色填充、虚线边框、厚度3）是否正确打印。
   - 修改`struct BoxProps box`的初始化参数（如`{0, RED, SOLID, 8}`），重新运行，检查输出是否同步变化。

3. 对齐特性部分：
   - 观察“按double对齐的char变量地址”是否为`double`对齐值的倍数（若系统中`double`对齐为8，则地址最后三位应为`000`）。
   - 更换类型（如`long long`），用`_Alignof(long long)`查询其对齐要求，再用`_Alignas(long long)`指定变量对齐，验证地址规律。
*/