### 一、总结主题：C 按位逻辑运算符核心知识
1. **适用类型**：整型数据（含 `char`）。
2. **运算本质**：对二进制位**逐位操作**，不影响其他位；与常规逻辑运算符（`&&`/`||`/`!`）操作“整体真假”不同。
3. **核心运算符**：
   - 按位取反（`~`）：一元，`1` 变 `0`、`0` 变 `1`。
   - 按位与（`&`）：二元，对应位**都为 `1`**时结果为 `1`；含复合赋值 `&=`。
   - 按位或（`|`）：二元，对应位**至少一个为 `1`**时结果为 `1`；含复合赋值 `|=`。
   - 按位异或（`^`）：二元，对应位**一个为 `1` 且不同时为 `1`**时结果为 `1`；含复合赋值 `^=`。


### 二、内容逻辑梳理（按运算符分类）
1. **按位取反（`~`）**
   - 操作：对每一位“取反”（`1`→`0`，`0`→`1`）。
   - 特性：不修改原变量，生成新值；若要修改原变量，需显式赋值（如 `val = ~val;`）。
   - 示例：`unsigned char val = 2`（二进制 `00000010`），则 `~val` 为 `11111101`（十进制 `253`）。

2. **按位与（`&`）**
   - 操作：逐位比较两个运算对象。
   - 规则：对应位都为 `1` 时，结果位为 `1`；否则为 `0`（“位级逻辑与”）。
   - 复合赋值：`val &= num;` 等价于 `val = val & num;`。

3. **按位或（`|`）**
   - 操作：逐位比较两个运算对象。
   - 规则：对应位至少一个为 `1` 时，结果位为 `1`（“位级逻辑或”）。
   - 复合赋值：`val |= num;` 等价于 `val = val | num;`。

4. **按位异或（`^`）**
   - 操作：逐位比较两个运算对象。
   - 规则：对应位“一个为 `1` 且不同时为 `1`”时，结果位为 `1`（“相同为 `0`，不同为 `1`”）。
   - 复合赋值：`val ^= num;` 等价于 `val = val ^ num;`。


### 三、编程举例及说明
#### 示例1：按位取反
```c
#include <stdio.h>
int main() {
    unsigned char val = 2;   // 二进制：00000010
    unsigned char newVal = ~val;
    printf("原 val：%u\n", val);          // 输出：原 val：2
    printf("~val 结果：%u\n", newVal);    // 输出：~val 结果：253（二进制11111101）
    val = ~val; // 修改原变量
    printf("修改后 val：%u\n", val);      // 输出：修改后 val：253
    return 0;
}
```
**说明**：`~` 对二进制位逐位取反，通过赋值可修改原变量。


#### 示例2：按位与、或、异或及复合赋值
```c
#include <stdio.h>
int main() {
    unsigned char a = 0b10010010; // 十进制146
    unsigned char b = 0b00111101; // 十进制61

    // 按位与：对应位都为1时结果为1
    unsigned char andRes = a & b; // 10010010 & 00111101 → 00010000（十进制16）
    printf("a & b = %u\n", andRes);

    // 按位或：对应位至少一个为1时结果为1
    unsigned char orRes = a | b; // 10010010 | 00111101 → 10111111（十进制191）
    printf("a | b = %u\n", orRes);

    // 按位异或：对应位不同时结果为1
    unsigned char xorRes = a ^ b; // 10010010 ^ 00111101 → 10101111（十进制175）
    printf("a ^ b = %u\n", xorRes);

    // 复合赋值（按位与赋值）
    unsigned char c = 0b10101010; // 十进制170
    c &= 0b00110011; // 等价于 c = c & 0b00110011 → 00100010（十进制34）
    printf("c &= 0b00110011 后：%u\n", c);
    return 0;
}
```
**说明**：
- 按位与（`&`）：可用于“提取特定位”（如位掩码）。
- 按位或（`|`）：可用于“设置特定位为1”。
- 按位异或（`^`）：可用于“位翻转”或“无临时变量交换数值”。
- 复合赋值：简化代码，直接对变量自身运算并赋值。


### 四、对比表格：按位 vs 常规逻辑运算符
| 对比维度       | 按位逻辑运算符（`&`/`|`/`~`等）| 常规逻辑运算符（`&&`/`||`/`!`等）|
|----------------|--------------------------------|----------------------------------|
| 操作对象       | 整型的**每一个二进制位**        | 表达式的**整体真假**（非0为真）|
| 结果粒度       | 生成**新整型值**（逐位运算）| 结果为**真（1）/假（0）**         |
| 短路特性       | 无（始终计算两个操作数）| 有（如 `&&` 左为假时，右不计算）|
| 典型用途       | 位操作（掩码、位翻转等）| 逻辑判断（分支、循环条件）|


### 五、扩展知识点（按位运算符的延伸应用）
1. **位掩码控制权限**：
   用不同二进制位表示“读/写/执行”权限，例：
   ```c
   #define READ  1 << 0 // 0b00000001
   #define WRITE 1 << 1 // 0b00000010
   #define EXEC  1 << 2 // 0b00000100
   unsigned char perm = READ | WRITE; // 同时有读、写权限
   if (perm & EXEC) printf("有执行权限\n");
   else printf("无执行权限\n");
   perm |= EXEC; // 新增执行权限
   ```

2. **无临时变量交换数值**：
   利用 `a ^ a = 0`、`a ^ 0 = a` 的性质：
   ```c
   int a = 10, b = 20;
   a = a ^ b;
   b = a ^ b; // 等价于 b = (a^b)^b = a
   a = a ^ b; // 等价于 a = (a^b)^a = b
   printf("a=%d, b=%d\n", a, b); // 输出：a=20, b=10
   ```

3. **奇偶性判断**：
   最低位为 `1` → 奇数；为 `0` → 偶数。通过 `& 1` 提取最低位：
   ```c
   int num = 7;
   printf("%d 是%s数\n", num, (num & 1) ? "奇" : "偶");
   ```

4. **清除/设置特定位**：
   - 清除第 `n` 位：`val &= ~(1 << n);`（如 `n=3`，`~(1<<3)` 为 `11110111`，与运算后第3位变0）。
   - 设置第 `n` 位：`val |= (1 << n);`（如 `n=2`，`1<<2` 为 `00000100`，或运算后第2位变1）。