### 1. 总结主题
- **15.1.2 有符号整数**：讲解有符号整数的三种表示方法（符号-量值、二进制反码、二进制补码），其中**二进制补码**是现代计算机最常用的方式，解决了符号-量值法的歧义问题，扩展了数值范围。
- **15.1.3 二进制浮点数**：介绍二进制浮点数的存储结构（二进制小数+二进制指数）、二进制小数的表示局限性，以及浮点数缩放时的精度特性。


### 2. 内容逻辑梳理
#### （1）有符号整数的表示（递进：从缺陷方法到最优方法）
- **符号-量值法**：
  - 规则：最高位为**符号位**（0正、1负），剩余位表示“量值”。
  - 示例（1字节）：`01111111`（+127）、`11111111`（-127）。
  - 缺陷：存在**+0（00000000）**和**-0（10000000）**，浪费位组合，范围仅-127~+127。

- **二进制反码**：
  - 规则：正数与“符号-量值法”一致；负数是对正数**每一位取反**（0→1，1→0）。
  - 示例（1字节）：+1（`00000001`）→ -1（`11111110`）；-0为`11111111`。
  - 缺陷：仍存在-0，范围仍为-127~+127，未解决歧义。

- **二进制补码（核心）**：
  - 规则：正数与前两种一致；负数是“正数取反后**加1**”。
  - 示例（1字节）：+1（`00000001`）→ -1（`11111111`，取反+1）；-128为`10000000`（特殊表示）。
  - 优势：仅一个0（`00000000`），范围扩展为**-128~+127**（1字节），且加减运算可统一为二进制加法，是现代计算机的标准选择。


#### （2）二进制浮点数（因果：为表示小数/大范围数，设计“小数+指数”结构）
- **二进制小数的表示**：
  - 类比十进制（如 \( 0.527 = \frac{5}{10} + \frac{2}{100} + \frac{7}{1000} \)），二进制小数**分母为2的幂**（如 `0.101` = \( \frac{1}{2} + \frac{0}{4} + \frac{1}{8} = 0.625 \)）。
  - 局限性：很多十进制小数（如0.1）无法用二进制**精确表示**（因 \( \frac{1}{10} \) 无法拆分为有限个 \( \frac{1}{2^n} \) 的和）。

- **浮点数的存储与缩放**：
  - 结构：拆分为**二进制小数（尾数，表精度）**和**二进制指数（阶码，表范围）**（类似 \( N = 尾数 × 2^{指数} \)）。
  - 缩放规则：
    - 乘/除以2的幂：仅调整**指数**，小数部分不变（如 \( 0.101 × 2^3 \)，指数+3，小数仍为`0.101`）。
    - 乘/除以非2的幂（如5）：需同时调整小数和指数，且小数可能因“无法精确表示”**损失精度**。


### 3. 编程举例（C语言：补码与浮点数精度）
#### （1）有符号整数的补码演示
```c
#include <stdio.h>

int main() {
    // 补码溢出：127 + 1 → -128
    signed char a = 127;
    signed char b = a + 1;
    printf("a = %d, a + 1 = %d\n", a, b); // 输出：a = 127, a + 1 = -128

    // 补码还原：-1 → 取反加1得1
    signed char c = -1;
    unsigned char c_bits = (unsigned char)c; // 读补码位模式（11111111）
    unsigned char c_rev = ~c_bits;          // 取反（00000000）
    unsigned char c_rev_plus1 = c_rev + 1;  // 加1（00000001 → 1）
    printf("补码取反加1后：%u\n", c_rev_plus1);

    return 0;
}
```
**说明**：演示补码的“溢出规则”和“负数还原为正数绝对值”的逻辑。


#### （2）浮点数的精度问题演示
```c
#include <stdio.h>

int main() {
    // 0.1无法精确表示，暴露精度损失
    float f = 0.1f;
    double d = 0.1;
    printf("float 0.1：%.15f\n", f);   // 末尾非0，精度损失
    printf("double 0.1：%.30lf\n", d); // 更明显看到误差

    // 浮点数乘法的精度变化
    float product = 0.1f * 3.0f;
    printf("0.1f * 3.0f = %.15f（理论应为0.3，实际有误差）\n", product);

    return 0;
}
```
**说明**：二进制浮点数无法精确存储0.1，运算时误差会被放大，体现精度局限性。


### 4. 对比表格（有符号整数的三种表示方法）
| 表示方法       | 正数规则               | 负数规则                     | 0的表示       | 数值范围（1字节） | 缺陷/优势               |
|----------------|------------------------|------------------------------|---------------|-------------------|-------------------------|
| 符号-量值法    | 符号位为0，其余表量值  | 符号位为1，其余表量值         | +0（`00000000`）、-0（`10000000`） | -127~+127         | 双0，浪费位组合         |
| 二进制反码     | 同符号-量值法          | 对正数每一位取反             | +0（`00000000`）、-0（`11111111`） | -127~+127         | 仍有双0，歧义未解决     |
| 二进制补码     | 同符号-量值法          | 正数取反后加1                | 仅`00000000`  | -128~+127         | 单0、范围大、运算简便   |


### 5. 扩展知识点补充
#### （1）补码的运算优势
补码将“减法”转化为“加法”：如 \( a - b = a + (-b) \)（-b用补码表示），CPU只需“加法器”即可处理加减，简化硬件。示例：\( 5 - 3 = 5 + (-3) \)，`5`（`00000101`）加`-3`的补码（`11111101`），结果为`00000010`（2），正确。


#### （2）浮点数的IEEE 754标准
- 现代计算机用**IEEE 754**定义浮点数：
  - `float`（32位）：1位符号、8位指数、23位尾数；
  - `double`（64位）：1位符号、11位指数、52位尾数。
- 通过“偏置指数”（指数存时加偏移）和“隐含最高位1”（尾数精度比存储多1位），优化范围与精度。


#### （3）二进制小数的应用
因对“2的幂分母”（如1/2、3/4）能精确表示，二进制小数用于**音频PCM编码**（按2的幂量化）、**嵌入式固定点数运算**（用整数模拟小数，避免浮点开销）。


#### （4）浮点数精度的工程应对
- 金融场景：用**十进制浮点数库**（如C++ `decimal`）或**整数缩放**（如“分”代“元”）避免误差。
- 科学计算：用**Kahan求和算法**减少浮点数累加的误差累积。