以下以清晰的注释形式，为你解答函数相关代码文件（`.c` 和 `.h` ）的区别与用法，帮你理解头文件和源文件的分工：

```c
// ------------------------------
// 问题：函数头文件是 .c 还是 .h ？
// 知识要点：
//  1. 文件类型分工：
//     - .c 文件：叫“源文件”，写函数的具体实现（函数体、变量定义等）
//     - .h 文件：叫“头文件”，写函数声明、宏定义、类型别名等，是代码的“接口”
//  2. 核心作用：
//     - .c 文件负责“实现功能”，.h 文件负责“暴露接口”，让其他文件能调用函数
//  3. 协作关系：
//     - 其他 .c 文件想调用某个函数时，只需包含对应的 .h 文件（引入接口），不用管 .c 里的实现
//     - 编译时，.c 文件会被编译成机器码，.h 文件起到“告诉编译器函数长什么样”的作用

// 举个例子：实现一个加法函数，拆分到 .c 和 .h 文件
// ------------------------------
// 1. add.h（头文件，写函数声明，暴露接口）
#ifndef ADD_H  // 防止头文件重复包含（重要！）
#define ADD_H

// 函数声明：告诉编译器，有一个这样的函数（返回 int，接收两个 int 参数）
int add(int a, int b); 

#endif

// ------------------------------
// 2. add.c（源文件，写函数实现）
#include "add.h"  // 包含自己的头文件，确保声明和实现一致

// 函数定义（实现）：真正的加法逻辑
int add(int a, int b) {
    return a + b;
}

// ------------------------------
// 3. main.c（其他源文件，调用 add 函数）
#include <stdio.h>
#include "add.h"  // 包含头文件，获取 add 函数的声明

int main() {
    int num1 = 5, num2 = 3;
    // 调用 add 函数，编译器通过 .h 文件知道函数的参数和返回值类型
    int result = add(num1, num2); 
    printf("结果：%d\n", result);
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存三个文件：add.h、add.c、main.c
//     - 编译命令（以 gcc 为例）：gcc main.c add.c -o main
//     - 运行：./main（Linux/Mac） 或 main.exe（Windows）
//  2. 预期结果：
//     - 输出 “结果：8”，验证函数调用成功
//  3. 检查点：
//     - 确认 .h 文件里的声明和 .c 文件里的实现是否一致
//     - 删掉 #include "add.h" 试试，会发现编译器报错（找不到 add 函数声明），体会头文件的作用

// 易错点提醒：
//  1. 忘记写头文件保护（#ifndef ... #define ... #endif），可能导致重复定义错误（如果多个文件包含同一个头文件）
//  2. .c 文件里的函数实现，必须和 .h 文件里的声明匹配（返回值、参数类型要一致），否则调用时会出错
//  3. 调用函数的 .c 文件，必须包含对应的 .h 文件，否则编译器不知道函数的存在

// 拓展思考：
//  1. 如果把 add 函数的实现改到 main.c 里，不拆分 .c 文件，能运行吗？（可以，但拆分文件更适合大型项目）
//  2. 头文件里除了函数声明，还能写什么？（比如宏定义 #define PI 3.14 、类型别名 typedef int MyInt; ）
//  3. 多个 .c 文件包含同一个 .h 文件时，为什么要加头文件保护？（防止重复声明，导致编译报错） 
```

总结来说：  
- **`.h` 是头文件**，负责写函数声明、宏、类型等“接口”，让其他文件能调用函数。  
- **`.c` 是源文件**，负责写函数的具体实现（函数体），真正实现功能。  

这样拆分的好处是：代码模块化（比如多个文件调用同一个函数时，只需包含 `.h` ）、方便多人协作（一人写 `.h` 和 `.c` 实现，其他人只需用 `.h` 调用 ），也更符合大型项目的开发规范。