/* 
知识要点总结：
1. 指针参数传递（地址传递）：
   - 函数参数用 `int *u`、`int *v` 接收变量地址，调用时传 `&x`、`&y` ，让函数直接操作主调函数的变量内存。
   - 区别于「值传递」，指针传递能让被调函数修改主调函数的变量。
2. 解引用操作（`*`）：
   - `*u` 表示访问指针 `u` 指向的变量值，通过 `*u = *v` 可直接修改主调函数中 `x` 的值，实现变量交换。
3. 函数原型与指针参数：
   - 函数声明 `void interchange(int *u, int *v);` 明确指针参数类型，告诉编译器要接收地址，支持跨函数修改变量。
4. 指针 vs 地址常量：
   - 指针变量（`u`、`v`）存储地址，可修改指向；`&x` 是地址常量，值固定。函数通过指针灵活操作不同变量的地址。

代码总体逻辑说明：
主函数 `main` 定义 `x=5`、`y=10`，调用 `interchange(&x, &y)` 传递地址。`interchange` 函数用指针接收地址，通过解引用 `*u`、`*v` 交换 `x`、`y` 的值。程序验证「指针传递让函数能修改主调函数变量」的核心功能，对比值传递（无法修改），突出指针的作用。
*/

#include <stdio.h>

// 函数声明：接收两个 int 指针，无返回值，用于交换指针指向的变量值
void interchange(int *u, int *v);  

int main(void)
{
    int x = 5, y = 10;
    printf("Originally x = %d and y = %d.\n", x, y);
    
    // 传递 x、y 的地址，让 interchange 能修改它们的值
    interchange(&x, &y);  
    
    printf("Now x = %d and y = %d.\n", x, y);
    return 0;
}

// 函数定义：通过指针交换两个变量的值
void interchange(int *u, int *v)
{
    int temp;
    // *u 访问 u 指向的变量值（即 main 中 x 的值），存入 temp
    temp = *u;  
    // *v 访问 v 指向的变量值（即 main 中 y 的值），赋给 u 指向的变量（x ）
    *u = *v;  
    // temp 中保存的原 x 值，赋给 v 指向的变量（y ），完成交换
    *v = temp;  
}

/* 
测试及验证建议方案：
1. 基础交换功能验证：
   - 运行程序，观察输出是否从 `x=5,y=10` 变为 `x=10,y=5`，验证指针传递实现了变量交换。
   - 注释掉 `interchange` 函数内的交换逻辑（`temp=*u; *u=*v; *v=temp;`），重新运行，观察 `x`、`y` 是否不变，理解指针交换的关键代码作用。
2. 指针地址与解引用测试：
   - 在 `interchange` 中打印 `u`、`v` 的地址（`printf("u 的地址：%p, v 的地址：%p\n", &u, &v);`），对比 `*u`、`*v` 的值，理解“指针存储地址，解引用访问值”。
   - 故意写成 `u = v;`（修改指针本身地址，而非指向的值），观察 `x`、`y` 是否交换，理解“指针变量赋值≠解引用赋值”的区别。
3. 空指针与错误处理：
   - 调用 `interchange(NULL, &y)`，观察程序崩溃，理解“指针必须指向有效内存，否则解引用会导致未定义行为”。
   - 传递非法地址（如 `interchange((int*)0x12345678, &y)`），观察运行错误，强化“指针需指向有效变量”的认知。
4. 多变量交换拓展：
   - 定义更多变量（如 `int a=1, b=2, c=3`），用 `interchange` 交换不同变量（如 `interchange(&a, &b); interchange(&b, &c);`），观察值变化，体会指针传递的灵活性。
5. 值传递 vs 指针传递对比：
   - 复制代码，修改为值传递版本（`interchange(int u, int v)`，内部交换 `u`、`v`），运行对比输出，深刻理解“值传递无法修改主调函数变量，指针传递可以”的核心区别。
*/