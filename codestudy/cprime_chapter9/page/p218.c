/* 
知识要点总结：
1. 旧式函数声明问题：
   - 旧式函数声明（如 `int imax();` ）只告知编译器函数返回值类型，不说明参数个数和类型，调用函数时若参数不匹配（个数不对、类型不符 ），编译器无法检查，可能导致程序运行异常（如读取错误栈数据、类型转换出问题 ）。
2. ANSI C 函数原型优势：
   - 函数原型（如 `int imax(int, int);` ）明确声明函数返回值类型、参数个数及类型，让编译器在编译阶段就能检查函数调用时的参数匹配问题（个数是否正确、类型是否兼容 ），及时报错或警告，避免运行时因参数错误产生奇怪结果。
   - 理解参数类型不匹配时，编译器会尝试隐式类型转换（如 `double` 转 `int` ），但可能丢失数据（如 `3.9` 转 `int` 变成 `3` ），编译器通常会给出警告，提醒开发者注意。
3. 函数定义与调用：
   - 掌握函数定义的完整结构（返回值类型、函数名、参数列表、函数体 ），以及函数调用时实参与形参的传递规则，实参要和形参在个数、类型上合理匹配（类型不匹配时看是否可隐式转换 ）。
4. 栈内存与参数传递：
   - 简单了解函数调用时参数传递依赖栈内存，主调函数把实参按一定规则压栈，被调函数从栈中读取形参值。旧式声明因无参数信息，可能读错栈数据（如少传参数时，读取到栈中其他无关值 ）；函数原型配合正确参数传递，能保证栈数据读取正确。

代码总体逻辑说明：
程序先演示旧式函数声明的写法及问题，再用 ANSI C 函数原型的写法对比。代码包含两个版本的函数调用测试：第一个版本用旧式声明 `int imax();` ，调用时故意传错参数（如少传参数、传浮点型参数 ），看编译器（若支持旧式兼容 ）或运行时的异常表现；第二个版本用函数原型 `int imax(int, int);` ，同样传错参数，观察编译器的报错或警告。`imax` 函数定义逻辑简单，返回两个整数中的较大值，通过不同声明方式的对比，突出函数原型在参数检查方面的重要性，让开发者明白使用 ANSI C 函数原型能提升程序正确性和可读性。
*/

#include <stdio.h>

// --------------------- 旧式函数声明演示（问题版本） ---------------------
// 旧式函数声明：仅说明返回值类型，不说明参数信息
int imax();  

// --------------------- ANSI C 函数原型演示（正确用法对比） ---------------------
// 函数原型声明：明确参数个数（2 个）和类型（int），返回值类型 int
// int imax(int, int);  

int main(void) 
{
    // 测试 1：旧式声明下的错误调用，少传一个参数（应该传 2 个 int，实际传 1 个 ）
    printf("旧式声明，少传参数：The maximum of 3 and 5 is %d.\n", imax(3));  
    // 测试 2：旧式声明下的错误调用，传浮点型参数（应该传 int，实际传 double ）
    printf("旧式声明，类型不匹配：The maximum of 3 and 5 is %d.\n", imax(3.9, 5.2));  

    // 若启用下面的函数原型，上面的错误调用会在编译时被编译器检查到
    // 启用方式：注释掉旧式声明，取消注释下面的函数原型，重新编译观察报错
    // int imax(int, int);  
    // 正确调用示例（需启用函数原型后，修正参数才能正常运行 ）
    // printf("ANSI 原型，正确调用：The maximum of 3 and 5 is %d.\n", imax(3, 5));  

    return 0;
}

// 函数定义：返回两个 int 中的较大值
int imax(int n, int m) 
{
    return (n > m ? n : m);
}

/* 
代码测试及验证建议方案：
1. 旧式声明问题复现：
   - 使用支持旧式函数声明兼容的编译器（如 gcc 带兼容选项 ），编译运行代码（注释掉 ANSI 函数原型部分 ），观察输出结果。会发现少传参数时，`imax` 函数读取到栈中随机值（输出奇怪的大数 ）；传浮点参数时，因隐式转换（`double` 转 `int` ），值可能被截断（如 `3.9` 转 `3` ），但编译器可能不报错（仅旧式兼容场景 ），体会旧式声明的风险。
   - 尝试在严格要求 ANSI C 的编译器（如开启强检查 ）下编译旧式声明代码，看是否直接报错，理解现代编译器对旧式声明的逐步弃用和严格检查趋势。
2. ANSI 函数原型验证：
   - 取消注释代码中 `int imax(int, int);` 这行（启用函数原型 ），再次编译代码。此时编译器会检查到 `imax(3)` 少传参数、`imax(3.9, 5.2)` 类型不匹配（`double` 转 `int` 可能丢失数据 ），输出报错或警告信息。根据报错，修正参数（如 `imax(3, 5)` 、`imax((int)3.9, (int)5.2)` 显式转换 ），重新编译运行，看是否得到正确结果（输出 `5`  ），体会函数原型对参数检查的作用。
3. 类型转换与警告测试：
   - 故意写 `imax(3.9, 5.2)` （不做显式转换 ），启用函数原型后编译，看编译器警告信息（如“double 转换为 int 可能丢失数据” ），理解隐式类型转换的潜在问题，以及编译器如何提醒开发者。
   - 尝试不同类型的不匹配参数（如传字符串、字符型等 ），看编译器报错内容，加深对参数类型检查的理解。
4. 函数原型位置测试：
   - 把函数原型 `int imax(int, int);` 移到 `main` 函数内部（局部作用域 ），测试是否还能正常检查参数，体会函数原型声明位置只要在调用前即可，不管是全局还是局部作用域（但全局作用域声明可被多个函数共享 ）。
5. 栈内存与参数传递探究（进阶，可辅助理解 ）：
   - 借助调试工具（如 gdb ），在旧式声明少传参数的调用处（`imax(3)` ）设置断点，查看栈内存数据，看 `imax` 函数读取的形参值是否是栈中无关数据；再在函数原型正确调用时（`imax(3, 5)` ）查看栈，看形参读取的是正确的实参值，对比理解参数传递与栈的关系，以及函数原型如何避免读错栈数据。 
*/