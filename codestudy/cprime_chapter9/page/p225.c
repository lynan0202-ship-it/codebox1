/* 
知识要点总结：
1. 递归实现斐波那契数列：
   - 理解斐波那契数列的递归定义：当 n 为 1 或 2 时返回 1，其他情况返回 `Fibonacci(n-1) + Fibonacci(n-2)` ，掌握递归公式与数学定义的对应关系。
   - 认识**双递归**（函数每一级递归调用自身两次 ）的特点，以斐波那契递归函数为例，清楚双递归会导致变量数量呈指数级增长（每级递归创建的变量数是上一级的 2 倍 ），理解其对内存资源的巨大消耗风险。
2. 函数声明与调用：
   - 学会定义无返回值的 `main` 函数（实际可返回 `int` ，这里按书中示例用 `void` 演示 ），以及带返回值的递归函数（`unsigned long Fibonacci(unsigned n);` ）；掌握函数调用流程，包括主函数中调用递归函数，以及递归函数内部的自调用（双递归调用 ）。
3. 递归的优缺点体会：
   - 理解递归的**优点**：逻辑简洁直观，直接对应数学定义，代码编写简单；
   - 理解递归的**缺点**：双递归场景下内存消耗指数级增长，可能导致程序因栈溢出崩溃；同时递归代码阅读和维护难度相对较高，调用层级深时流程难跟踪。
4. C 函数的平等性：
   - 明白 C 语言中函数的平等性，每个函数（包括 `main` ）都可被其他函数调用（甚至递归调用自身或被递归调用 ），虽然 `main` 是程序入口，但本质与其他函数平等，只是执行时机特殊（程序启动先执行 `main` 第一条语句 ）。

代码总体逻辑说明：
程序定义 `Fibonacci` 递归函数实现斐波那契数列计算，`main` 函数作为入口调用该递归函数。流程如下：
1. `main` 函数中提示用户输入斐波那契数列的项数 `n` ；
2. 调用 `Fibonacci(n)` 计算第 `n` 项斐波那契数值，同时演示递归函数的双递归调用过程； 
3. 输出计算结果（实际代码中因聚焦递归流程，输出可按需补充 ）；
4. 通过注释详细说明每一步体现的递归知识点，尤其是双递归导致的内存消耗问题，帮助初学者理解递归的风险与特点。
*/

#include <stdio.h>

// 递归函数声明：计算第 n 项斐波那契数，n 为无符号整数，返回无符号长整型结果
unsigned long Fibonacci(unsigned n);  

// 主函数，程序入口
void main(void) 
{
    unsigned n;
    printf("Enter the position in Fibonacci sequence (n >= 1): ");
    scanf("%u", &n);  // 输入要计算的斐波那契数列项数

    // 调用递归函数计算并输出结果（这里简单演示，可完善输出格式）
    unsigned long result = Fibonacci(n);
    printf("The %uth Fibonacci number is: %lu\n", n, result);
}

// 递归函数定义：实现斐波那契数列计算，体现双递归
unsigned long Fibonacci(unsigned n) 
{
    if (n == 1 || n == 2) 
    {
        // 递归终止条件：第 1、2 项返回 1
        return 1;  
    } 
    else 
    {
        // 双递归调用：自身调用两次，分别计算 n-1 和 n-2 项，结果相加
        return Fibonacci(n - 1) + Fibonacci(n - 2);  
    }
}

/* 
代码测试及验证建议方案：
1. 基础功能验证：
   - 输入小数值（如 n=1、2、3、5 ），检查输出结果是否符合斐波那契数列定义（1、1、2、5 ），验证递归函数逻辑正确性。
   - 逐步增大 n 值（如 n=10、20 ），观察程序运行情况（计算时间、内存占用 ），体会小范围时递归的正常工作，感受数值增大时计算时间的增长（因重复计算多，双递归效率极低 ）。
2. 内存消耗与崩溃测试：
   - 尝试输入较大值（如 n=30、40 ），观察程序是否因内存不足变慢甚至崩溃（模拟书中提到的指数级内存消耗问题 ）；结合调试工具（如查看栈使用情况 ），直观感受双递归对栈空间的疯狂占用。
   - 对比 n=30 和 n=40 时的运行差异，理解变量数量指数级增长的实际影响（每级递归变量数翻倍 ），加深对双递归内存风险的认识。
3. 递归流程跟踪（调试）：
   - 使用编译器调试功能（如 VS Code + GDB 、Dev-C++ 调试 ），在 `Fibonacci` 函数的 `return` 语句处设置断点，跟踪递归调用栈。输入小 n 值（如 n=5 ），单步执行，观察递归调用顺序（先调用 `Fibonacci(4)` ，再在其内部调用 `Fibonacci(3)` 和 `Fibonacci(2)` 等 ），以及每次递归返回值的计算过程，理解双递归的执行流程和重复计算问题（如计算 `Fibonacci(5)` 时，`Fibonacci(3)` 会被多次计算 ）。
4. 非递归实现对比（拓展理解）：
   - 自行编写**循环实现**的斐波那契数列函数（用迭代方式，从第 1、2 项逐步累加到第 n 项 ），对比递归实现和循环实现的代码复杂度、执行效率（计算大 n 值时的时间差异 ）、内存占用。体会循环在效率和内存控制上的优势，理解递归与循环在不同场景的适用选择。
5. 函数平等性测试（进阶）：
   - 尝试修改代码，让 `main` 函数被 `Fibonacci` 递归调用（如在 `Fibonacci` 中写 `main()` 调用 ，需注意递归终止条件避免无限递归 ），观察程序运行情况（虽然实际很少这样用，但能验证 C 函数平等性 ）；或者写一个函数递归调用 `main` ，感受函数平等性的体现。 
*/