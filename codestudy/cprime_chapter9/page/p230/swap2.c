/* 
知识要点总结：
1. 指针与地址传递：
   - 指针变量存储**变量的地址**（如 `int *p = &x;` ，`p` 是指针，存 `x` 的地址 ）。
   - 调用 `interchange(&x, &y)` 时，传递的是 `x`、`y` 的**地址**，形参 `int *u`、`int *v` 接收地址，此时形参和实参**共享同一块内存**。
2. 解引用操作（`*`）：
   - 通过 `*u`、`*v` 可以**访问指针指向的变量的值**，修改 `*u` 会直接改变 `main` 中 `x` 的值，实现“通过函数修改实参”。
3. 值传递 vs 地址传递：
   - 对比 `swap1.c` ，理解**地址传递（指针）可以让函数修改实参**，解决值传递无法反馈结果的问题；但指针增加了代码复杂度，需注意解引用的正确使用。

代码总体逻辑说明：
`main` 中定义 `x=5`、`y=10` ，调用 `interchange(&x, &y)` 传递地址。`interchange` 用指针形参 `u`、`v` 接收地址，通过 `*u`、`*v` 访问并交换 `x`、`y` 的值。程序打印交换前后的值，展示指针如何解决“值传递无法修改实参”的问题。
*/

#include <stdio.h>

// 函数声明：形参是指针，接收变量地址
void interchange(int *u, int *v);  

int main(void)
{
    int x = 5, y = 10;
    printf("Originally x = %d and y = %d.\n", x, y);
    
    // 传递 x、y 的地址，让函数能修改它们的值
    interchange(&x, &y);  
    
    printf("Now x = %d and y = %d.\n", x, y);
    return 0;
}

// 函数定义：通过指针交换实参的值
void interchange(int *u, int *v)
{
    int temp;
    printf("Originally *u = %d and *v = %d (访问指针指向的值).\n", *u, *v);
    
    // 交换指针指向的变量的值（即 main 中的 x、y ）
    temp = *u;
    *u = *v;
    *v = temp;
    
    printf("Now *u = %d and *v = %d (指针指向的值已交换).\n", *u, *v);
}

/* 
测试及验证建议方案：
1. 基础功能验证：
   - 编译运行 `gcc swap2.c -o swap2 && ./swap2` ，观察 `x`、`y` 交换为 `10`、`5` ，验证指针传递能修改实参。
2. 指针地址与解引用测试：
   - 在 `interchange` 中打印指针地址（`printf("u addr: %p, v addr: %p\n", u, v);` ），观察 `u` 存 `x` 的地址、`v` 存 `y` 的地址，理解指针存储地址的本质。
   - 故意写 `u = v;`（修改指针本身地址，而非指向的值 ），观察 `x`、`y` 是否交换，理解“指针变量本身的赋值不影响实参，必须解引用才能修改值”。
3. 空指针与错误处理（易错点）：
   - 调用 `interchange(NULL, &y)` ，观察程序崩溃，理解**指针必须指向有效内存**，否则解引用会报错（空指针访问 ）。
*/