/* 
知识要点总结：
1. 指针的本质：
   - 指针是存储**内存地址**的变量，值为其他变量的地址。例如 `int *ptr;` 中，`ptr` 存的是 `int` 变量的地址，和 `int` 变量存整数、`char` 变量存字符的逻辑一致，只是存储内容是地址。
2. 地址运算符 `&`：
   - `&变量名` 可获取变量的内存地址，如 `&pooh` 得到 `pooh` 的地址，赋值给指针变量（`ptr = &pooh;` ），让指针“指向”该变量。
3. 间接运算符 `*`（解引用）：
   - 当指针 `ptr` 指向变量（如 `pooh` ）时，`*ptr` 表示“访问 `ptr` 指向地址中的值”，即通过指针操作目标变量的值。`*ptr` 等价于指针指向的变量（如 `pooh` ），可用于赋值、取值。
4. 指针变量的声明：
   - 声明格式为 `类型 *指针变量名;` ，如 `int *ptr;` 表示 `ptr` 是一个指针，存储 `int` 类型变量的地址；`char *ch_ptr;` 表示存储 `char` 类型变量的地址，明确指针指向的变量类型。
5. 指针的赋值与指向变化：
   - 指针变量可重新赋值（如 `ptr = &bah;` ），改变其指向的变量，体现指针“可变指向”的特点，区别于 `&pooh` 这类固定的地址常量。

代码总体逻辑说明：
程序定义 `int` 变量 `pooh`、`bah` 和指针变量 `ptr` 。通过 `&` 运算符让 `ptr` 先后指向 `pooh` 和 `bah` ，再用 `*` 运算符通过指针访问、修改目标变量的值。同时对比指针变量（`ptr` ）和地址常量（`&pooh` ）的区别，展示指针“可修改指向”的特性，帮助理解指针的核心操作流程。
*/

#include <stdio.h>

int main(void)
{
    // 定义普通 int 变量
    int pooh = 22, bah = 50;  
    // 声明指针变量 ptr，用于存储 int 类型变量的地址
    int *ptr;  

    // 1. 指针指向 pooh：用 & 获取 pooh 的地址，赋值给 ptr
    ptr = &pooh;  
    printf("ptr 指向 pooh 时：\n");
    // 打印指针变量 ptr 存储的地址（即 pooh 的地址）
    printf("ptr 的值（pooh 的地址）：%p\n", ptr);  
    // 打印 &pooh（pooh 的地址，常量 ），对比指针变量和地址常量
    printf("&pooh 的值（地址常量）：%p\n", &pooh);  
    // 通过 *ptr 访问 ptr 指向的变量（pooh ）的值，等价于 pooh
    printf("*ptr 的值（pooh 的值）：%d\n", *ptr);  

    // 通过指针修改 pooh 的值：*ptr 等价于 pooh，赋值后 pooh 变为 23
    *ptr = 23;  
    printf("通过 *ptr 修改后，pooh 的值：%d\n", pooh);

    // 2. 指针重新指向 bah：改变指针的指向，存储 bah 的地址
    ptr = &bah;  
    printf("\nptr 指向 bah 时：\n");
    // 打印 ptr 存储的地址（bah 的地址 ）
    printf("ptr 的值（bah 的地址）：%p\n", ptr);  
    // 通过 *ptr 访问 bah 的值
    printf("*ptr 的值（bah 的值）：%d\n", *ptr);  

    // 通过指针修改 bah 的值：*ptr 等价于 bah，赋值后 bah 变为 51
    *ptr = 51;  
    printf("通过 *ptr 修改后，bah 的值：%d\n", bah);

    return 0;
}

/* 
测试及验证建议方案：
1. 基础指针操作验证：
   - 编译运行代码，观察指针 `ptr` 指向 `pooh` 和 `bah` 时，`ptr` 的地址值（`%p` 输出 ）、`*ptr` 的值（目标变量值 ）是否正确。确认 `ptr` 存储的是变量地址，`*ptr` 能访问和修改目标变量。
   - 对比 `ptr` 和 `&pooh` 的输出，确认指针变量存储地址，且地址常量（`&pooh` ）和指针变量（`ptr` ）都表示地址，但指针变量可修改指向。
2. 指针修改变量测试：
   - 检查通过 `*ptr = 23` 修改 `pooh` 、`*ptr = 51` 修改 `bah` 后，原变量的值是否改变，验证 `*` 运算符的解引用功能（通过指针修改目标变量 ）。
   - 尝试在指针指向 `pooh` 时，直接修改 `ptr` 的值（如 `ptr = 0x12345678;` ），观察程序是否崩溃，理解指针必须指向有效内存地址，否则解引用会导致未定义行为（非法访问内存 ）。
3. 不同类型指针测试（拓展）：
   - 定义 `char ch = 'A';` 和 `char *ch_ptr;` ，重复上述指针操作（`ch_ptr = &ch; *ch_ptr = 'B';` ），观察字符变量的修改，体会指针类型需与目标变量类型匹配（`int *` 对应 `int` ，`char *` 对应 `char` ）。
   - 尝试用 `int *` 指针指向 `char` 变量（如 `ptr = (int *)&ch;` ，强制类型转换 ），观察 `*ptr` 取值的异常，理解指针类型匹配的重要性（不同类型变量内存布局不同，强制转换可能导致数据解析错误 ）。
4. 指针与变量地址的动态变化：
   - 在代码中添加更多变量（如 `int temp = 100;` ），让 `ptr` 指向新变量，观察指针地址和目标变量值的变化，强化“指针可灵活指向不同变量”的理解。
   - 打印 `&ptr`（指针变量自身的地址 ），对比 `ptr` 存储的地址（目标变量地址 ），理解“指针变量也是内存中的一块空间，有自己的地址，但存储的内容是其他变量的地址”。
5. 易错点与边界测试：
   - 声明指针后未初始化（如 `int *null_ptr; *null_ptr = 10;` ），观察程序崩溃，理解野指针（未初始化指针 ）的危害，强调指针使用前需赋值有效地址。
   - 尝试访问超出变量作用域的指针（如在函数中返回局部变量的地址给指针 ），观察运行时错误（如栈溢出、未定义行为 ），理解指针指向的变量需在有效作用域内。 
*/