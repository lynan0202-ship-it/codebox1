/* 
知识要点总结：
1. 递归函数定义：
   - 明确递归函数是在函数体内调用自身的函数，如 `up_and_down` 中调用 `up_and_down(n + 1);` ，实现函数自我调用的递归过程。
2. 递归终止条件：
   - 理解递归必须有终止条件（如 `if (n < 4)` ），否则会无限递归（类似死循环 ），导致栈溢出等问题。当条件不满足时，递归调用停止，开始逐层返回。
3. 递归执行流程：
   - 掌握递归函数的执行顺序：递归调用之前的语句（如 `printf("Level %d: n location %p\n", n, &n);` ）按递归调用顺序执行（第 1 级→第 2 级→第 3 级→第 4 级 ）；递归调用之后的语句（如 `printf("LEVEL %d: n location %p\n", n, &n);` ）按递归返回顺序执行（第 4 级→第 3 级→第 2 级→第 1 级 ），形成“先深入，后返回”的执行轨迹。
4. 变量作用域与栈帧：
   - 清楚每级递归调用都有自己独立的变量副本（如 `n` ），存储在栈帧中，不同级递归的变量互不干扰（从输出的地址 `&n` 可看出，每级 `n` 的地址不同 ）。递归返回时，会释放当前级的栈帧，回到上一级递归的栈帧继续执行。
5. 递归与循环的关系：
   - 了解递归和循环可以互相替代解决问题，但适用场景不同。递归在处理具有递归结构（如树、链表遍历 ）或逻辑上需要“先深入后返回”的问题时更直观，不过效率通常不如循环（因递归涉及频繁的栈操作和函数调用开销 ）。

代码总体逻辑说明：
程序定义 `up_and_down` 递归函数和 `main` 函数。`main` 函数作为入口，调用 `up_and_down(1)` 启动递归。`up_and_down` 函数接收参数 `n` ，先打印当前递归层级（`Level` ）及变量 `n` 的地址，然后判断 `n` 是否小于 4 ，若是则递归调用自身（参数 `n + 1` ），递归调用返回后，再打印另一组信息（`LEVEL` ）及 `n` 的地址。通过这样的递归调用和打印，清晰展示递归的“深入”（递归调用前的打印 ）和“返回”（递归调用后的打印 ）过程，帮助理解递归的执行流程、变量作用域、终止条件等关键知识点，体现递归函数在演示递归原理方面的作用。
*/

#include <stdio.h>  // 引入标准输入输出库，使用 printf 函数

// 函数原型声明：告知编译器 up_and_down 函数的返回值类型（void）和参数类型（int）
void up_and_down(int n);  

int main(void) 
{
    up_and_down(1);  // 调用 up_and_down 函数，初始参数为 1，启动递归
    return 0;  // main 函数返回 0，程序正常结束
}

// 递归函数定义：实现递归调用并打印信息，演示递归流程
void up_and_down(int n) 
{
    // 打印当前递归层级（Level）及变量 n 的地址，属于递归调用之前的语句，按递归深入顺序执行
    printf("Level %d: n location %p\n", n, &n);  
    if (n < 4)  // 递归终止条件：n 小于 4 时继续递归，否则停止
    {
        up_and_down(n + 1);  // 递归调用自身，参数递增，进入下一级递归
    }
    // 递归调用返回后执行的语句，按递归返回顺序执行
    printf("LEVEL %d: n location %p\n", n, &n);  
}

/* 
代码测试及验证建议方案：
1. 基础执行流程测试：
   - 编译运行代码，观察输出的 `Level` 和 `LEVEL` 打印顺序及 `n` 的地址变化，对比书中讲解的执行流程，验证是否理解递归的“深入”和“返回”过程。
   - 修改递归终止条件（如 `if (n < 3)` ），重新运行，看递归层级如何变化（变为 3 级 ），打印顺序和地址有何改变，加深对终止条件作用的理解。
2. 变量作用域与栈帧测试：
   - 在 `up_and_down` 函数中定义一个局部变量（如 `int temp = n * 2;` ），然后在打印语句中加入 `temp` 的值（如 `printf("Level %d: n=%d, temp=%d, location %p\n", n, n, temp, &n);`  ），观察每级递归中 `temp` 的值和地址，体会局部变量在递归中的独立作用域（每级递归的 `temp` 都是独立的 ）。
   - 尝试在递归返回后修改 `n` 的值（如 `n = 0;` ），看对上级递归的 `n` 是否有影响，验证不同级递归变量的独立性（修改当前级 `n` 不影响上级 ）。
3. 递归深度与栈溢出测试：
   - 逐步增大递归终止条件（如把 `n < 4` 改成 `n < 10000`  ），观察程序运行情况。当递归层级过大时，会因栈溢出导致程序崩溃（提示 `Segmentation fault` 等错误 ），理解递归深度受栈空间限制，体会终止条件和递归深度的关系，以及递归可能存在的风险。
   - 对比循环实现相同功能（打印类似层级信息 ），编写循环版本代码（如用 `for` 循环模拟递归的深入和返回 ），测试两者在执行效率、代码复杂度方面的差异，加深对递归和循环适用场景的理解。
4. 地址与系统差异测试：
   - 在不同操作系统（如 Windows、Linux、macOS ）或不同编译器（如 gcc、clang、MSVC ）下编译运行代码，观察变量 `n` 的地址格式和变化规律，理解地址表示因系统和编译器而异，但每级递归 `n` 地址不同的本质不变。
   - 如果系统不支持 `%p` 格式打印地址，按书中提示替换成 `%u` 或 `%lu` ，重新编译运行，看地址输出变化，确保代码可移植性，同时理解地址打印的不同方式。
5. 易错点与拓展测试：
   - 故意删除递归终止条件（去掉 `if (n < 4)`  ），运行程序，观察栈溢出错误的表现（如程序崩溃、报错信息 ），加深对无限递归危害的认识，牢记递归必须有终止条件。
   - 拓展递归函数功能，如在递归过程中计算 `n` 的累加和（每级递归把 `n` 累加到一个全局变量 ），测试递归返回后累加和是否正确，理解递归过程中全局变量的作用（全局变量在所有递归层级中共享 ），与局部变量的区别。 
*/