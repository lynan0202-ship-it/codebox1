/* 
知识要点总结：
1. 递归实现整数转二进制：
   - 理解递归处理二进制转换的核心逻辑：通过 `n % 2` 获取当前位的二进制值（0 或 1 ），但因计算顺序是“先得到低位、后得到高位”，所以要在递归调用之后打印当前位（实现“先深入递归分解问题，后返回打印结果”，让高位先输出、低位后输出 ）。
   - 掌握递归终止条件：当 `n < 2` 时停止递归（因为 `n / 2` 结果小于 2 ，说明已处理到最高位 ），确保递归不会无限进行。
2. 函数声明与调用：
   - 学会在主函数前声明递归函数原型（`void to_binary(unsigned long n);` ），支持函数定义在后、调用在前的写法；理解函数调用时实参传递（`to_binary(number)` ）和递归调用的过程（`to_binary(n / 2)` ），以及递归函数无返回值（`void` 类型 ）但通过 `putchar` 输出结果的特点。
3. 输入处理与循环控制：
   - 利用 `scanf` 返回值（成功读取的输入项数量 ）控制 `while` 循环（`while (scanf("%lu", &number) == 1)` ），实现持续输入整数；当输入非整数（如 `q` ）时，循环终止，程序结束，掌握这种输入交互的常见写法。
4. 字符转换与输出：
   - 明白如何将数值 `0` 或 `1` 转换为字符 `'0'` 或 `'1'` ，通过条件表达式 `r == 0 ? '0' : '1'` 实现数值到字符的映射，再用 `putchar` 输出，理解字符输出的基本方法。
5. 递归与非递归实现对比：
   - 了解递归实现简洁直观，但依赖栈空间，对于深度大的递归可能栈溢出；非递归实现（如用数组存储二进制位再逆序输出 ）虽然代码稍复杂，但更节省栈空间，可在处理大规模数据时使用，书中后续章节会介绍，此处先理解递归的优势。

代码总体逻辑说明：
程序先通过 `#include <stdio.h>` 引入标准输入输出库，声明 `to_binary` 递归函数原型。`main` 函数作为入口，定义变量存储用户输入的无符号长整数 `number` ，提示用户输入整数并说明退出方式，然后进入 `while` 循环：每次成功读取一个整数后，调用 `to_binary` 函数将其转换为二进制并输出，接着提示用户继续输入；当输入非整数时，循环终止，输出 `Done.` 结束程序。`to_binary` 函数通过递归实现二进制转换：先计算当前数对 2 取余得到二进制位（`r = n % 2` ），若 `n >= 2` 则递归调用自身处理 `n / 2` （分解问题到更小规模 ），递归调用返回后，将 `r` 转换为字符并输出（此时从最高位开始输出 ）。整体流程围绕整数转二进制的递归实现，结合输入交互，清晰展示递归在处理“倒序输出”类问题时的优势（无需额外数据结构存储中间结果 ）。
*/

#include <stdio.h>  // 引入标准输入输出库，使用 printf、scanf、putchar 等函数

// 函数原型声明：告知编译器 to_binary 函数的参数类型（unsigned long）和返回值类型（void）
void to_binary(unsigned long n);  

int main(void) 
{
    unsigned long number;  // 定义变量存储用户输入的无符号长整数

    // 提示用户输入整数，说明退出方式（输入 q 等非整数）
    printf("Enter an integer (q to quit):\n");  
    // 当 scanf 成功读取一个无符号长整数（返回值为 1 ）时，持续循环
    while (scanf("%lu", &number) == 1)  
    {
        printf("Binary equivalent: ");  // 提示二进制转换结果的开始
        to_binary(number);  // 调用递归函数，将输入的整数转换为二进制并输出
        putchar('\n');  // 换行，分隔每次的输出结果
        // 提示用户继续输入或退出
        printf("Enter an integer (q to quit):\n");  
    }
    printf("Done.\n");  // 输入非整数时，循环终止，输出结束提示
    return 0;  // main 函数返回 0，程序正常结束
}

// 递归函数定义：将无符号长整数 n 转换为二进制并输出，无返回值（void 类型 ）
void to_binary(unsigned long n)  
{
    int r;  // 定义变量 r，存储 n % 2 的结果（当前位的二进制数值 0 或 1 ）

    r = n % 2;  // 计算当前位的二进制数值
    if (n >= 2)  // 判断是否需要继续递归：n >= 2 说明还有更高位需要处理
    {
        to_binary(n / 2);  // 递归调用自身，处理 n / 2（更小规模的问题 ）
    }
    // 递归调用返回后，将数值 r 转换为字符并输出（实现高位先输出、低位后输出 ）
    putchar(r == 0 ? '0' : '1');  
    return;  // void 函数的 return 可省略，这里显式写出强调函数结束
}

/* 
代码测试及验证建议方案：
1. 基础功能验证：
   - 编译运行代码，输入多个整数（如 5、9、1 、100 ），查看输出的二进制是否正确（5 对应 101 、9 对应 1001 、1 对应 1 、100 对应 1100100 ），验证递归转换逻辑。
   - 输入 0 ，检查输出是否为 0 （0 的二进制表示就是 0 ），测试边界值处理。
2. 输入处理测试：
   - 输入非整数（如 `q`、`abc` ），观察循环是否终止，是否输出 `Done.` ，验证 `scanf` 控制循环和程序退出的逻辑。
   - 输入极大的无符号长整数（如 `18446744073709551615` ，`unsigned long` 最大值 ），查看二进制输出是否正确，测试数据范围处理（因递归深度大，可观察是否栈溢出，一般现代编译器处理这种规模没问题，但能体会递归深度的影响 ）。
3. 递归流程调试：
   - 借助调试工具（如 gdb ），在 `to_binary` 函数的 `r = n % 2` 和 `putchar` 处设置断点，单步执行，观察递归调用的顺序（如输入 5 ，看递归调用 `to_binary(2)`、`to_binary(1)` ）、`n` 和 `r` 的值变化，以及 `putchar` 执行顺序（先处理 `n=1` 时的输出，再处理 `n=2` 时的输出，最后处理 `n=5` 时的输出 ），理解“先递归分解、后返回打印”的流程，明确二进制位的输出顺序。
4. 非递归实现对比（拓展，加深理解 ）：
   - 尝试用非递归方式实现整数转二进制（如用数组存储二进制位，每次 `n % 2` 结果存入数组，最后逆序输出数组元素 ），对比递归和非递归实现的代码复杂度、执行效率（可通过多次转换大整数，观察运行时间 ），感受递归在简洁性上的优势，以及非递归在栈空间使用上的优势。
5. 易错点与边界测试：
   - 故意删除递归终止条件（注释 `if (n >= 2)` 判断 ），输入整数（如 5 ），观察是否因无限递归导致栈溢出（程序崩溃 ），理解递归终止条件的必要性。
   - 修改递归调用和打印的顺序（如在递归调用之前打印 `r` ），输入整数查看输出结果（会变成低位先输出、高位后输出，得到错误的二进制顺序 ），明确递归调用前后语句执行顺序对输出结果的影响，加深对递归“先深入后返回”逻辑的理解。 
*/