/* 
知识要点总结：
1. 递归与循环实现阶乘：
   - 循环实现（`fact` 函数 ）：通过 `for` 循环，初始化结果变量 `ans` 为 1，然后从 `n` 递减乘到 2，利用循环的迭代特性计算阶乘，理解循环变量更新和累乘逻辑。
   - 递归实现（`rfact` 函数 ）：基于阶乘公式 `n! = n * (n-1)!` ，递归调用自身计算 `(n-1)!` ，直到 `n == 0` 时返回 1 作为终止条件，掌握递归的“分解问题、终止条件、返回计算”流程，以及尾递归（递归调用是函数执行的最后一条有效语句 ）的特点。
2. 函数声明与调用：
   - 学会在主函数前声明函数原型（`long fact(int n);`、`long rfact(int n);` ），让编译器提前知晓函数信息，支持函数定义在后、调用在前的写法；理解函数调用时实参传递（`fact(num)`、`rfact(num)` ）和形参接收的过程，以及返回值的使用（输出阶乘结果 ）。
3. 输入处理与边界检查：
   - 利用 `scanf` 返回值控制循环（`while (scanf("%d", &num) == 1)` ），实现持续输入；对输入的 `num` 进行边界检查（小于 0 或大于 12 ），提示用户正确输入范围，避免因数值过大超出 `long` 类型表示范围导致结果错误，理解数据范围和类型取值的关系。
4. 递归与循环的对比：
   - 明白递归和循环都能解决阶乘计算问题，但各有优劣。递归逻辑简洁、贴近数学定义，但因频繁函数调用和栈操作，内存消耗大、效率低于循环；循环效率高、内存占用少，但逻辑相对间接。通过对比两者实现，理解不同场景下工具的选择思路。

代码总体逻辑说明：
程序先通过预处理引入 `stdio.h` ，声明 `fact` 和 `rfact` 函数原型。`main` 函数作为入口，先提示用户程序功能和输入范围，然后进入 `while` 循环，持续读取用户输入的整数 `num` 。每次读取成功后，检查 `num` 的合法性（是否在 0 - 12 之间 ）：不合法则提示重新输入；合法则分别调用 `fact`（循环实现 ）和 `rfact`（递归实现 ）函数计算阶乘，输出两种方式的计算结果。`fact` 函数用 `for` 循环迭代累乘得到阶乘；`rfact` 函数用递归分解问题，依据终止条件返回结果。整体流程围绕阶乘计算，对比递归和循环的实现，同时做好输入处理和边界检查，体现程序的完整性和健壮性，帮助理解递归、循环、函数调用等核心知识点。
*/

#include <stdio.h>

// 函数原型声明：告知编译器 fact 函数接收 int 参数，返回 long 类型结果
long fact(int n);  
// 函数原型声明：告知编译器 rfact 函数接收 int 参数，返回 long 类型结果
long rfact(int n);  

int main(void) 
{
    int num;  // 定义变量存储用户输入的整数

    // 提示程序功能和输入要求
    printf("This program calculates factorials.\n");
    printf("Enter a value in the range 0-12 (q to quit):\n");

    // 当 scanf 成功读取一个整数（返回值为 1 ）时，持续循环
    while (scanf("%d", &num) == 1)  
    {
        if (num < 0)  // 输入负数，提示错误
        {
            printf("No negative numbers, please.\n");
        }
        else if (num > 12)  // 输入超过 12，提示范围
        {
            printf("Keep input under 13.\n");
        }
        else  // 输入合法，计算并输出阶乘
        {
            // 调用循环实现的 fact 函数，输出结果
            printf("loop: %d factorial = %ld\n", num, fact(num));  
            // 调用递归实现的 rfact 函数，输出结果
            printf("recursion: %d factorial = %ld\n", num, rfact(num));  
        }
        // 再次提示输入，保持交互
        printf("Enter a value in the range 0-12 (q to quit):\n");  
    }

    printf("Bye.\n");  // 输入非整数（如 q ），退出循环，提示结束
    return 0;  // 程序正常结束
}

// 循环实现阶乘计算的函数定义
long fact(int n) 
{
    long ans = 1;  // 初始化结果为 1，阶乘从 1 开始累乘
    // for 循环：从 n 递减到 2，依次相乘
    for (int i = n; i > 1; i--)  
    {
        ans *= i;  
    }
    return ans;  // 返回阶乘结果
}

// 递归实现阶乘计算的函数定义
long rfact(int n) 
{
    if (n > 0)  // 递归终止条件：n > 0 时，继续递归分解问题
    {
        // 递归调用自身，计算 (n-1)! ，再乘以 n 得到 n!
        return n * rfact(n - 1);  
    }
    else  // n == 0 时，返回 1 （0! = 1 ）
    {
        return 1;  
    }
}

/* 
代码测试及验证建议方案：
1. 基础功能验证：
   - 编译运行代码，输入合法值（如 5、10 ），检查循环和递归计算的阶乘结果是否一致且正确（5! = 120 、10! = 3628800 ），验证两种实现的正确性。
   - 输入边界值（0、12 ），查看结果是否符合预期（0! = 1 、12! = 479001600 ），测试边界条件处理。
2. 输入处理测试：
   - 输入负数（如 -3 ），检查是否提示 `No negative numbers, please.` ；输入大于 12 的数（如 13 ），检查是否提示 `Keep input under 13.` ，验证输入边界检查逻辑。
   - 输入非整数（如 `q`、`abc` ），观察循环是否终止，是否输出 `Bye.` ，测试 `scanf` 控制循环和程序退出的逻辑。
3. 递归与循环对比测试：
   - 尝试输入较大合法值（如 12 ），对比程序运行时循环和递归的执行效率（可通过观察输出速度，或借助编译器调试查看执行步骤 ），感受递归因函数调用带来的开销；修改递归函数为非尾递归形式（如在递归调用后加无关操作 ），对比尾递归和非尾递归的执行差异（如栈空间使用 ），加深对尾递归优化的理解。
   - 将递归和循环实现的函数体互换（如在 `fact` 中写递归逻辑，`rfact` 中写循环逻辑 ），测试程序是否仍能正确运行，强化对两种实现本质的掌握。
4. 类型与范围测试：
   - 输入 13 ，查看结果是否超出 `long` 类型范围（13! = 6227020800 ，超出 32 位 `long` 最大值 2147483647 ），观察输出是否异常（如出现负数或错误值 ），理解数据类型取值范围对结果的影响，验证边界提示的必要性。
   - 修改 `fact` 和 `rfact` 的返回值类型为 `unsigned long` 或 `long long` ，重新编译运行，输入 13 查看结果是否正确，体会类型调整对数据范围的扩展作用。
5. 易错点与拓展测试：
   - 故意删除递归函数的终止条件（注释 `else return 1;` ），输入合法值（如 3 ），观察程序是否因栈溢出崩溃，理解递归终止条件的重要性。
   - 拓展程序功能，如统计递归调用次数（定义全局变量记录 ），输入不同值查看递归深度，分析递归次数与输入值的关系，强化对递归执行流程的理解。 
*/