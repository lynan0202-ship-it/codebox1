// ------------------------------
// 题干：编写并测试 Fibonacci() 函数，该函数用循环代替递归计算斐波那契数。
// 知识要点：
//  1. 循环结构的使用（for 循环实现迭代计算）
//  2. 函数的定义与调用（封装斐波那契数计算逻辑）
//  3. 斐波那契数列的数学逻辑（前两项为 1，从第三项开始每一项是前两项之和 ）
// 总体逻辑：
//  1. 定义 `Fibonacci` 函数，通过循环迭代计算指定位置的斐波那契数
//  2. 在 `main` 函数中，调用 `Fibonacci` 函数，传入不同的位置参数进行测试并输出结果 
#include <stdio.h>

// 定义 Fibonacci 函数，用循环计算第 n 个斐波那契数
int Fibonacci(int n) {
    // 处理 n 为 1 或 2 的情况，斐波那契数列前两项通常定义为 1
    if (n == 1 || n == 2) { 
        return 1;
    }
    // 用于存储第 n-2 项的斐波那契数
    int prev_prev = 1; 
    // 用于存储第 n-1 项的斐波那契数
    int prev = 1; 
    // 用于存储当前计算的斐波那契数
    int current = 0; 
    // 从第 3 项开始循环计算
    for (int i = 3; i <= n; i++) { 
        // 当前项等于前两项之和
        current = prev_prev + prev; 
        // 更新前两项，为下一次循环做准备
        prev_prev = prev; 
        prev = current;
    }
    return current;
}

int main() {
    // 测试第 10 个斐波那契数，预期结果为 55
    int n = 10; 
    printf("第 %d 个斐波那契数是：%d\n", n, Fibonacci(n));

    // 可添加更多测试用例，比如测试第 5 个（预期 5 ）、第 15 个（预期 610 ）等
    n = 5;
    printf("第 %d 个斐波那契数是：%d\n", n, Fibonacci(n));

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存代码为 fibonacci.c
//     - 用 gcc 编译：gcc fibonacci.c -o fibonacci 
//     - 运行：./fibonacci（Linux/Mac） 或 fibonacci.exe（Windows）
//  2. 预期结果：
//     - 输入 n = 10 ，输出 “第 10 个斐波那契数是：55”
//     - 输入 n = 5 ，输出 “第 5 个斐波那契数是：5”
//  3. 检查点：
//     - 确认对于 n = 1、2 ，返回值为 1
//     - 确认循环计算逻辑正确，后续项的值等于前两项之和
// 易错点提醒：
//  1. 容易忘记处理 n = 1 和 n = 2 的特殊情况，导致计算结果错误
//  2. 在循环中更新前两项时，顺序容易写反，导致后续计算错误
//  3. 变量初始化或循环条件设置错误，比如循环从 i = 2 开始，导致结果偏差
// 拓展思考：
//  1. 如果要计算斐波那契数列的前 n 项，而不是第 n 项，如何修改函数？可通过数组存储并返回
//  2. 当 n 很大时（比如 n = 100 ），int 类型可能会溢出，如何处理？可改用 long long 类型或使用大数处理方法
//  3. 对比递归实现斐波那契函数，循环实现有什么优势？（递归可能存在栈溢出、效率低的问题，循环更高效且稳定 ） 