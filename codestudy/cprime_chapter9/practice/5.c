// ------------------------------
// 题干：编写并测试一个函数 larger_of()，该函数把两个 double 类型变量的值替换为较大的值。
//       例如，larger_of(x, y) 会把 x 和 y 中较大的值重新赋给两个变量。
// 知识要点：
//  1. 函数的参数传递（指针传递，实现修改实参的值 ）
//  2. 条件判断（比较两个数的大小 ）
//  3. 指针的解引用操作（通过指针修改变量的值 ）
// 总体逻辑：
//  1. 定义 `larger_of` 函数，接收两个 `double` 类型指针参数
//  2. 在函数内部比较两个指针指向的值的大小，将较大的值赋给两个指针指向的变量
//  3. 在 `main` 函数中定义两个 `double` 类型变量，调用 `larger_of` 函数并输出修改后的结果
#include <stdio.h>

// 定义 larger_of 函数，将两个 double 类型变量的值替换为较大的值
void larger_of(double *x, double *y) {
    // 如果 x 指针指向的值大于 y 指针指向的值
    if (*x > *y) { 
        // 将较大的值（*x ）赋给 y 指针指向的变量
        *y = *x; 
    } else {
        // 否则将较大的值（*y ）赋给 x 指针指向的变量
        *x = *y; 
    }
}

int main() {
    // 定义两个 double 类型的变量
    double x = 3.2, y = 5.7; 
    printf("调用函数前：x = %.1f，y = %.1f\n", x, y);

    // 调用 larger_of 函数，传递变量的地址
    larger_of(&x, &y); 

    printf("调用函数后：x = %.1f，y = %.1f\n", x, y);
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存代码为 larger_of.c
//     - 用 gcc 编译：gcc larger_of.c -o larger_of
//     - 运行：./larger_of（Linux/Mac） 或 larger_of.exe（Windows）
//  2. 预期结果：
//     - 调用函数后，x 和 y 的值都变为原来两个数中的较大值，示例中 5.7 
//  3. 检查点：
//     - 确认两个变量的值都被替换为较大的值
// 易错点提醒：
//  1. 容易忘记传递变量的地址（使用 `&` ），导致函数无法修改实参的值
//  2. 指针的解引用操作容易出错，要确保 `*x` 和 `*y` 表示的是变量的值
// 拓展思考：
//  1. 如果要处理三个变量，把它们的值都替换为最大的值，如何修改函数？可以增加指针参数或使用数组
//  2. 如果变量的值相等，函数的处理逻辑是否正确？可以传入两个相等的值测试 