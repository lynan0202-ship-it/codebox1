// ------------------------------
// 题干：编写并测试一个函数，该函数以 3 个 double 变量的地址作为参数，把最小值放入第 1 个变量，
//       中间值放入第 2 个变量，最大值放入第 3 个变量。
// 知识要点：
//  1. 指针参数传递（通过地址修改主函数变量）
//  2. 三数排序逻辑（比较、交换值实现排序）
//  3. 解引用操作（通过指针访问、修改变量值）
//  4. 嵌套条件判断（处理三数大小关系）
// 总体逻辑：
//  1. 定义 sort_three 函数，接收三个 double 指针，代表三个变量的地址
//  2. 先通过多次比较和交换，找出最小值、中间值、最大值
//  3. 把排序后的值，通过解引用指针，赋值给对应的变量
//  4. main 函数中定义三个变量，调用函数后打印结果，验证排序
#include <stdio.h>

// 定义排序函数，接收三个 double 变量的地址
void sort_three(double *a, double *b, double *c) {
    // 临时变量，用于交换值
    double temp; 

    // 步骤 1：确保 *a 是最小值（和 *b、*c 比较）
    // 如果 *a 比 *b 大，交换两者的值
    if (*a > *b) { 
        temp = *a;
        *a = *b;
        *b = temp;
    }
    // 如果 *a 比 *c 大，交换两者的值
    if (*a > *c) { 
        temp = *a;
        *a = *c;
        *c = temp;
    }

    // 步骤 2：确保 *b 是中间值（此时 *a 已最小，只需比较 *b 和 *c ）
    // 如果 *b 比 *c 大，交换两者的值，保证 *b <= *c
    if (*b > *c) { 
        temp = *b;
        *b = *c;
        *c = temp;
    }

    // 此时：
    // *a = 最小值，*b = 中间值，*c = 最大值
}

int main() {
    // 定义三个未排序的变量
    double num1 = 5.2, num2 = 1.8, num3 = 3.7; 

    printf("排序前：num1 = %.1f, num2 = %.1f, num3 = %.1f\n", num1, num2, num3);

    // 调用函数，传递变量地址，排序三个数
    sort_three(&num1, &num2, &num3); 

    printf("排序后：num1 = %.1f（最小）, num2 = %.1f（中间）, num3 = %.1f（最大）\n", 
           num1, num2, num3);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存代码为 exercise_6.c
//     - 编译：gcc exercise_6.c -o exercise_6 
//     - 运行：./exercise_6（Linux/Mac） 或 exercise_6.exe（Windows）
//  2. 预期结果：
//     - 排序前：num1=5.2, num2=1.8, num3=3.7 
//     - 排序后：num1=1.8（最小）, num2=3.7（中间）, num3=5.2（最大）
//  3. 检查点：
//     - 验证三个变量是否按 “最小、中间、最大” 排序
//     - 更换初始值（如 9.1, 2.5, 6.3 ），重新运行确认逻辑通用
// 易错点提醒：
//  1. 忘记用指针传递（如直接传变量名 num1 而非 &num1 ），导致函数无法修改主函数变量
//  2. 交换值时漏写临时变量 temp ，或交换逻辑写反（如 *a = *b; *b = temp; 顺序错 ）
//  3. 排序逻辑不完整（如只比较一次，没覆盖所有情况 ）
// 拓展思考：
//  1. 如果要排序更多数（如 4 个、5 个 ），如何修改代码？（用数组存储 + 冒泡排序/选择排序 ）
//  2. 如果变量中有重复值（如 2.3, 2.3, 5.1 ），排序是否仍正确？动手测试验证
//  3. 如何优化排序逻辑（如用更简洁的方式比较三数大小 ）？