// ------------------------------
// 题干：编写一个 to_base_n() 函数接受两个参数，第二个参数在 2~10 范围内，以指定进制打印第一个参数的数值。
// 知识要点：
//  1. 进制转换逻辑（除基取余法，递归或循环实现 ）
//  2. 函数参数处理（验证进制范围，处理特殊数值 ）
//  3. 递归函数应用（实现进制转换的递归输出 ）
// 总体逻辑：
//  1. 定义 `to_base_n` 函数，接收数值和进制参数，验证进制范围后，通过递归实现除基取余，输出转换后的进制数
//  2. 在 `main` 函数中调用 `to_base_n` 函数，测试不同数值和进制的转换
#include <stdio.h>

// 定义函数，递归实现进制转换并输出
void to_base_n(int num, int base) {
    // 验证进制是否在 2~10 范围内
    if (base < 2 || base > 10) { 
        printf("进制参数错误，需在 2~10 之间\n");
        return;
    }
    // 递归终止条件：当数值小于进制时，直接输出
    if (num < base) { 
        printf("%d", num);
        return;
    }
    // 递归调用，先转换高位
    to_base_n(num / base, base); 
    // 输出当前位的余数
    printf("%d", num % base); 
}

int main() {
    int num = 129, base = 8;
    printf("%d 的 %d 进制表示为：", num, base);
    to_base_n(num, base);
    printf("\n");

    // 测试其他情况，如 num = 10，base = 2（二进制 ）
    num = 10;
    base = 2;
    printf("%d 的 %d 进制表示为：", num, base);
    to_base_n(num, base);
    printf("\n");
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存代码为 to_base_n.c
//     - 用 gcc 编译：gcc to_base_n.c -o to_base_n
//     - 运行：./to_base_n（Linux/Mac） 或 to_base_n.exe（Windows）
//  2. 预期结果：
//     - 129 的 8 进制表示为 201 ；10 的 2 进制表示为 1010 
//  3. 检查点：
//     - 确认进制在 2~10 外时，函数提示错误
//     - 验证转换结果是否正确，可通过手动计算或其他工具验证
// 易错点提醒：
//  1. 容易忘记验证进制范围，导致传入非法进制时出现错误结果或运行异常
//  2. 递归输出时，顺序容易写反，导致高位和低位颠倒，结果错误
// 拓展思考：
//  1. 如何扩展函数支持 16 进制转换？需要修改余数的表示（如 A - F ），可添加字符映射逻辑
//  2. 如何实现非递归版本的进制转换函数？用循环和栈（或数组 ）存储余数，再逆序输出 