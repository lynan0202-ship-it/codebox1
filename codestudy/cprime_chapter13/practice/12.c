// ------------------------------
// 题干：12. 创建一个文本文件，内含20行，每行30个整数。这些整数都在0～9之间，用空格分开。该文件是用数字表示一张图片，0～9表示逐渐增加的灰度。编写一个程序，把文件中的内容读入一个20×30的int数组中。一种把这些数字转换为图片的粗略方法是：该程序使用数组中的值初始化一个20×31的字符数组，用0值对应的空字符，1对应点字符，以此类推，数字越大表示字符所占的空间越大。例如，用#表示9。每行的最后一个字符（第31个）是空字符，这样该数组包含了20个字符串。最后，程序显示最终的图片（即，打印所有的字符串），并将结果储存在文本文件中。
// 知识要点：
//  1. C语言文件操作（fopen、fscanf、fprintf、fclose的使用）
//  2. 二维数组的定义与遍历（20行30列的int数组，20行31列的char数组）
//  3. 字符映射逻辑（根据数字值选择对应字符，处理字符串结束符）
// 总体逻辑：
//  1. 打开输入文件，逐行读取30个整数，存入20×30的int数组。
//  2. 定义字符映射表，将0-9的数字对应到不同字符（如空格、.、:、~、*、=、+、#等）。
//  3. 遍历int数组，将每个数字转换为对应字符，存入20×31的char数组，每行末尾添加'\0'作为字符串结束。
//  4. 打开输出文件，逐行打印字符数组到屏幕，并写入文件。
//  5. 关闭所有文件，释放资源。

#include <stdio.h>

int main() {
    // 输入/输出文件名（假设输入为data.txt，输出为output.txt）
    const char *input_file = "data.txt";
    const char *output_file = "output.txt";
    
    // 存储原始数据：20行30列的int数组
    int data[20][30] = {0};
    // 字符映射表：0->空格，1->. ... 9->#（共10个字符）
    char symbols[] = " .:~*=+###";  // 索引0-9对应字符
    
    // 步骤1：读取输入文件
    FILE *fp_in = fopen(input_file, "r");
    if (fp_in == NULL) {
        printf("无法打开输入文件 %s\n", input_file);
        return 1;
    }
    for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 30; j++) {
            fscanf(fp_in, "%d", &data[i][j]);  // 逐个读取整数
        }
    }
    fclose(fp_in);  // 关闭输入文件
    
    // 步骤2：转换为字符数组（每行31列，末尾存'\0'）
    char chars[20][31] = {0};  // 初始化为全0（即'\0'）
    for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 30; j++) {
            int num = data[i][j];
            chars[i][j] = symbols[num];  // 根据数字映射字符
        }
        chars[i][30] = '\0';  // 每行末尾添加字符串结束符
    }
    
    // 步骤3：输出到屏幕和文件
    FILE *fp_out = fopen(output_file, "w");
    if (fp_out == NULL) {
        printf("无法打开输出文件 %s\n", output_file);
        return 1;
    }
    for (int i = 0; i < 20; i++) {
        printf("%s\n", chars[i]);  // 打印到屏幕
        fprintf(fp_out, "%s\n", chars[i]);  // 写入文件
    }
    fclose(fp_out);  // 关闭输出文件
    
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 新建data.txt，按格式写入20行、每行30个0-9的整数（空格分隔）。
//     - 编译：gcc 12.c -o 12 ；运行：./12（Windows下为12.exe）。
//  2. 预期结果：
//     - 屏幕打印20行字符（如0→空格，9→#），同时生成output.txt，内容与屏幕一致。
//  3. 检查点：
//     - 对比data.txt的数字和output.txt的符号，确保映射正确（如9→#）。
//     - 每行必须有30个可见字符（第31个是'\0'，不显示）。
// 易错点提醒：
//  1. 文件未检查打开失败：若data.txt不存在，程序会崩溃，需判断fopen返回值。
//  2. 字符数组越界：chars是20×31，循环j最多到29，末尾需手动加'\0'。
//  3. 映射表长度：symbols必须有10个元素（索引0-9），否则可能访问非法内存。
// 拓展思考：
//  1. 若输入文件格式错误（如行数不足、非数字），如何增强鲁棒性？可添加fscanf返回值检查。
//  2. 符号映射能否动态配置？比如从用户输入或配置文件读取。
//  3. 对比值传递与指针：数组名传参是指针传递（修改会影响原数组），此处直接操作数组，逻辑更直接。