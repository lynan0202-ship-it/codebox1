// ------------------------------
// 题干：9. 修改程序清单13.3中的程序，从1开始，根据加入列表的顺序为每个单词编号。当程序下次运行时，确保新的单词编号接着上次的编号开始。
// （假设原程序是链表存储单词，此处模拟“编号持久化”核心逻辑）
// 知识要点：
//  1. 文件持久化（fopen读写文件，保存/读取编号）
//  2. 程序启动/结束的状态保存（上次编号→本次编号→保存）
//  3. 简单流程控制（模拟节点添加过程）
// 总体逻辑：
//  1. 启动时读文件：尝试读取上次保存的编号，不存在则初始化为1
//  2. 模拟添加节点：每次用当前编号，用完后自增
//  3. 结束时写文件：将最新编号保存到文件，供下次使用
#include <stdio.h>

int main() {
    int last_id = 1; // 默认初始编号
    FILE *fp = fopen("last_id.txt", "r"); // 尝试读取上次编号

    if (fp != NULL) { // 文件存在，读取内容
        fscanf(fp, "%d", &last_id);
        fclose(fp);
    }

    printf("本次起始编号：%d\n", last_id);
    // 模拟添加3个节点（实际应为链表操作，此处简化演示）
    for (int i = 0; i < 3; i++) {
        printf("  添加节点，编号：%d\n", last_id);
        last_id++; // 编号自增
    }

    // 保存最新编号到文件
    fp = fopen("last_id.txt", "w");
    if (fp == NULL) {
        printf("错误：无法保存编号！\n");
        return 1;
    }
    fprintf(fp, "%d", last_id);
    fclose(fp);

    return 0;
}

// 测试验证方案：
//  1. 运行方式：
//     - 第一次运行：编译后直接执行，输出起始编号1，添加3个节点（1、2、3），保存last_id=4
//     - 第二次运行：再次执行，输出起始编号4，添加3个节点（4、5、6），保存last_id=7
//  2. 检查点：
//     - 查看last_id.txt文件内容，是否随运行更新（第一次是4，第二次是7）
//     - 程序启动时，若文件不存在，是否默认从1开始
// 易错点提醒：
//  1. fopen写模式（"w"）会覆盖文件，若误写为"a"会导致编号累加错误
//  2. 忘记关闭文件，可能导致数据未写入（缓冲区未刷新）
//  3. fscanf失败时，last_id未初始化（此处通过默认值1避免问题）
// 拓展思考：
//  1. 如何支持多个链表？可在文件中按“链表名 编号”格式存储（如"list1 5\nlist2 10"）
//  2. 异常退出（如崩溃）导致文件未保存？可在关键步骤强制刷新缓冲区（fflush(fp)）
// ------------------------------