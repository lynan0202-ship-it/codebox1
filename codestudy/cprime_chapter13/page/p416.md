### 一、核心知识要点总结（13.2.1~13.2.2 章节）  
#### 13.2.1 命令行参数与程序退出  
- **参数传递**：  
  - `argc`：命令行参数**个数**（程序名算第1个，如`./a.out file.txt`中`argc=2`）。  
  - `argv`：字符串数组，`argv[0]`是**程序名**，`argv[1]`开始是用户参数。  
- **程序退出**：  
  - `exit(EXIT_SUCCESS)`：正常退出（等价于`main`中`return 0`）。  
  - `exit(EXIT_FAILURE)`：异常退出（需包含`<stdlib.h>`）。  
  - **`return` vs `exit`**：  
    | 对比维度       | `return`（在`main`中）       | `exit()`（任意函数）          |  
    |----------------|------------------------------|------------------------------|  
    | 作用范围       | 仅退出当前`main`函数         | 直接终止**整个程序**          |  
    | 递归场景       | 逐层返回上一级递归           | 直接终止，忽略递归层级        |  


#### 13.2.2 `fopen`函数与文件模式  
- **核心功能**：打开文件，返回`FILE*`指针（失败则为`NULL`），需配合`fclose`关闭。  
- **模式字符串（表13.1提炼）**：  
  | 模式   | 文本/二进制 | 行为描述（文件存在时）          | 适用场景               |  
  |--------|-------------|---------------------------------|------------------------|  
  | `"r"`  | 文本        | 只读，文件必须存在              | 读取已有文本文件       |  
  | `"w"`  | 文本        | 清空文件（不存在则创建）        | 重写/新建文本文件      |  
  | `"a"`  | 文本        | 追加到文件末尾（不存在则创建）  | 日志记录               |  
  | `"rb"` | 二进制      | 只读，按原始字节读取            | 读取图片、可执行文件   |  
  | `"wx"` | 文本（C11） | 独占创建，文件存在则失败        | 防止竞争条件（如锁文件）|  
- **文件指针`FILE*`**：  
  指向`stdio.h`定义的**结构体**，存储文件状态（如当前位置、缓冲区、错误标记），是标准I/O函数的“操作句柄”。  


### 二、目标段落逻辑梳理（命令行参数 → `fopen` → 错误处理）  
1. **需求驱动**：程序需要**操作文件** → 必须从命令行获取**文件名** → 需检查`argc`。  
2. **参数检查**：  
   - 若`argc≠2` → 用`argv[0]`输出程序名（如`./a.out`）→ 提示用法 → `exit(EXIT_FAILURE)`。  
3. **文件打开**：  
   - 调用`fopen(argv[1], "r")` → 返回`FILE* fp`。  
   - 若`fp==NULL`（文件不存在/权限不足）→ 报错 → `exit(EXIT_FAILURE)`。  
4. **资源释放与退出**：  
   - 操作完成后`fclose(fp)` → 正常`return 0`（等价于`exit(EXIT_SUCCESS)`）。  


### 三、编程知识点：命令行+`fopen`综合示例  
```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    char ch;

    // 1. 检查命令行参数：必须提供1个文件名
    if (argc != 2) {
        // argv[0]自动获取程序名，错误提示更灵活
        printf("Usage: %s filename\n", argv[0]); 
        exit(EXIT_FAILURE); // 异常退出，终止程序
    }

    // 2. 打开文件：文本只读模式
    fp = fopen(argv[1], "r"); 
    if (fp == NULL) { // 打开失败的判断
        printf("Error: Can't open %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    // 3. 逐字符读取并打印（模拟文件内容预览）
    while ((ch = fgetc(fp)) != EOF) { // EOF是文件结束标志（-1）
        putchar(ch); // 输出到屏幕
    }

    // 4. 关闭文件（必须执行，否则缓冲区数据可能丢失）
    fclose(fp);

    return 0; // 等价于exit(EXIT_SUCCESS)（仅在main中）
}
```  
**关键注释解析**：  
- `argv[0]`：保证错误提示随程序名变化（如程序重命名为`mycat`，提示也会变成`Usage: mycat filename`）。  
- `fgetc` vs `getc`：功能相同，`fgetc`是函数，`getc`可宏实现，这里用`fgetc`更直观。  
- **易错点**：若把`ch`定义为`char`，当读取到`0xFF`（如特殊字符）时，会被解释为`-1`（EOF），导致循环提前终止，因此必须用`int`存储返回值！  


### 四、扩展知识点补充  
#### 1. 命令行参数的深层用法  
- **多参数处理**：如`./program file1.txt file2.txt`，可通过`argc`遍历`argv[1]`到`argv[argc-1]`，实现多文件操作。  
- **路径问题**：`argv[1]`可传入相对路径（`../data.txt`）或绝对路径（`/home/user/file.txt`），由系统解析。  


#### 2. `fopen`模式的细节陷阱  
- **Windows 文本模式**：写入`"\n"`会自动转为`"\r\n"`（回车+换行），读取时`"\r\n"`转`"\n"`；二进制模式（`"rb"`/`"wb"`）则保留原始字节。  
- **`"wx"` 模式的价值**：在多进程环境中，`"wx"`确保文件**独占创建**，避免多个程序同时创建同一文件导致数据冲突。  


#### 3. 错误处理的增强  
- **`perror` 函数**：替代`printf`，自动打印系统错误原因（需包含`<stdio.h>`）：  
  ```c
  if (fp == NULL) {
      perror("fopen"); // 输出如：fopen: No such file or directory
      exit(EXIT_FAILURE);
  }
  ```  
- **`errno` 变量**：定义在`<errno.h>`，`fopen`失败时，`errno`会被设置为具体错误码（如`ENOENT`表示文件不存在）。  


通过以上拆解，可清晰掌握**命令行交互**与**文件打开**的核心逻辑，以及`exit`、`fopen`的细节差异，为复杂文件操作奠定基础。