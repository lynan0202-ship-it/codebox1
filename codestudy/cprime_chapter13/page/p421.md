/*
代码名称：addword.c（文件单词追加程序：演示fprintf、fscanf、rewind用法）
知识要点总结：
1. 文件打开模式 "a+"：  
   - 写操作：数据始终追加到文件末尾（即使移动了读指针）  
   - 读操作：默认指针在文件末尾，需用rewind()重置到开头才能读取历史内容  
2. fprintf/FILE*：格式与printf一致，但输出目标是文件（第一个参数为文件指针）  
3. fscanf/FILE*：格式与scanf一致，但输入源是文件（第一个参数为文件指针）  
4. rewind(FILE*)：将文件内部的读写指针强制移到起始位置  
5. 交互逻辑：用户输入单词，以#开头的单词终止输入；程序自动追加内容并回显文件全量数据  

总体逻辑说明：  
① 打开文件：以"a+"模式打开wordy文件（支持追加写入和读取，无文件则创建）  
② 用户输入：循环读取终端输入的单词，若单词首字符是#则停止，否则写入文件  
③ 内容回显：调用rewind()将文件指针移到开头，逐词读取文件内容并输出到屏幕  
④ 资源释放：关闭文件，检查关闭操作是否成功  
*/

#include <stdio.h>
#include <stdlib.h>  // 提供exit()和EXIT_FAILURE常量
#define MAX 41       // 单词最大长度（40个有效字符 + 1个结束符'\0'）

int main(void) {
    FILE *fp;         // 指向目标文件的指针
    char words[MAX];  // 存储输入/读取的单词

    // ---------- 1. 打开文件（关键：a+模式的特性） ----------
    // "a+"模式细节：
    // - 写：新内容永远追加到文件末尾（即使之前用rewind移动了指针）
    // - 读：初始指针在文件末尾，必须用rewind才能读之前的内容
    if ((fp = fopen("wordy", "a+")) == NULL) {
        fprintf(stderr, "Can't open \"wordy\" file.\n");  // 错误信息输出到标准错误
        exit(EXIT_FAILURE);  // 异常退出，终止程序
    }

    // ---------- 2. 提示用户输入单词 ----------
    puts("Enter words to add to the file; press the Enter");
    puts("key at the beginning of a line to terminate.");
    // 循环条件解析：
    // - fscanf(stdin, "%s", words) == 1：从终端成功读入1个单词（%s会跳过空格/换行）
    // - words[0] != '#'：单词首字符不是#（若输入#，立即终止循环）
    while (fscanf(stdin, "%s", words) == 1 && words[0] != '#') {
        fprintf(fp, "%s\n", words);  // 把单词写入文件，每行一个（加换行符分隔）
    }

    // ---------- 3. 读取并输出文件全部内容 ----------
    puts("File contents:");
    rewind(fp);  // 必须调用！否则文件指针在末尾，fscanf会直接读到EOF
    // 循环读取文件内容：
    // fscanf(fp, "%s", words) == 1 → 从文件成功读入1个单词
    while (fscanf(fp, "%s", words) == 1) {
        puts(words);  // 将读取的单词输出到屏幕
    }
    puts("Done!");  // 提示操作完成

    // ---------- 4. 关闭文件（检查错误） ----------
    if (fclose(fp) != 0) {
        fprintf(stderr, "Error closing file\n");  // 关闭失败时提示
    }

    return 0;  // 正常退出
}


/*
代码测试及验证建议方案：
1. 首次运行验证：  
   • 编译：gcc addword.c -o addword  
   • 运行：./addword  
   • 输入：apple banana #（按回车，输入#结束）  
   • 检查：  
     - 是否生成wordy文件？  
     - wordy内容是否为 apple\nbanana\n？  
     - 程序输出的File contents是否显示apple和banana？  

2. 追加功能验证：  
   • 再次运行./addword  
   • 输入：cherry date #  
   • 检查wordy内容：apple\nbanana\ncherry\ndate\n（追加成功）  
   • 程序输出是否包含4个单词？  

3. rewind必要性测试：  
   • 注释掉rewind(fp); 这行，重新编译运行  
   • 输入：test # → 观察File contents是否为空（因指针在末尾，读不到内容）  
   • 恢复rewind，验证内容正常输出，理解rewind的作用  

4. 边界输入测试：  
   • 输入空行：运行程序后直接按回车，再输入# → 检查文件是否无新内容（fscanf跳过空白，空行不触发写入）  
   • 输入#开头的单词：比如#stop → 立即终止输入，文件内容不变  
   • 输入超长单词（40个字符）：比如输入40个a → 检查words数组是否正确存储（截断为40个a + '\0'）  

5. 错误场景测试：  
   • 修改代码，将fopen模式改为"a"（去掉+），尝试读取文件 → 观察fscanf是否失败（"a"模式仅支持写，读会报错）  
   • 删除wordy文件后运行程序 → 检查是否自动创建新文件并正常工作  

6. 文件模式特性验证：  
   • 先运行程序写入内容，再用文本编辑器手动修改wordy内容  
   • 再次运行程序追加新单词 → 检查手动修改的内容是否保留（验证"a+"模式不会覆盖历史数据）  
*/