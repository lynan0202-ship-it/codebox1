### 一、核心知识总结（13.4.2 `fgets()` 和 `fputs()` 函数）  
#### 1. `fgets()` 函数  
- **功能**：从文件/标准流（如 `stdin`）读取**一行数据**，存入字符数组。  
- **参数规则**：  
  - `buf`：存储内容的字符数组（目标地址）。  
  - `STLEN`：最大读取字符数（实际读 `STLEN-1` 个，留 1 位存 `\0`）。  
  - `fp`：文件指针（指定读取的文件/流，如 `stdin`/`fp`）。  
- **读取逻辑**：  
  - 终止条件：遇到 **换行符 `\n`**、**文件末尾（EOF）** 或 **读满 `STLEN-1` 字符**。  
  - 保留换行：若读取完整行，`\n` 会被存入 `buf`（位于 `\0` 之前）。  
- **返回值**：  
  - 成功：返回 `buf` 地址（非 `NULL`）；  
  - 失败/结束：返回 `NULL`（可判断文件结束）。  

#### 2. `fputs()` 函数  
- **功能**：将字符串写入文件/标准流（如 `stdout`）。  
- **参数规则**：  
  - `buf`：要写入的字符串（以 `\0` 结尾，**不自动加换行符**）。  
  - `fp`：文件指针（指定写入目标，如 `stdout`/`fp`）。  
- **写入逻辑**：仅写字符串内容（直到 `\0`），**不额外添加换行符**（与 `puts` 不同）。  
- **返回值**：  
  - 成功：返回非负整数（如非 `EOF`）；  
  - 失败：返回 `EOF`（需检查错误）。  

#### 3. 核心关联  
- **互补性**：`fgets` 保留输入的换行符，`fputs` 不添加额外换行符，两者配合可 **精准复制行内容**（如文件拷贝时保持格式）。  


### 二、段落逻辑梳理（因果/递进关系）  
#### `fgets()` 逻辑链：  
`功能定位`（读一行） → `参数设计`（控缓冲区、长度、文件） → `终止条件`（换行/EOF/长度） → `返回值意义`（成功/失败判断）。  

#### `fputs()` 逻辑链：  
`功能定位`（写字符串） → `参数设计`（字符串、目标文件） → `写入特性`（不加换行，与 `fgets` 互补） → `返回值判断`（成功/失败）。  

#### 两者关系：  
`场景需求`（精准处理行格式） → `fgets（存\n）` + `fputs（不补\n）` → `完美保留行结构`。  


### 三、编程示例（文件拷贝：逐行复制）  
```c
#include <stdio.h>
#define BUF_SIZE 100  // 每行最多存 99 字符 + \0

int main() {
    FILE *in, *out;
    char buf[BUF_SIZE];

    // 1. 打开文件（输入：in.txt，输出：out.txt）
    in = fopen("in.txt", "r");
    out = fopen("out.txt", "w");
    if (in == NULL || out == NULL) {
        fprintf(stderr, "文件打开失败！\n");
        return 1;
    }

    // 2. 逐行读取并写入
    while (fgets(buf, BUF_SIZE, in) != NULL) {  // 读一行，直到 EOF
        fputs(buf, out);  // 写入一行（buf 含 \n，fputs 不额外加，保持格式）
    }

    // 3. 关闭文件
    fclose(in);
    fclose(out);
    printf("文件拷贝完成！\n");
    return 0;
}
```  
**说明**：  
- **安全特性**：`BUF_SIZE` 避免缓冲区溢出（对比废弃函数 `gets` 的危险性）。  
- **换行处理**：若 `in.txt` 行是 `"Hello\n"`，`fgets` 存为 `"Hello\n\0"`，`fputs` 写入后仍为 `"Hello\n"`，格式不变。  
- **终止判断**：`fgets` 返回 `NULL` 时，说明读到 EOF，结束循环。  


### 四、对比表格（`fgets`/`fputs` vs 类似函数）  
| 函数      | 功能                  | 关键差异                          | 安全特性          | 典型场景               |  
|-----------|-----------------------|-----------------------------------|-------------------|------------------------|  
| **`fgets`** | 读一行到字符数组      | 需指定长度，保留换行符            | 安全（防溢出）    | 文件逐行读、用户输入   |  
| **`gets`**  | 读一行到字符数组      | 无长度限制，易溢出（已废弃）      | 危险              | （不建议使用）         |  
| **`fputs`** | 写字符串到文件        | 不自动加换行符                    | 可控              | 配合 `fgets` 复制内容  |  
| **`puts`**  | 写字符串到标准输出    | 自动加换行符                      | 简单但不灵活      | 终端快速输出           |  


### 五、扩展知识点（延伸学习）  
#### 1. `fgets` 细节深化  
- **换行符处理**：  
  - 若行短于 `STLEN-1`：`buf` 含 `\n`（如 `Hi` → `Hi\n\0`）。  
  - 若行长于 `STLEN-1`：读 `STLEN-1` 字符，**不含 `\n`**（剩余内容下次读取）。  
- **标准输入场景**：`fgets(stdin, ...)` 可读取含空格的行（对比 `scanf("%s")` 跳过空格）。  

#### 2. `fputs` 错误处理  
- 磁盘满、设备断开时，`fputs` 返回 `EOF`，需检查：  
  ```c
  if (fputs(buf, out) == EOF) {
      fprintf(stderr, "写入失败！\n");
  }
  ```  

#### 3. 延伸应用  
- **日志系统**：用 `fgets` 读配置行，`fputs` 写日志（保留格式）。  
- **网络通信**：通过 `fdopen` 将 socket 封装为 `FILE*`，复用 `fgets`/`fputs` 收发文本。  
- **用户交互**：`fgets(stdin, ...)` 读取含空格的用户名（比 `scanf` 更灵活）。  


通过以上梳理，可清晰掌握 `fgets`/`fputs` 的核心用法、安全优势，以及与其他函数的差异，结合示例和扩展知识，深入理解行级文件操作的细节。