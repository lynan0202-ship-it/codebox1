

### 13.8~13.9 核心知识精讲  


#### 一、核心概念提炼（分点总结）  
##### 1. 「流」的本质  
- **抽象模型**：输入/输出是**字节流**，无需关心物理设备（键盘、文件、网络均可统一处理）。  
- **解释权**：由函数决定如何解析流（如 `fgetc` 按字符读，`fread` 按二进制块读）。  

##### 2. 文件模式的决策逻辑  
| **需求**                | 选文本模式                     | 选二进制模式                   |  
|-------------------------|--------------------------------|--------------------------------|  
| 数据类型                | 字符串、人类可读内容           | 数值、结构体、图片等非文本数据 |  
| 换行符处理              | 自动转换（如 `\n`↔`\r\n`）     | 直接读写 `\n`（无转换）        |  
| 精度要求                | 允许丢失（如 `double` 转字符串）| 必须精准（保留内存二进制布局）  |  
| 典型场景                | 日志、配置文件                | 数据库、可执行文件、多媒体数据  |  

##### 3. FILE 指针的核心作用  
- **控制结构体**：包含 **缓冲区、当前位置、错误标记**（`ferror`/`feof` 依赖此状态）。  
- **生命周期**：`fopen` 创建 → 读写函数操作 → `fclose` 销毁（必须关闭，否则缓冲数据可能丢失）。  

##### 4. EOF 处理的关键细节  
- **检测时机**：输入函数（如 `getc`）**读取后** 才会检测到 EOF，因此正确逻辑是：  
  ```c
  int ch;
  while ((ch = getc(fp)) != EOF) { ... } // 先读，再判EOF
  ```  
- **易错点**：提前调用 `feof(fp)` 会返回 `0`（EOF 标记未设置），导致逻辑错误。  


#### 二、逻辑关系梳理（标准I/O工作流）  
```mermaid
graph TD
    A[程序] --> B[FILE*指针] 
    B --> C[流结构<br/>(缓冲+文件+状态)] 
    C --> D[读写函数<br/>(文本/二进制解析)] 
    D -->|文本模式| E[换行符自动转换<br/>(如Windows下写\n为\r\n)] 
    D -->|二进制模式| F[直接字节操作<br/>(保留内存精度)] 
    E --> G[人类可读文件<br/>(.txt)] 
    F --> H[二进制文件<br/>(.dat)] 
    style B fill:#FFE4E1,stroke:#993333
    style C fill:#E0FFFF,stroke:#008080
```  


#### 三、编程示例：文本 vs 二进制模式对比（文件复制）  
```c
/* 
程序名称：mode_compare.c  
知识要点：  
1. 文本/二进制模式的换行符差异。  
2. FILE指针的模式选择（"r"/"rb"、"w"/"wb"）。  
3. EOF判断与错误处理（ferror）。  

总体逻辑：  
1. 分别以文本和二进制模式复制同一文件（含换行符）。  
2. 对比目标文件的大小和内容（文本模式下Windows会多\r字节）。  
*/

#include <stdio.h>
#include <stdlib.h>

#define BUFSIZE 1024

// 通用复制函数（支持文本/二进制模式）
void copy_file(const char *src, const char *dest, const char *mode) {
    FILE *fp_src = fopen(src, mode);
    FILE *fp_dest = fopen(dest, mode);
    if (!fp_src || !fp_dest) {
        perror("文件打开失败");
        exit(EXIT_FAILURE);
    }

    char buf[BUFSIZE];
    size_t bytes;
    while ((bytes = fread(buf, 1, BUFSIZE, fp_src)) > 0) {
        fwrite(buf, 1, bytes, fp_dest);
    }

    if (ferror(fp_src) || ferror(fp_dest)) {
        fprintf(stderr, "读写错误！\n");
    }

    fclose(fp_src);
    fclose(fp_dest);
}

int main() {
    const char *src = "source.txt";  // 源文件（含\n换行）
    // 准备源文件内容（手动创建或代码写入，此处省略）

    // 1. 文本模式复制
    copy_file(src, "text_copy.txt", "r"); // 读文本模式
    copy_file(src, "text_copy.txt", "w"); // 写文本模式

    // 2. 二进制模式复制
    copy_file(src, "bin_copy.dat", "rb");// 读二进制模式
    copy_file(src, "bin_copy.dat", "wb");// 写二进制模式

    printf("复制完成！\n");
    printf("文本模式文件：text_copy.txt（可观察换行符变化）\n");
    printf("二进制模式文件：bin_copy.dat（大小与源文件一致）\n");
    return 0;
}
```  

**代码说明**：  
- **模式差异**：文本模式下，Windows环境写文件时 `\n` 会自动转为 `\r\n`（文件变大）；二进制模式保持 `\n`（大小与源文件一致）。  
- **验证方法**：用文本编辑器打开 `text_copy.txt`（换行正常），用二进制编辑器（如HxD）对比 `bin_copy.dat` 和源文件（字节完全一致）。  


#### 四、对比表格（标准I/O核心函数）  
| **功能**       | **文本模式函数**       | **二进制模式函数**     | **关键差异**                     |  
|----------------|------------------------|------------------------|----------------------------------|  
| 写数据         | `fprintf`              | `fwrite`               | 文本：格式转换；二进制：直接写内存 |  
| 读数据         | `fscanf`/`fgetc`       | `fread`                | 文本：解析字符；二进制：读字节块   |  
| 定位           | `fseek`（慎用SEEK_END）| `fseek`（精准）        | 文本模式下SEEK_END可能因换行符失真 |  
| 换行符处理     | 自动转换               | 无转换                 | 文本模式隐式处理，二进制显式控制   |  


#### 五、扩展知识点补充  
##### 1. 缓冲的隐形规则（进阶）  
- **全缓冲**：普通文件默认，缓冲满或 `fflush` 时刷盘（提升大文件效率）。  
- **行缓冲**：`stdout` 默认，换行或 `fflush` 时刷盘（如 `printf("Hello")` 需 `\n` 才显示）。  
- **无缓冲**：`stderr` 默认，立即刷盘（确保错误信息不丢失）。  

##### 2. 跨平台兼容陷阱  
- **换行符**：Windows文本模式自动处理 `\r\n`，但二进制模式需手动转换（可通过宏判断系统）：  
  ```c
  #ifdef _WIN32
      // 处理\r\n
  #else
      // 处理\n
  #endif
  ```  
- **字节序**：二进制模式下，跨平台传输需转换大端/小端（如用 `htons` 转换网络字节序）。  

##### 3. 高级流操作  
- **重定向**：通过 shell 重定向流（如 `./a.out < input.txt > output.txt`），程序无需修改，直接处理 `stdin`/`stdout`。  
- **流拼接**：多个输入流可通过管道拼接（如 `cat file1 file2 | ./a.out`），程序只需循环读 `stdin`。  




通过以上讲解，可系统掌握 **流的抽象、模式选择、函数协作** 的核心逻辑，结合代码和扩展知识，能应对文件读写的实际场景（如跨平台、高精度数据、实时日志等）。