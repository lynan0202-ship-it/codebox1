### 一、核心知识总结（13.5.2~13.5.4 文件模式与定位函数）  
#### 1. 二进制模式 vs 文本模式  
| **对比维度**       | **二进制模式**                     | **文本模式**                         |  
|--------------------|------------------------------------|--------------------------------------|  
| **换行符处理**     | 不转换，直接读写 `\n`              | DOS/Windows 下：写 `\n` → `\r\n`，读 `\r\n` → `\n`；UNIX 无转换 |  
| **字节计数逻辑**   | `ftell` 返回**实际字节位置**       | `ftell` 返回**逻辑位置**（含换行符转换的影响） |  
| **`fseek` 支持**   | `SEEK_SET/CUR/END` 均可靠          | `SEEK_END` 可能失效（因文件大小受转换影响） |  
| **EOF 标记（Ctrl+Z）** | 视为普通字节                       | DOS 环境下可能将 `Ctrl+Z` 视为文件结尾   |  
| **适用场景**       | 非文本文件（图片、二进制数据）     | 文本文件读写                         |  


#### 2. 定位函数核心结论  
- **`fseek`**：设置文件指针位置，参数为 `(文件指针, 偏移量, 起始位置)`（`SEEK_SET`/`CUR`/`END`），文本模式下 `SEEK_END` 可能受限。  
- **`ftell`**：返回当前位置，二进制模式返回实际字节数，文本模式返回逻辑位置（非实际字节）。  
- **`fgetpos`/`fsetpos`**：通过 `fpos_t` 类型记录位置，避免 `long` 溢出问题，ANSI C 推荐，跨系统更可靠。  


### 二、段落逻辑梳理（二进制与文本模式的差异因果）  
1. **背景**：UNIX 和 MS-DOS 文本文件格式不同（UNIX 用 `\n`，DOS 用 `\r\n`）。  
2. **文本模式的设计**：为适配不同系统，自动转换换行符（写 `\n` → `\r\n`，读 `\r\n` → `\n`），导致 `ftell` 无法返回实际字节数。  
3. **二进制模式的设计**：不处理换行符和 `Ctrl+Z`，严格按字节读写，`ftell`/`fseek` 直接操作实际位置。  
4. **冲突点**：DOS 文本文件可能因 `Ctrl+Z` 虚假结尾，二进制模式无此问题；文本模式 `SEEK_END` 因换行符转换，文件大小不确定，导致定位失效。  


### 三、编程举例（文本 vs 二进制模式的换行符差异）  
```c
#include <stdio.h>

int main() {
    // 1. 文本模式写文件：测试换行符转换
    FILE *fp_txt = fopen("text_mode.txt", "w");
    fputc('\n', fp_txt);  // DOS 环境下，实际写入 \r\n（2 字节）
    fclose(fp_txt);

    // 2. 二进制模式写文件：测试原始字节
    FILE *fp_bin = fopen("bin_mode.bin", "wb");
    fputc('\n', fp_bin);  // 实际写入 \n（1 字节）
    fclose(fp_bin);

    // 3. 验证文件大小（DOS/Windows 环境下运行）
    //    text_mode.txt 大小为 2 字节，bin_mode.bin 大小为 1 字节
    return 0;
}
```  
**说明**：  
- 文本模式下，`\n` 自动转换为 `\r\n`，文件大小增加；二进制模式保持原始字节。  
- UNIX 环境下两者均为 1 字节（无转换），体现**系统差异对模式的影响**。  


### 四、扩展知识点补充  
#### 1. 换行符跨平台差异  
- **Windows**：`\r\n`（`0x0D 0x0A`）  
- **Linux/MacOS**：`\n`（`0x0A`）  
- **旧版 Mac**：`\r`（`0x0D`）  
  → 文本模式的换行转换是“隐式兼容”，但二进制模式需手动处理跨平台换行（如统一用 `\n` 存储，读取时判断系统）。  

#### 2. `fpos_t` 的底层设计  
- `fpos_t` 可能是**结构体**（而非简单整数），用于存储复杂定位信息（如多字节编码偏移），因此必须通过 `fgetpos`/`fsetpos` 操作，不能直接赋值。  

#### 3. 高级应用场景  
- **随机访问文件**（如数据库、视频）：必须用二进制模式 + `fseek`/`fgetpos`，确保位置精准。  
- **大文件支持**：`long` 类型可能溢出（如 2GB 以上文件），`fpos_t` 由系统定义，更适合现代大文件。  


### 五、关键对比表格（函数对比）  
| **函数**       | **返回/参数类型** | **优势**                     | **局限性**               |  
|----------------|-------------------|------------------------------|--------------------------|  
| `ftell`        | `long`            | 简单直观，旧代码兼容         | 受 `long` 范围限制（可能溢出） |  
| `fgetpos`      | `fpos_t`          | 无溢出风险，跨系统稳定       | 需配对 `fsetpos` 使用    |  
| `fseek`        | `int`（成功返回 0）| 支持灵活偏移（如 `SEEK_END-1`） | 文本模式下 `SEEK_END` 不可靠 |  


通过以上梳理，可清晰掌握 **文件模式的底层差异** 和 **定位函数的使用场景**，结合代码和扩展知识，能更高效处理跨平台文件操作问题。