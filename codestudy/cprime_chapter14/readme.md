### 一、主题核心知识要点总结  
#### 关键概念与核心结论：  
1. **语法元素**：  
   - `struct`（结构体）：组合不同类型数据，创建自定义复合类型。  
   - `union`（联合体）：共享同一块内存存储不同类型数据（成员互斥使用）。  
   - `typedef`：为类型取别名，简化代码。  
   - 成员访问符：`.`（结构体变量用）、`->`（结构体指针用）。  

2. **结构体核心逻辑**：  
   - **必要性**：简单变量/数组无法表示复杂实体（如“学生”含学号、姓名、成绩），结构体弥补这一不足。  
   - **使用流程**：定义结构体模板（类型）→ 声明结构体变量 → 通过 `.` 或 `->` 访问成员 → 编写函数处理结构体（如计算、打印）。  

3. **联合体特性**：  
   - 内存共享：所有成员共用同一块内存，大小等于**最大成员的大小**（而非总和）。  
   - 互斥性：同一时间仅能有效使用一个成员（否则数据会覆盖）。  

4. **函数指针**：  
   - 存储函数的地址，可用于**回调函数**（如排序时传入比较逻辑）。  


### 二、目标段落逻辑梳理（“设计程序时……”段落）  
**逻辑关系（因果+递进）**：  
1. **因**：编程需选择合适的数据表示方法，但简单变量/数组能力不足（无法描述多属性的复杂实体）。  
2. **果**：C 语言提供 **结构体变量**，允许将不同类型数据“打包”成新形式。  
3. **类比**：若熟悉 Pascal 的“记录（record）”，可快速理解结构体（二者设计思想相似）。  
4. **延伸**：后续通过示例学习结构体的创建与使用，逐步掌握其语法。  


### 三、编程知识点举例（结构体的定义、使用与函数处理）  
#### 示例 1：结构体基本操作（变量创建、成员访问）  
```c
#include <stdio.h>
#include <string.h> // 用于strcpy

// 1. 定义结构体模板（描述“学生”的类型）
struct Student {
    int id;         // 学号（整型）
    char name[20];  // 姓名（字符数组）
    float score;    // 成绩（浮点型）
};

int main() {
    // 2. 创建结构体变量（两种方式：直接定义 / 指针+动态分配）
    struct Student stu1; // 直接定义变量
    struct Student *p = &stu1; // 指针指向变量

    // 3. 赋值（. 访问变量成员，-> 访问指针指向的成员）
    stu1.id = 101;                // 直接访问：变量.成员
    strcpy(stu1.name, "LiLei");   // 字符数组需用strcpy赋值
    p->score = 92.5;              // 指针访问：指针->成员

    // 4. 输出
    printf("学号：%d，姓名：%s，成绩：%.1f\n", 
           stu1.id,   // 等价于 p->id
           p->name,   // 等价于 stu1.name
           stu1.score);

    return 0;
}
```  
**说明**：  
- 字符数组 `name` 不能直接赋值（如 `stu1.name = "LiLei"` 会报错），需用 `strcpy` 复制字符串。  
- `.` 和 `->` 效果等价：`p->id` 等价于 `(*p).id`，但 `->` 更简洁。  


#### 示例 2：函数处理结构体（计算总成绩）  
```c
// 定义“课程成绩”结构体
struct Course {
    float math;   // 数学成绩
    float english;// 英语成绩
};

// 函数：接收结构体，返回总成绩（值传递，适合小结构体）
float calcTotal(struct Course c) {
    return c.math + c.english;
}

int main() {
    // 初始化结构体（也可逐字段赋值）
    struct Course c1 = {88.5, 94.0}; 
    float total = calcTotal(c1);
    printf("总成绩：%.1f\n", total); // 输出：182.5
    return 0;
}
```  
**进阶优化**：若结构体很大，建议传递**指针**（避免拷贝开销）：  
```c
float calcTotal(struct Course *c) {
    return c->math + c->english; // 指针访问成员
}
// 调用：calcTotal(&c1);
```  


### 四、对比表格（结构体 vs 联合体）  
| **特性**        | **结构体（struct）**                     | **联合体（union）**                     |
|-----------------|------------------------------------------|------------------------------------------|
| **内存分配**    | 成员依次存储，总大小 ≥ 成员大小之和（含内存对齐） | 所有成员共享同一块内存，大小 = 最大成员的大小 |
| **成员访问**    | 可同时读写多个成员（互不干扰）            | 同一时间仅能有效使用一个成员（否则数据覆盖） |
| **典型场景**    | 描述复杂实体（如学生、商品、坐标）        | 节省内存，处理互斥类型（如数据解析、状态标记） |
| **代码示例**    | `struct { int a; char b; }`（大小 ≥ 5）   | `union { int a; char b; }`（大小 = 4）     |  


### 五、扩展知识点（围绕结构体）  
1. **内存对齐**：  
   - 编译器为提高访问效率，会让结构体成员按**对齐规则**存储（如 `int` 对齐到 4 字节地址），导致结构体大小可能大于成员总和。  
   - 可通过 `#pragma pack(n)` 手动控制对齐（如 `#pragma pack(1)` 取消对齐，强制紧凑存储）。  

2. **typedef 简化结构体**：  
   ```c
   typedef struct { // 直接为匿名结构体取别名
       int x, y;
   } Point; // 后续可直接用 Point 定义变量，无需写 struct
   Point p = {10, 20}; // 等价于 struct Point p = {10, 20};
   ```  

3. **结构体的高级应用**：  
   - **结构体数组**：存储多个同类型结构体（如 `struct Student class[50];` 表示 50 名学生）。  
   - **链表节点**：用指针指向同类型结构体，构建链表（核心数据结构）：  
     ```c
     struct Node {
         int data;
         struct Node *next; // 指向自身类型的指针
     };
     ```  
   - **嵌套结构体**：结构体成员可以是另一个结构体（如 `struct Date` 作为 `struct Student` 的成员）。  

4. **函数指针的实际场景**：  
   - 实现**回调函数**（如 `qsort` 排序时，传入自定义比较函数的指针）：  
     ```c
     // 比较函数原型（qsort要求的格式）
     int compare(const void *a, const void *b) {
         return (*(int*)a - *(int*)b); // 升序比较
     }
     int main() {
         int arr[] = {3,1,2};
         qsort(arr, 3, sizeof(int), compare); // 传入函数指针
     }
     ```  


通过以上梳理，可系统掌握结构体、联合体的核心用法，以及延伸的工程实践技巧。