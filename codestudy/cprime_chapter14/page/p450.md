### 一、14.6 指向结构的指针 核心知识总结  
#### 14.6.1 声明和初始化结构指针  
- **声明**：`struct 结构体名 *指针名;`（如 `struct guy *him;`），仅定义指针，未关联实际结构。  
- **初始化规则**：  
  - **单个结构体**：需用 `&` 取地址（如 `him = &barney;`，因结构体名≠地址）。  
  - **结构体数组元素**：  
    - `him = &fellows[0];`（直接取数组元素地址）；  
    - `him = fellows;`（数组名是首元素地址，等价于 `&fellows[0]`）。  
- **内存特性**：  
  - 结构体大小可能 **大于成员大小之和**（编译器为“内存对齐”插入填充字节，如 `float` 地址需是4的倍数）。  
  - 指针自增（`him++`）时，偏移量为 **整个结构体的实际大小**（含填充）。  


#### 14.6.2 用指针访问结构成员  
- **两种方式**：  
  | 语法          | 等价写法          | 原理                     | 易错点                  |  
  |---------------|-------------------|--------------------------|-------------------------|  
  | `him->income` | `(*him).income`   | 解引用指针后访问成员     | 无（推荐，简洁）        |  
  | `(*him).income` | `him->income`   | 显式解引用，强调指针逻辑 | 忘记括号：`*him.income`（错误，因 `.` 优先级高于 `*`，会被解析为 `*(him.income)`，而 `him.income` 是 `float`，非指针） |  




### 二、知识逻辑链：从“声明”到“访问”的递进关系  
```mermaid
graph LR
    A[声明结构指针] --> B[语法：struct guy *him;（存地址，未指向有效结构）]
    B --> C[初始化：关联实际结构]
    C --> D[单个结构：him = &barney;（用&取地址）]
    C --> E[数组元素：him = fellows;（数组名是首地址）]
    E --> F[指针自增：him++（偏移=结构体实际大小，含填充）]
    F --> G[访问成员]
    G --> H[方式1：him->income（简洁，避优先级问题）]
    G --> I[方式2：(*him).income（显式解引用，需括号）]
```  




### 三、完整示例代码（覆盖声明、初始化、访问、内存验证）  
```c
#include <stdio.h>
#define LEN 20

// 定义嵌套结构（模拟教材示例）
struct names {
    char first[LEN]; // 20字节
    char last[LEN];  // 20字节
};
struct guy {
    struct names handle; // 嵌套结构，占40字节（假设无填充）
    char favfood[LEN];   // 20字节
    char job[LEN];       // 20字节
    float income;        // 4字节（假设系统float占4字节）
};

int main() {
    // 1. 定义结构体数组并初始化（2个元素）
    struct guy fellows[2] = {
        {{"Ewen", "Villard"}, "grilled salmon", "coach", 68112.0},
        {{"Rodney", "Swillbelly"}, "tripe", "editor", 32000.0}
    };

    // 2. 声明并初始化结构指针（指向数组首元素）
    struct guy *him = fellows; // 等价于 &fellows[0]

    // 3. 演示指针访问成员（两种方式对比）
    printf("=== 方式1：-> 访问 ===\n");
    printf("姓名：%s %s，收入：%.2f\n", 
           him->handle.first, him->handle.last, him->income);

    printf("\n=== 方式2：(*him). 访问 ===\n");
    printf("姓名：%s %s，收入：%.2f\n", 
           (*him).handle.first, (*him).handle.last, (*him).income);

    // 4. 验证指针自增：偏移量=结构体实际大小
    printf("\n=== 指针地址变化（验证内存布局）===\n");
    printf("him初始地址：%p\n", him);      // 指向fellows[0]
    him++;                               // 移动到fellows[1]
    printf("him自增后地址：%p\n", him);  // 地址差=sizeof(struct guy)
    printf("fellows[1]地址：%p\n", &fellows[1]); // 对比验证

    // 5. 优先级陷阱演示（故意写错误语法，观察编译器报错）
    // printf("%f\n", *him.income); // 错误！等价于*(him.income)，但him.income是float，非指针
    // 正确写法：(*him).income 或 him->income

    return 0;
}
```  
**代码说明**：  
- **初始化验证**：`him = fellows` 利用“数组名是首地址”的特性，直接指向数组首元素。  
- **地址对比**：打印 `him` 自增前后的地址，与 `&fellows[1]` 对比，验证偏移量为 `sizeof(struct guy)`（可通过 `sizeof` 计算实际大小，观察是否含填充）。  
- **错误演示**：注释的 `*him.income` 会触发编译错误，凸显 `.` 的高优先级，强调括号的必要性。  




### 四、对比表格（关键概念辨析）  
#### 对比1：结构指针的初始化方式  
| 目标对象       | 初始化代码          | 原理说明                     |  
|----------------|---------------------|------------------------------|  
| 单个结构体     | `him = &barney;`    | 结构体名≠地址，需用`&`取地址 |  
| 结构体数组元素 | `him = fellows;`    | 数组名是首元素地址           |  


#### 对比2：`->` 和 `(*p).` 的差异  
| 维度         | `->`                  | `(*p).`                |  
|--------------|-----------------------|-----------------------|  
| 语法简洁性   | 更简洁，无括号        | 需括号，略显繁琐      |  
| 优先级处理   | 天然避免`.`的优先级问题 | 必须加括号，否则错误  |  
| 语义表达     | 隐式解引用，侧重结果  | 显式解引用，侧重过程  |  


#### 对比3：结构指针 vs 普通指针（如 `int *p`）  
| 特性         | 结构指针（`struct guy *him`） | 普通指针（`int *p`）      |  
|--------------|------------------------------|--------------------------|  
| 指向内容     | 整个结构体（含多成员）       | 单个`int`变量            |  
| 自增偏移量   | `sizeof(struct guy)`（含填充）| `sizeof(int)`（4/8字节） |  
| 成员访问     | 需`->`或`(*him).`            | 直接解引用（`*p`）       |  




### 五、扩展知识点（深入理解内存对齐）  
#### 1. 为什么会有“填充字节”？  
- **规则**：编译器要求 **成员地址是其类型大小的整数倍**（如 `float` 占4字节，地址需是4的倍数）。  
- **影响**：若成员间地址不满足对齐，编译器会插入**填充字节**，导致结构体实际大小 **大于成员大小之和**（如示例中理论84字节，实际可能因填充变为92字节）。  

#### 2. 如何查看结构的实际大小？  
```c
printf("struct guy 实际大小：%zu 字节\n", sizeof(struct guy));
```  
运行后可观察是否包含填充（对比理论值和实际值）。  

#### 3. 内存对齐对指针的影响  
- `him++` 会跳过 **整个结构体的实际大小**（含填充），而非成员的逻辑总和。  
- 手动计算偏移（如 `him = (struct guy*)((char*)him + 84);`）可能破坏对齐，导致性能下降或运行时错误。  




### 总结：掌握结构指针的三个核心维度  
1. **语法维度**：熟练使用 `->` 和 `(*p).`，规避优先级陷阱（牢记 `.` 比 `*` 优先级高）。  
2. **内存维度**：理解内存对齐的存在（填充字节），以及指针自增的实际偏移逻辑。  
3. **应用维度**：结合数组、函数传参（后续14.7节），体会指针在高效操控复杂结构中的优势。  

通过“语法实践→内存探究→扩展应用”的路径，逐步突破结构指针的学习难点，为链表、树等复杂数据结构奠定基础！