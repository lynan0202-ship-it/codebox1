

### 一、14.6 指向结构的指针 核心知识总结  
#### 1. 核心概念  
- **结构体指针定义**：`struct 结构体名 *指针变量;`（如 `struct guy *him;`），存储**结构体变量的地址**。  
- **成员访问语法**：  
  - 方式1（简洁）：`指针->成员名`（如 `him->income`，等价于 `(*him).income`）。  
  - 方式2（底层逻辑）：`(*指针).成员名`（需加括号，因为`.`优先级高于`*`）。  
- **指针遍历结构体数组**：利用指针自增（`him++`），每次移动**一个结构体的字节长度**，高效遍历连续存储的结构体数组。  

#### 2. 为什么用结构体指针？（4大理由）  
| 理由序号 | 核心逻辑                                                                 |  
|----------|--------------------------------------------------------------------------|  
| 1        | **操控更高效**：指针操作比直接访问结构体更灵活（类似数组指针操控数组）。  |  
| 2        | **历史兼容性**：早期C语言中，结构体不能直接传参，必须通过指针间接传递。  |  
| 3        | **传参更高效**：传递指针（4/8字节）比拷贝整个结构体（可能很大）更快。    |  
| 4        | **嵌套指针支持**：复杂结构体中常包含其他结构体的指针，需用指针链式访问。  |  


### 二、知识逻辑链：从“为什么”到“怎么用”  
```mermaid
graph LR
    A[为什么用结构体指针?] --> B[4大核心理由（高效、历史、传参、嵌套）]
    B --> C[怎么声明?] --> D[struct guy *him;（指向guy结构体的指针）]
    D --> E[怎么访问成员?] 
    E --> F[him->income（推荐，简洁）]
    E --> G[(*him).income（底层逻辑，需括号）]
    D --> H[怎么遍历数组?] --> I[him = &fellow[0]; 循环中him++（移动结构体长度）]
    I --> J[结合->访问成员，批量处理数据]
```  


### 三、极简示例代码（突出指针核心用法）  
```c
#include <stdio.h>
#define LEN 20

// 定义基础姓名结构
struct names {
    char first[LEN];
    char last[LEN];
};

// 定义嵌套的guy结构（同教材）
struct guy {
    struct names handle;
    char favfood[LEN];
    char job[LEN];
    float income;
};

int main() {
    // 1. 定义结构体数组并初始化（2个guy）
    struct guy fellows[2] = {
        {{"Ewen", "Villard"}, "grilled salmon", "coach", 68112.0},
        {{"Rodney", "Swillbelly"}, "tripe", "editor", 32000.0}
    };

    // 2. 定义结构体指针，指向数组首元素
    struct guy *him = fellows;  // 等价于 &fellows[0]，数组名是首元素地址

    // 3. 遍历数组（通过指针自增）
    for (int i = 0; i < 2; i++, him++) {  // him++ 移动到下一个guy结构体
        printf("=== 第%d个人信息 ===\n", i+1);
        // 两种访问方式对比：-> 和 (*him). 
        printf("姓名：%s %s\n", him->handle.first, (*him).handle.last); 
        printf("职业：%s\n", him->job);
        printf("收入：%.2f\n", him->income);
    }

    return 0;
}
```  
**代码说明**：  
- **指针初始化**：`him = fellows` 直接让指针指向数组首元素（数组名是首地址）。  
- **遍历逻辑**：`him++` 自动跳过一个`struct guy`的长度（无需手动计算偏移）。  
- **访问对比**：`him->job` 和 `(*him).job` 效果相同，但`->`更简洁（避免括号和星号的繁琐）。  


### 四、对比表格（易混点辨析）  
#### 对比1：结构体指针的两种成员访问方式  
| 语法形式       | 等价写法          | 优点                  | 易错点提醒                     |  
|----------------|-------------------|-----------------------|--------------------------------|  
| `him->income`  | `(*him).income`   | 代码简洁，可读性高    | 无（推荐使用）                 |  
| `(*him).income`| `him->income`     | 体现底层解引用逻辑    | 忘记加括号：`*him.income`（错误，因为`.`优先级更高，会被解析为 `*(him.income)`，导致语法错误） |  


#### 对比2：结构体指针 vs 直接访问结构体  
| 操作场景       | 结构体指针（`him`）                     | 直接访问（`fellows[0]`）           |  
|----------------|-----------------------------------------|------------------------------------|  
| 传参效率       | 传递指针（4/8字节），高效               | 拷贝整个结构体（可能占几十/几百字节），低效 |  
| 遍历数组       | `him++` 自动移动，代码简洁              | 需手动`fellows[i]`，索引管理繁琐    |  
| 成员访问       | 必须用`->`或`(*him).`                  | 直接用`.`（如`fellows[0].income`） |  


### 五、扩展知识点（进阶延伸）  
#### 1. **结构体指针作为函数参数**（修改原结构体）  
```c
// 函数：修改结构体的收入（通过指针传参，直接修改原数据）
void raise_salary(struct guy *person, float rate) {
    person->income *= (1 + rate);  // 等价于 (*person).income *= ...
}

// 调用示例：
raise_salary(&fellows[1], 0.1);  // 给第2个人涨10%工资
```  


#### 2. **const修饰的结构体指针**（保护数据不被修改）  
```c
// 只读指针：可访问成员，但不能修改结构体内容
void print_info(const struct guy *person) {
    printf("%s %s\n", person->handle.first, person->handle.last); 
    // person->income = 0;  // 编译报错：只读指针无法修改数据
}
```  


#### 3. **动态分配结构体（malloc）**  
```c
#include <stdlib.h>
struct guy *create_guy() {
    struct guy *p = malloc(sizeof(struct guy)); // 动态分配内存
    if (p != NULL) {
        // 初始化成员（示例）
        strcpy(p->handle.first, "Alice");
        p->income = 50000.0;
    }
    return p;
}

// 调用后记得释放：free(p);
```  


#### 4. **指向嵌套结构体的指针（复杂场景）**  
如果`handle`本身是**指针**（而非结构体），则访问需双重指针：  
```c
struct guy {
    struct names *handle;  // handle是指针，指向names结构体
    // ...其他成员
};

struct names alice = {"Alice", "Smith"};
struct guy bob = {&alice, "pizza", "engineer", 80000.0};

// 访问：先解引用handle指针，再访问first
printf("%s\n", bob.handle->first);  // 等价于 (*bob.handle).first
```  




### 总结：结构体指针的学习路径  
1. **理解本质**：结构体指针存储的是**结构体变量的地址**，而非结构体本身。  
2. **掌握语法**：牢记 `->` 的用法（替代 `(*p).`），避免优先级陷阱。  
3. **实践遍历**：用指针遍历结构体数组，体会`him++`的自动偏移优势。  
4. **进阶扩展**：结合函数传参、动态分配、const修饰，深化对指针和结构体的协同使用。  

通过“语法→对比→实践→扩展”的步骤，逐步掌握结构体指针的核心用法，解决实际开发中**高效操控复杂数据结构**的问题！