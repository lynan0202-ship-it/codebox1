### 一、14.4 结构数组核心知识总结  
#### 1. 结构数组的声明  
- **语法**：`struct 结构体名 数组名[元素数量];`  
  例：`struct book library[100];` → 创建含100个`book`结构体的数组，每个元素（如`library[0]`）是完整的`book`结构。  
- **本质**：数组的**元素类型为结构体**，类比普通数组（如`int arr[10]`的元素是`int`，结构数组的元素是自定义结构体）。  


#### 2. 结构数组成员的访问  
- **语法**：`数组名[下标].成员名`（先下标定位元素，再点运算符访问成员）。  
  - 正确：`library[2].title`（第3本图书的标题）、`library[0].value`（第1本图书的价格）。  
  - 错误：`library.title[2]`（下标应跟在**数组名**后，而非**成员名**后，逻辑上混淆了“数组”和“结构体”的层级）。  


#### 3. 程序设计核心逻辑（以`manybook.c`为例）  
- **输入阶段**：  
  - 用`while`循环持续接收输入，终止条件：`count < 最大数量` **且** `书名非空`（通过`library[count].title[0] != '\0'`判断）。  
  - 自定义函数`s_gets`封装`fgets`，解决两个问题：  
    - 替换输入中的换行符为`\0`（避免字符串带换行）；  
    - 清理超长输入的残留字符（防止干扰后续输入）。  
  - `scanf`读取价格后，用`getchar()`清理残留换行符（否则会被后续`s_gets`误读为“空行”）。  

- **输出阶段**：  
  - 遍历结构数组（`for (index = 0; index < count; index++)`），通过`library[index].title`等语法访问成员，格式化输出。  




### 二、知识逻辑链梳理（声明→访问→程序实现）  
```mermaid
graph TD
    A[结构数组声明] --> B[类比普通数组，元素是结构体]
    B --> C[例：struct book library[100];]
    C --> D[结构数组成员访问]
    D --> E[数组下标定位元素 → 点运算符访问成员]
    E --> F[正确：library[0].title]
    E --> G[错误：library.title[0]（混淆层级）]
    F --> H[程序设计]
    H --> I[输入：循环+自定义s_gets+清理缓冲区]
    H --> J[输出：遍历数组+格式化输出成员]
```  




### 三、极简示例代码（突出结构数组核心用法）  
```c
#include <stdio.h>
#define MAX_BOOKS 2  // 演示2本图书

// 定义图书结构体
struct Book {
    char title[50];  // 书名
    char author[30]; // 作者
    float price;     // 价格
};

int main() {
    // 1. 声明结构数组：存储MAX_BOOKS本图书
    struct Book books[MAX_BOOKS];
    
    // 2. 输入数据（循环填充结构数组）
    for (int i = 0; i < MAX_BOOKS; i++) {
        printf("第%d本书标题：", i+1);
        // 简化示例：实际建议用s_gets处理带空格的输入
        scanf("%s", books[i].title);  
        
        printf("第%d本书作者：", i+1);
        scanf("%s", books[i].author);  
        
        printf("第%d本书价格：", i+1);
        scanf("%f", &books[i].price);  
    }
    
    // 3. 输出数据（遍历结构数组）
    printf("\n=== 图书清单 ===\n");
    for (int i = 0; i < MAX_BOOKS; i++) {
        printf("《%s》 作者：%s  价格：%.2f\n", 
               books[i].title,   // 访问标题
               books[i].author,  // 访问作者
               books[i].price);  // 访问价格
    }
    
    return 0;
}
```  
**代码说明**：  
- 声明`struct Book books[2]`：创建含2个`Book`结构的数组。  
- 访问成员：通过`books[i].title`（数组下标`i` + 点运算符 + 成员名`title`）实现。  
- 扩展建议：若需支持**带空格的书名/作者**（如“The C Book”），需将`scanf`替换为教材中的`s_gets`函数。  




### 四、对比表格（易混点辨析）  
#### 对比1：结构数组成员访问的正确 vs 错误  
| 操作目的          | 正确写法               | 错误写法               | 错误原因                     |  
|-------------------|------------------------|------------------------|------------------------------|  
| 访问第3本书的标题 | `library[2].title`     | `library.title[2]`     | 下标应跟在**数组名**后，而非**成员名**后 |  
| 访问第1本书的价格 | `library[0].value`     | `library.value[0]`     | 混淆“数组下标”和“成员层级”   |  


#### 对比2：结构数组与普通数组的差异  
| 维度          | 普通数组（如`int arr[5]`） | 结构数组（如`struct Book lib[5]`） |  
|---------------|---------------------------|-------------------------------------|  
| 元素类型      | 基本类型（`int`）         | 结构体（含多个成员，如`title`/`author`） |  
| 访问方式      | 直接下标（`arr[0]`）      | 下标 + 点运算符（`lib[0].title`）   |  
| 存储特点      | 连续存储同类型数据        | 连续存储结构体（每个元素含多字段）  |  




### 五、扩展知识点（进阶延伸）  
#### 1. 结构数组的初始化  
声明时直接赋值，例：  
```c
struct Book books[2] = {
    {"C Primer", "Steve", 99.9},  // 第1本：按成员顺序赋值
    {"Python Crash", "Eric", 89.5} // 第2本
};
```  


#### 2. 动态结构数组（ malloc 分配）  
若图书数量不确定，可动态分配内存：  
```c
#include <stdlib.h> // 需引入头文件
struct Book *books = malloc(MAX_BOOKS * sizeof(struct Book));
// 使用后释放内存：free(books);
```  


#### 3. 结构数组的指针访问（进阶）  
结构数组名是**指针**（指向第一个元素），可通过指针遍历：  
```c
struct Book *p = library; // p指向library[0]
while (p < library + MAXBKS) {
    printf("%s by %s\n", p->title, p->author); // 用->访问成员（等价于(*p).title）
    p++; // 指针移动到下一个结构体
}
```  




### 总结：从概念到实践的学习路径  
1. **理解本质**：结构数组是“数组 + 结构体”的复合类型，元素是完整的结构体。  
2. **掌握访问**：牢记 `数组名[下标].成员名` 的语法，避免混淆下标和成员的位置。  
3. **编程实践**：通过循环处理多元素输入输出，学会用`s_gets`和`getchar()`处理输入缓冲区问题。  
4. **进阶扩展**：尝试动态分配、指针遍历，加深对内存和结构体的理解。  

通过“概念→语法→代码→对比→扩展”的步骤，逐步构建结构数组的知识体系！