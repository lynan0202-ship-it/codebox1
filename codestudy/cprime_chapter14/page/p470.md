### 一、14.8.2 核心知识要点总结  
1. **文件打开模式**：  
   - 使用 `a+b` 模式：`a` 实现“追加读写”（读时需手动定位到开头，写时自动到末尾），`b` 标识二进制格式（UNIX 系统可省略，因本身是二进制文件模型）。  
2. **二进制 IO 函数**：  
   - `rewind(pfile)`：将文件指针重置到开头，为读取已有数据做准备。  
   - `fread(&data, size, 1, pfile)` / `fwrite(&data, size, 1, pfile)`：按 `size`（如 `sizeof(struct)`）批量读写数据，一次处理一个结构体。  
3. **程序流程设计**：  
   - **读阶段**：循环读取文件中已有结构体到数组，记录数量 `filecount`。  
   - **写阶段**：接收用户输入填充数组，再将新增部分（`count - filecount` 个）写入文件（利用 `a+b` 追加特性）。  
4. **存储方案特点**：  
   - **优点**：按固定大小读写，检索高效（直接定位 `n*sizeof(struct)` 位置）。  
   - **缺点**：浪费空间（如字符数组未填满，空字符仍占内存/磁盘）。    


### 二、段落逻辑梳理（按“因果→步骤”拆解）  
1. **为什么选二进制模式？**  
   → 因为 `fread()`/`fwrite()` 依赖二进制操作（文本模式会因换行符转换等破坏数据）。  
2. **`rewind()` 的作用？**  
   → `a+b` 模式下，文件默认打开时指针在末尾，需用 `rewind` 回到开头，才能读取**已有内容**。  
3. **两个 `while` 循环的分工：**  
   - 第一个 `while`：从文件读结构体到数组，同时统计 `filecount`（已有数据量）。  
   - 第二个 `while`：接收用户输入，填充数组（从 `filecount` 位置开始，避免覆盖已有数据）。  
4. **`fwrite` 为什么只写“新增部分”？**  
   → 因为文件以 `a+b` 打开，新数据需**追加到末尾**，而非覆盖，故遍历 `[filecount, count)` 区间写入。    


### 三、核心代码举例（简化版，突出二进制读写）  
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // 用于 strcpy

#define MAX_BKS 5  // 简化容量，方便测试
struct Book {
    char title[20];  // 书名
    float price;     // 价格
};

int main() {
    struct Book library[MAX_BKS];  // 存储书籍的结构体数组
    int count = 0, filecount = 0;  // count: 总数据量；filecount: 文件原有数据量
    FILE *fp = fopen("test.dat", "a+b");  // 二进制追加+读写模式
    
    if (!fp) {  // 文件打开失败
        fprintf(stderr, "无法打开文件！\n");
        exit(1);
    }

    // 1. 读取文件中已有的数据（必须先重置指针到开头）
    rewind(fp);  // 定位到文件起始位置
    while (count < MAX_BKS &&  // 数组未满，且读取成功
           fread(&library[count], sizeof(struct Book), 1, fp) == 1) {
        printf("已读数据：%s | 价格：%.2f\n", library[count].title, library[count].price);
        count++;  // 计数+1
    }
    filecount = count;  // 记录文件原有数据的数量

    // 2. 写入新数据（如果数组还有空间）
    if (count < MAX_BKS) {
        // 模拟用户输入（实际可替换为 scanf/s_gets 交互）
        strcpy(library[count].title, "C Primer");  // 设置书名
        library[count].price = 99.9;               // 设置价格
        count++;  // 新数据计数+1

        // 仅将“新增部分”写入文件（从 filecount 到 count-1）
        fwrite(&library[filecount], sizeof(struct Book), 1, fp);
        printf("新数据已写入文件！\n");
    }

    fclose(fp);  // 关闭文件
    return 0;
}
```  
**关键说明**：  
- `sizeof(struct Book)` 自动计算结构体大小，避免硬编码错误。  
- `fread` 返回值为“成功读取的块数”，等于 `1` 时表示读取到一个完整结构体。  
- `a+b` 模式下，`fwrite` 会自动定位到文件末尾，直接追加新数据，无需手动调整指针。  


### 四、对比表格：二进制存储 vs 文本存储（Markdown）  
| **维度**       | 二进制存储（如 `fread/fwrite`）       | 文本存储（如 `fprintf/fscanf`）       |
|----------------|--------------------------------------|---------------------------------------|
| **读写方式**   | 按固定大小（`sizeof`）批量读写        | 按格式化字符串逐字段解析              |
| **可读性**     | 不可读（需程序解析）                 | 人类可读（如文本编辑器直接打开）      |
| **效率**       | 高（一次 IO 操作处理整个结构体）      | 低（逐字段解析，涉及字符串转换）      |
| **空间占用**   | 紧凑（无格式字符，如 `\n` `\t`）     | 冗余（含分隔符、换行符等）            |
| **适用场景**   | 程序内部数据持久化（如配置、缓存）   | 日志、配置文件（需人工修改场景）      |  


### 五、扩展知识点补充  
1. **跨平台问题**：  
   - 二进制文件受 **字节序**（如 x86 小端、ARM 大端）和 **结构体对齐** 影响，跨平台读写需统一格式（如显式序列化/反序列化，将数据转为网络字节序或固定格式）。  
2. **动态存储优化**：  
   - 若嫌固定数组浪费空间，可结合 **链表 + 动态分配**（如 `struct Book *books = malloc(n * sizeof(struct Book))`），或设计“变长记录”格式（前4字节存数据长度，再存实际内容）。  
3. **文件指针高级操作**：  
   - `fseek(fp, offset, origin)`：灵活定位（如 `fseek(fp, -sizeof(struct Book), SEEK_END)` 跳转到最后一个结构体）。  
   - `ftell(fp)`：获取当前文件指针位置，直接计算已有数据量（替代 `rewind + 循环计数`，更高效）。  
4. **调试工具**：  
   - Linux 下用 `hexdump -C test.dat`，Windows 用二进制编辑器，查看文件原始内容，验证读写是否正确（如结构体字段是否按字节对齐存储）。  


通过以上拆解，可帮初学者从 **程序流程→技术细节→对比扩展** 全面理解 **结构体二进制文件存储** 的设计思路和实现要点，同时规避跨平台、空间浪费等潜在问题。