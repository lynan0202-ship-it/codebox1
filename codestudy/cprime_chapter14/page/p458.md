### 一、主题总结：结构与结构指针的选择  
**核心知识要点**：  
1. **两种传递方式**：  
   - **结构指针（传址）**：函数参数为`struct *`，传递结构体地址。  
   - **结构本身（传值）**：函数参数/返回值为`struct`，传递结构体副本。  
2. **优缺点对比**：  
   - 传址：效率高（仅传地址），但需用`const`防止意外修改原数据；  
   - 传值：天然保护原数据（操作副本），代码更直观，但拷贝大结构时耗时耗内存。  
3. **适用场景**：  
   - 优先用 **指针+`const`** 平衡效率与安全；  
   - 小结构（如坐标、颜色）或需链式调用时，传值更便捷。  


### 二、内容逻辑梳理（因果/递进关系）  
1. **传址的优势** → 为什么用指针？  
   - 兼容性好（新旧C标准支持），执行快（只需传递地址，无需拷贝数据）。  
   - 缺点：若函数内部修改指针指向的结构，会直接影响原数据（需`const`约束只读）。  
2. **传值的优势** → 为什么用结构本身？  
   - 函数操作**副本**，原数据绝对安全；代码更直观（像普通变量赋值）。  
   - 缺点：旧编译器可能不支持结构返回，且大结构拷贝时性能差。  
3. **取舍逻辑**：  
   - 小结构（如`vector`）→ 传值更简洁；  
   - 大结构/频繁操作 → 传指针+`const`更高效；  
   - 需保护原数据 → 传值或`const`指针。  


### 三、编程知识点：传值 vs 传址 代码示例  
#### 场景：计算二维向量和（`struct vector`）  

##### 1. 传值版本（参数+返回值均为结构）  
```c
struct vector { double x; double y; };

// 函数：接收两个向量（传值），返回它们的和（传值）
struct vector sum_vect(struct vector a, struct vector b) {
    struct vector res;
    res.x = a.x + b.x;
    res.y = a.y + b.y;
    return res; // 返回整个结构（拷贝到调用处）
}

int main() {
    struct vector a = {1.2, 3.4};
    struct vector b = {5.6, 7.8};
    struct vector ans = sum_vect(a, b); // 直接传结构，像普通变量运算
    printf("Sum: (%.1f, %.1f)\n", ans.x, ans.y);
    return 0;
}
```  
**说明**：  
- 调用直观（`sum_vect(a, b)` 像数学运算），但每次调用会拷贝`a`、`b`和返回值`res`。  


##### 2. 传址版本（指针参数，配合`const`保护输入）  
```c
struct vector { double x; double y; };

// 函数：接收两个输入向量（const指针，只读），结果存入res指针
void sum_vect(const struct vector *a, const struct vector *b, struct vector *res) {
    res->x = a->x + b->x; // 通过指针访问成员（->）
    res->y = a->y + b->y;
}

int main() {
    struct vector a = {1.2, 3.4};
    struct vector b = {5.6, 7.8};
    struct vector ans;
    sum_vect(&a, &b, &ans); // 传递地址（&），注意参数顺序
    printf("Sum: (%.1f, %.1f)\n", ans.x, ans.y);
    return 0;
}
```  
**说明**：  
- 仅传地址，效率高；`const`保证`a`、`b`不会被修改；  
- 需注意指针参数的顺序（结果指针放最后），否则易混淆。  


### 四、对比表格（传值 vs 传址）  
| **对比维度**       | 结构传值（参数/返回值）                     | 结构指针（传址）                     |
|--------------------|--------------------------------------------|--------------------------------------|
| **数据安全**       | 操作副本，原数据天然安全                   | 需`const`修饰才能只读，否则可修改    |
| **执行效率**       | 拷贝整个结构，小结构影响小，大结构开销大   | 仅传地址，效率高                     |
| **代码直观性**     | 调用像普通变量（`a + b`），更自然          | 需指针语法（`->`、`&`），稍复杂      |
| **兼容性**         | 旧编译器可能不支持结构返回（C99后完善）    | 全版本C标准支持                      |
| **内存占用**       | 传参和返回时拷贝结构，占额外内存           | 仅传地址，内存开销小                 |  


### 五、扩展知识点（延伸学习）  
1. **`const`的深层作用**：  
   - 除了保护原数据，还能让函数接口更清晰（表明“只读”），编译器会检查违规修改。  
2. **结构嵌套与深拷贝**：  
   - 若结构包含**指针成员**（如`char *name`），传值会导致**浅拷贝**（指针指向同一块内存，释放时出错），此时必须传指针并手动深拷贝。  
3. **编译器优化**：  
   - 现代编译器对**小结构传值**做优化（如用寄存器传递，避免实际拷贝），性能接近传址。  
4. **返回值优化（RVO）**：  
   - 编译器可优化结构返回的拷贝开销（如直接在调用处构造返回值，而非临时变量）。  


通过以上对比，可清晰判断：**小结构优先传值，大结构/需频繁操作时传指针+`const`**，结合场景选择更高效的实现！