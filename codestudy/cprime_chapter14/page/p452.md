### 一、示例1：传递结构成员（funds1.c）
```c
/*
代码名称：funds1.c（向函数传递结构成员）
知识要点总结：
1. 结构成员可直接作为参数（如 double 类型的 bankfund）
2. 函数只需处理基本类型（sum 接收两个 double）
3. 传递的是“成员的值”，函数内修改不影响原结构

代码总体逻辑：
① 定义结构体 funds，包含银行和储蓄账户信息
② 初始化结构体变量 stan 
③ 调用 sum 函数，传入 stan 的 bankfund 和 savefund（两个 double 值）
④ sum 计算两者之和，主函数格式化输出结果
*/

#include <stdio.h>
#define FUNDLEN 50  // 账户名称最大长度

// 定义资金结构体：银行账户 + 储蓄账户
struct funds {
    char bank[FUNDLEN];   // 银行名称（字符数组）
    double bankfund;      // 银行账户余额（double 类型，可直接传参）
    char save[FUNDLEN];   // 储蓄机构名称（字符数组）
    double savefund;      // 储蓄账户余额（double 类型，可直接传参）
};

// 函数声明：计算两个 double 数的和（参数是结构成员的值）
double sum(double x, double y);

int main(void) {
    // 初始化结构体：按成员顺序赋值
    struct funds stan = {
        "Garlic-Melon Bank",        // bank 成员
        4032.27,                    // bankfund 成员
        "Lucky's Savings and Loan", // save 成员
        8543.94                     // savefund 成员
    };

    // 传递结构成员的值 → sum 只关心 double 类型，不关心来源
    printf("Stan has a total of $%.2f.\n", 
           sum(stan.bankfund, stan.savefund));

    return 0;
}

// 简单加法函数：处理两个 double 值（与结构无关，通用性强）
double sum(double x, double y) {
    return x + y;
}

/*
测试及验证建议方案：
1. 基础验证：运行程序，检查输出是否为 4032.27 + 8543.94 = 12576.21
2. 类型错误测试：尝试传 stan.bank（字符数组）给 sum，观察编译器报错（提示类型不匹配）
3. 函数副作用测试：在 sum 里修改 x 的值（如 x=0;），看主函数的 stan.bankfund 是否变化（验证“值传递”不影响原数据）
4. 边界测试：将 bankfund 改为 0，检查输出是否为 savefund 的值
*/


### 二、示例2：传递结构地址（funds2.c）
```c
/*
代码名称：funds2.c（向函数传递结构的地址）
知识要点总结：
1. 结构指针作为参数：传递地址，避免拷贝大结构体
2. const 修饰指针：保证函数内“只读”，不修改原结构
3. 成员访问：通过 `->` 运算符（指针->成员）访问结构成员

代码总体逻辑：
① 定义同构结构体 funds 
② 初始化 stan，调用 sum 时传递 `&stan`（结构的地址）
③ sum 函数通过指针访问成员（money->bankfund），计算总和
④ 地址传递效率高，const 防止意外修改原结构
*/

#include <stdio.h>
#define FUNDLEN 50

struct funds {
    char bank[FUNDLEN];
    double bankfund;
    char save[FUNDLEN];
    double savefund;
};

// 函数声明：参数是结构指针（const 修饰，确保“只读”）
double sum(const struct funds *money);

int main(void) {
    struct funds stan = {
        "Garlic-Melon Bank", 
        4032.27, 
        "Lucky's Savings and Loan", 
        8543.94 
    };

    // 传递结构的地址（&stan），sum 通过指针访问成员
    printf("Stan has a total of $%.2f.\n", sum(&stan));

    return 0;
}

// 指针访问成员：`money->bankfund` 等价于 `(*money).bankfund`
// const 修饰：禁止修改 *money 的内容（如 money->bankfund = 0; 会编译报错）
double sum(const struct funds *money) {
    return money->bankfund + money->savefund;
}

/*
测试及验证建议方案：
1. 地址验证：在 sum 里打印 `money` 的地址（%p），与主函数的 `&stan` 对比，确认一致
2. const 测试：尝试在 sum 里修改 `money->bankfund = 0;`，观察编译器是否报错（const 保护）
3. 指针语法对比：改写为 `(*money).bankfund + (*money).savefund`，验证与 `->` 效果一致
4. 空指针测试：故意传 NULL 给 sum，运行看是否崩溃（理解指针必须指向有效结构）
5. 效率对比：定义一个超大结构体（如含 1000 个 double），分别用“值传递”和“地址传递”测运行时间（体会地址传递的高效）
*/


### 三、示例3：传递结构本身（funds3.c）
```c
/*
代码名称：funds3.c（向函数传递结构本身）
知识要点总结：
1. 结构作为参数：函数内会**拷贝**一份完整的结构体
2. 值传递特性：函数内修改“副本”，不会影响主函数的原结构
3. 访问方式：通过 `.` 运算符（结构变量.成员）访问

代码总体逻辑：
① 定义同构结构体 funds 
② 初始化 stan，调用 sum 时直接传 stan（值传递，拷贝整个结构）
③ sum 函数内的 moolah 是 stan 的副本，计算副本的成员和
④ 由于是拷贝，原结构 stan 不会被函数修改
*/

#include <stdio.h>
#define FUNDLEN 50

struct funds {
    char bank[FUNDLEN];
    double bankfund;
    char save[FUNDLEN];
    double savefund;
};

// 函数声明：参数是结构体本身（值传递，会拷贝整个结构）
double sum(struct funds moolah);

int main(void) {
    struct funds stan = {
        "Garlic-Melon Bank", 
        4032.27, 
        "Lucky's Savings and Loan", 
        8543.94 
    };

    // 传递结构本身（stan），sum 内会创建 moolah 副本
    printf("Stan has a total of $%.2f.\n", sum(stan));

    return 0;
}

// 结构拷贝：moolah 是 stan 的完整副本（内存独立）
// 修改 moolah 的成员（如 moolah.bankfund = 0;）不会影响主函数的 stan
double sum(struct funds moolah) {
    return moolah.bankfund + moolah.savefund;
}

/*
测试及验证建议方案：
1. 拷贝验证：在 sum 里修改 `moolah.bankfund = 0;`，输出仍为 12576.21（原 stan 未变）
2. 内存地址测试：打印 `moolah` 和 `stan` 的地址（%p），确认不是同一地址（证明是拷贝）
3. 性能对比：和 funds2.c 对比运行时间，体会“值传递”在大结构时的低效
4. 初始化测试：故意注释 stan 的 savefund 初始化，看 sum 结果是否异常（验证拷贝是完整的）
5. 副作用测试：在 sum 里修改 moolah 的成员，主函数打印 stan 成员，确认无变化
*/


### 四、三种传递方式对比表（核心差异）
| 传递方式       | 参数类型               | 数据传递方式       | 能否修改原结构   | 效率（大结构时） | 访问语法       |
|----------------|------------------------|--------------------|------------------|------------------|----------------|
| 传递结构成员   | 基本类型（如 double）  | 值传递（成员的值） | 不能（值传递）   | 高（仅传单个值） | 直接用成员名   |
| 传递结构地址   | 结构指针（const 可选） | 地址传递（4/8字节）| 可修改（无 const）| 最高（仅传地址） | 指针->成员     |
| 传递结构本身   | 结构体本身             | 值传递（拷贝结构） | 不能（改副本）   | 低（拷贝整个结构）| 结构变量.成员 |

通过这三个示例，可清晰掌握 **向函数传递结构信息的三种方式**，以及它们的适用场景和优缺点！
```