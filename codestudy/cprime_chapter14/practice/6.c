// ------------------------------
// 题干：一个文本文件中保存着一个垒球队的信息。每行数据都是这样排列：
// 4 Jessie Joybat 5 2 1 1
// 第1项是球员号，为方便起见，其范围是0~18。第2项是球员的名。第3项是球员的姓。名和姓
// 都是一个单词。第4项是官方统计的球员上场次数。接着3项分别是击中数、走垒数和打点（RBI）。
// 文件可能包含多场比赛的数据，所以同一位球员可能有多行数据，而且同一位球员的多行数据之间
// 可能有其他球员的数据。编写一个程序，把数据储存到一个结构数组中。该结构中的成员要分别表
// 示球员的名、姓、上场次数、击中数、走垒数、打点和安打率（稍后计算）。可以使用球员号作为
// 数组的索引。该程序要读取文件中数据，并统计每位球员的各项累计和。
// 世界杯棒球统计与之相关。例如，一次走垒和触垒中的失误不计入上场次数，但是可能产生一个 RBI。
// 但是该程序要做的是像下面描述的一样读取和处理数据文件，不会关心数据的实际含义。
// 要实现这些功能，最简单的方法是把结构的内容都初始化为零，把文件中的数据读入临时变量中，
// 然后将其加入相应的结构中。程序读完文件后，应计算每位球员的安打率，把计算结果储存到结
// 构的相应成员中。计算安打率是用球员的累计击中数除以上场累计次数。这是一个浮点数计算。最
// 后，程序结合整个球队的统计数据，一行显示一位球员的累计数据。
// 知识要点：
//  1. 结构体的定义与使用 - 用于封装球员的多类信息
//  2. 数组的使用 - 以球员号为索引管理结构体数组
//  3. 文件操作 - 读取文本文件的行数据
//  4. 浮点数计算 - 实现安打率的除法运算（整数转浮点数）
//  5. 循环与条件判断 - 遍历文件和结构体数组进行数据累计与处理
// 总体逻辑：
//  1. 定义包含球员名、姓、各项统计及安打率的结构体
//  2. 初始化大小为19的结构体数组（对应球员号0~18），清空字符串、置零数值
//  3. 打开数据文件，逐行读取球员号、名、姓、上场次数、击中数、走垒数、打点
//  4. 根据球员号找到数组中对应结构体，累计数据（首次记录时设置姓名）
//  5. 关闭文件后，遍历数组计算每位球员的安打率（处理上场次数为0的情况）
//  6. 输出所有有记录球员的累计数据（名、姓、各项统计、安打率）
#include <stdio.h>
#include <string.h>

// 定义球员结构体，包含姓名、各项统计和安打率
typedef struct {
    char first_name[50];  // 球员名
    char last_name[50];   // 球员姓
    int games_played;     // 上场次数
    int hits;             // 击中数
    int walks;            // 走垒数
    int rbi;              // 打点
    float batting_average; // 安打率
} Player;

int main() {
    // 定义结构体数组，索引0~18对应球员号0~18
    Player team[19] = {0};
    // 初始化数组：字符串置空，数值置0
    for (int i = 0; i < 19; i++) {
        team[i].games_played = 0;
        team[i].hits = 0;
        team[i].walks = 0;
        team[i].rbi = 0;
        team[i].batting_average = 0.0;
        strcpy(team[i].first_name, "");
        strcpy(team[i].last_name, "");
    }

    // 打开数据文件（假设文件名为"players.txt"）
    FILE *file = fopen("players.txt", "r");
    if (file == NULL) { // 判断文件是否打开成功
        printf("无法打开文件！\n");
        return 1; // 文件打开失败，结束程序
    }

    // 临时变量，用于存储每行读取的数据
    int player_id, gp, h, w, r;
    char fn[50], ln[50];

    // 逐行读取文件数据，fscanf返回7表示成功读取7个数据项
    while (fscanf(file, "%d %s %s %d %d %d %d", &player_id, fn, ln, &gp, &h, &w, &r) == 7) {
        // 通过球员号找到数组中对应的结构体（指针指向该结构体）
        Player *p = &team[player_id];

        // 若该球员是首次记录（名字为空），则设置姓名
        if (strlen(p->first_name) == 0) {
            strcpy(p->first_name, fn);
            strcpy(p->last_name, ln);
        }

        // 累计各项数据
        p->games_played += gp;
        p->hits += h;
        p->walks += w;
        p->rbi += r;
    }

    // 关闭文件
    fclose(file);

    // 遍历数组，计算每位球员的安打率
    for (int i = 0; i < 19; i++) {
        Player *p = &team[i];
        // 上场次数>0时，用击中数/上场次数计算安打率（转浮点数避免整数除法）
        if (p->games_played > 0) {
            p->batting_average = (float)p->hits / p->games_played;
        } else {
            p->batting_average = 0.0; // 上场次数为0时，安打率为0
        }
    }

    // 输出每位球员的累计数据（只输出有姓名的球员，即有记录的）
    printf("球员名\t\t姓\t\t上场次数\t击中数\t走垒数\t打点\t安打率\n");
    for (int i = 0; i < 19; i++) {
        Player *p = &team[i];
        if (strlen(p->first_name) > 0) { // 名字非空，说明有记录
            printf("%s\t\t%s\t\t%d\t\t%d\t%d\t%d\t%.3f\n", 
                   p->first_name, p->last_name, p->games_played, p->hits, p->walks, p->rbi, p->batting_average);
        }
    }

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：①创建文本文件"players.txt"，写入测试数据（如：
//     4 Jessie Joybat 5 2 1 1
//     4 Jessie Joybat 3 1 0 2
//     0 Alex Smith 10 5 3 4
//     ）；②用gcc编译代码（gcc program.c -o program）；③运行可执行文件（./program）。
//  2. 预期结果：输出包含球员Jessie Joybat（上场8次、击中3次、安打率0.375）和Alex Smith（上场10次、击中5次、安打率0.5）等有数据球员的统计。
//  3. 检查点：核对每位球员的累计上场次数、击中数是否正确，安打率的小数计算是否准确（如3/8=0.375）。
// 易错点提醒：
//  1. 结构体数组的字符串成员未初始化，可能导致姓名显示混乱。
//  2. fscanf格式与数据不匹配（如数据列数错误），会导致读取失败或数据错位。
//  3. 计算安打率时忘记将整数转为浮点数，会得到错误的整数除法结果（如3/8得到0）。
//  4. 未判断上场次数是否为0，直接除法会导致“除以0”运行时错误。
// 拓展思考：
//  1. 若球员号范围不固定（非0~18），如何修改？可改用链表或动态数组（如malloc分配），用球员号作为标识查找。
//  2. 若要将结果写入新文件，如何实现？用fopen以"w"模式打开新文件，再用fprintf逐行写入球员数据。
//  3. 若需统计全队总数据（如总击中数、总上场次数），如何扩展？在结构体数组外定义全局变量，读取时同步累计。