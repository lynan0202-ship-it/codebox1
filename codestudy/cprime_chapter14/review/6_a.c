//### 6.a 部分代码

// ------------------------------
// 题干：a. 假设有下面的 typedef，声明一个内含 10 个指定结构的数组。然后，单独给成员赋值（或等价字符串），使第 3 个元素表示一个焦距长度有 500mm，孔径为 f/2.0 的 Remarkata 镜头。
// typedef struct lens { /* 描述镜头 */
//     float foclen; /* 焦距长度，单位为 mm */
//     float fstop; /* 孔径 */
//     char brand[30]; /* 品牌名称 */
// } LENS;
// 知识要点：
//  1. typedef 简化结构体类型声明 - 用 `LENS` 代替 `struct lens`，让类型名更简洁
//  2. 结构体数组的成员访问 - 通过数组下标（如 `lenses[2]`）访问结构体元素，再用 `.` 访问成员
//  3. 字符数组成员的赋值 - 必须用字符串函数（如 `strcpy`），不能直接用 `=` 给字符数组整体赋值
// 总体逻辑：
//  1. 定义 `LENS` 结构体类型，包含焦距、孔径、品牌三个成员
//  2. 声明包含 10 个 `LENS` 结构的数组 `lenses`
//  3. 对数组第 3 个元素（下标为 2）的 `foclen`、`fstop`、`brand` 成员分别赋值
//  4. 打印该元素的成员，验证赋值结果
#include <stdio.h>
#include <string.h> // 用于 `strcpy` 函数

typedef struct lens {
    float foclen;   // 焦距长度，单位：毫米
    float fstop;    // 孔径
    char brand[30]; // 品牌名称（字符数组，需存字符串结束符）
} LENS;

int main() {
    LENS lenses[10]; // 声明包含 10 个镜头结构的数组

    // 给第 3 个元素（下标 2）的成员单独赋值
    lenses[2].foclen = 500.0;          // 焦距设为 500mm
    lenses[2].fstop = 2.0;             // 孔径设为 f/2.0
    strcpy(lenses[2].brand, "Remarkata"); // 给品牌字符数组成员赋值

    // 打印第 3 个镜头的信息，验证赋值是否正确
    printf("第3个镜头：焦距=%.1f mm，孔径=f/%.1f，品牌=%s\n", 
           lenses[2].foclen, 
           lenses[2].fstop, 
           lenses[2].brand);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：将代码保存为 `a_part.c`，用 GCC 编译（如 `gcc a_part.c -o a_part`），然后运行 `./a_part`
//  2. 预期结果：输出 `第3个镜头：焦距=500.0 mm，孔径=f/2.0，品牌=Remarkata`
//  3. 检查点：核对焦距、孔径的数值和品牌字符串是否与赋值一致
// 易错点提醒：
//  1. 数组下标易数错 - 第 3 个元素的下标是 2（数组从 0 开始计数）
//  2. 字符数组赋值易错 - 必须用 `strcpy` 给字符数组成员赋值，不能直接写 `lenses[2].brand = "Remarkata";`
// 拓展思考：
//  1. 若要给多个数组元素赋值，如何更高效？可结合循环和条件判断，批量设置不同元素的成员
//  2. 品牌名称长度超过 30 会怎样？会导致**缓冲区溢出**，破坏程序其他数据，需确保字符串长度 ≤ 数组定义长度（这里是 30，包含结束符 `\0`）
// 对比说明：
//  字符数组成员 vs 普通变量赋值：`float` 等普通变量可直接用 `=` 赋值；但字符数组是“多个字符的集合”，必须用 `strcpy` 等字符串函数复制内容，不能直接用 `=` 整体赋值。


