//### 6.b 部分代码

// ------------------------------
// 题干：b. 重写a，在声明中使用一个带指定初始化器的初始化列表，而不是对每个成员单独赋值。
// 知识要点：
//  1. 结构体数组的**指定初始化器** - 可在声明时，通过“下标 + 成员名”精准初始化特定元素的成员
//  2. 初始化列表的语法 - 用 `[下标] = {.成员名 = 值, ...}` 格式，直接在声明时初始化指定元素
// 总体逻辑：
//  1. 定义 `LENS` 结构体类型（同 a 部分）
//  2. 声明包含 10 个 `LENS` 的数组，并在声明时用**指定初始化器**，直接初始化第 3 个元素（下标 2）的 `foclen`、`fstop`、`brand` 成员
//  3. 打印该元素的成员，验证初始化结果
#include <stdio.h>

typedef struct lens {
    float foclen;   // 焦距长度，单位：毫米
    float fstop;    // 孔径
    char brand[30]; // 品牌名称（字符数组，需存字符串结束符）
} LENS;

int main() {
    // 声明数组时，用指定初始化器直接初始化第 3 个元素（下标 2）
    LENS lenses[10] = {
        [2] = {.foclen = 500.0, .fstop = 2.0, .brand = "Remarkata"}
    };

    // 打印第 3 个镜头的信息，验证初始化结果
    printf("第3个镜头：焦距=%.1f mm，孔径=f/%.1f，品牌=%s\n", 
           lenses[2].foclen, 
           lenses[2].fstop, 
           lenses[2].brand);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：将代码保存为 `b_part.c`，用 GCC 编译（如 `gcc b_part.c -o b_part`），然后运行 `./b_part`
//  2. 预期结果：输出 `第3个镜头：焦距=500.0 mm，孔径=f/2.0，品牌=Remarkata`
//  3. 检查点：核对焦距、孔径的数值和品牌字符串是否与初始化的值一致
// 易错点提醒：
//  1. 指定初始化器语法易错 - 要注意 `[下标] = {.成员名 = 值, ...}` 的格式，成员名前的**点号（.）**不能省略
//  2. 字符数组初始化的长度限制 - 若字符串长度超过 `brand` 数组长度（30），会导致缓冲区溢出
// 拓展思考：
//  1. 如何同时初始化多个数组元素？可在初始化列表中用逗号分隔多个 `[下标] = { ... }`，例如：`[2] = { ... }, [5] = { ... }`
//  2. 若不指定下标，直接用“位置顺序”初始化会怎样？初始化列表会按数组下标从 0 开始依次赋值，若只需初始化特定元素，**指定下标**更清晰易读
// 对比说明：
//  单独赋值（a 部分）vs 指定初始化器（b 部分）：
//  - 单独赋值：先声明数组，再逐个给成员赋值，步骤多但灵活（可在运行时动态赋值）。
//  - 指定初始化器：声明时直接初始化特定元素，代码更简洁，适合“声明时就确定值”的场景，但灵活性稍低。