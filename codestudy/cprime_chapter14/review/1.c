// ------------------------------
// 题干：下面的结构模板有什么问题：
// struct {
//     char itable;
//     int num[20];
//     char *togs
// }
// 知识要点：
//  1. C语言结构体的定义语法 - 结构体每个成员的声明必须以分号结尾
//  2. C语言结构体的标签作用 - 若要后续通过“结构体名”定义变量，需给结构体指定标签（也可使用匿名结构体，但语法正确性仍需注意分号）
// 总体逻辑：
//  1. 检查结构体成员的语法：发现`char *togs`后面缺少分号，这会导致编译语法错误
//  2. 检查结构体的复用性：该结构体缺少标签（若后续要多次用此类型定义变量，没有标签会很不方便，除非是仅一次性使用的匿名结构体，但此处模板形式不完整）
#include <stdio.h>

// 正确的结构体定义示例（补充分号，并添加标签`MyStruct`，方便后续复用类型）
struct MyStruct {
    char itable;       // 定义字符类型成员`itable`
    int num[20];       // 定义整型数组成员`num`，长度为20
    char *togs;        // 定义字符指针成员`togs`，注意这里添加了分号（修正原问题）
};

int main() {
    // 定义一个`struct MyStruct`类型的变量`s`，用于测试结构体成员的访问
    struct MyStruct s;

    s.itable = 'A';    // 给字符成员`itable`赋值为'A'
    s.num[0] = 100;    // 给整型数组`num`的第1个元素（下标0）赋值为100
    s.togs = "test";   // 让字符指针`togs`指向字符串常量"test"

    // 打印各个成员的值，验证结构体是否能正常使用
    printf("itable: %c\n", s.itable);
    printf("num[0]: %d\n", s.num[0]);
    printf("togs: %s\n", s.togs);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：将代码保存为`.c`文件（如`struct_test.c`），用C语言编译器（如gcc）编译：`gcc struct_test.c -o struct_test`，然后运行生成的可执行文件：`./struct_test`
//  2. 预期结果：程序输出三行内容，分别是`itable: A`、`num[0]: 100`、`togs: test`
//  3. 检查点：重点查看每个成员是否被正确赋值，且打印结果与预期一致
// 易错点提醒：
//  1. 容易遗漏结构体成员后的分号，导致编译时出现“语法错误”（如`error: expected ';' before '}' token`）
//  2. 对匿名结构体的理解有误：若结构体没有标签且定义时不直接创建变量，后续将无法再用该类型定义变量（相当于“一次性”类型）
// 拓展思考：
//  1. 如果需要在函数间传递这个结构体的变量，是直接传结构体变量还是传指针更好？传指针更好，因为能避免拷贝结构体的所有成员（尤其当成员有数组、大内存时，传指针更高效）
//  2. 匿名结构体的典型使用场景是什么？当只需要临时定义一个结构体变量，且后续不再复用该类型时，可使用匿名结构体（例如`struct { int a; char b; } temp;`，仅用`temp`这一个变量）
// 对比说明：
//  有标签的结构体（如`struct MyStruct`）：可以在代码中多次用`struct MyStruct`定义新的变量，类型可复用；
//  无标签的匿名结构体（且定义时不直接创建变量）：只能在定义时直接创建变量（如`struct { ... } var;`），后续无法再用该“匿名类型”定义其他变量，复用性差。
// ------------------------------