// ------------------------------
// 题干：编写一个函数，用户提供月份号，该函数就返回一年中到该月为止（包括该月）的总天数。假设在所有函数的外部声明了第3题的结构模板和一个该类型结构的数组。
// 知识要点：
//  1. 结构体数组的定义与初始化 - 存储12个月的名称、缩写、天数等信息
//  2. 函数的定义与调用 - 编写计算总天数的函数，通过参数传递月份号
//  3. 循环累加的应用 - 从1月到指定月份，逐个累加每个月的天数
//  4. 结构体成员的访问 - 通过结构体数组元素，访问每个月的“天数”成员
// 总体逻辑：
//  1. 定义第3题的月份结构体（包含名称、缩写、天数、月份号）
//  2. 定义并初始化全局结构体数组，存储12个月（非闰年）的信息
//  3. 编写`calculateTotalDays`函数：接收月份号，循环累加从1月到该月的所有天数后返回
//  4. 在`main`函数中，调用该函数测试不同月份号（如3月、6月、12月），打印结果验证正确性
#include <stdio.h>

// 定义第3题的月份结构体
struct Month {
    char name[20];   // 存储完整月份名称
    char abbrev[4];  // 存储3个字母的缩写（需包含字符串结束符，所以设为4个字符空间）
    int days;        // 存储该月的天数
    int monthNum;    // 存储月份号（1 - 12）
};

// 定义并初始化全局结构体数组（非闰年，2月天数为28）
struct Month months[12] = {
    {"January", "Jan", 31, 1},    // 1月
    {"February", "Feb", 28, 2},   // 2月（非闰年）
    {"March", "Mar", 31, 3},      // 3月
    {"April", "Apr", 30, 4},      // 4月
    {"May", "May", 31, 5},        // 5月
    {"June", "Jun", 30, 6},       // 6月
    {"July", "Jul", 31, 7},       // 7月
    {"August", "Aug", 31, 8},     // 8月
    {"September", "Sep", 30, 9},  // 9月
    {"October", "Oct", 31, 10},   // 10月
    {"November", "Nov", 30, 11},  // 11月
    {"December", "Dec", 31, 12}   // 12月
};

// 计算“从1月到指定月份”总天数的函数
int calculateTotalDays(int monthNum) {
    int total = 0;  // 用于累加总天数的变量，初始化为0
    // 循环从1月（数组下标0）到指定月份（数组下标monthNum-1）
    for (int i = 0; i < monthNum; i++) {
        total += months[i].days;  // 累加当前月份的天数
    }
    return total;  // 返回累加后的总天数
}

int main() {
    // 测试案例1：月份号为3（3月）
    int month1 = 3;
    int total1 = calculateTotalDays(month1);
    printf("到%d月为止的总天数：%d\n", month1, total1);

    // 测试案例2：月份号为6（6月）
    int month2 = 6;
    int total2 = calculateTotalDays(month2);
    printf("到%d月为止的总天数：%d\n", month2, total2);

    // 测试案例3：月份号为12（12月，全年总天数）
    int month3 = 12;
    int total3 = calculateTotalDays(month3);
    printf("到%d月为止的总天数：%d\n", month3, total3);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：将代码保存为.c文件（如total_days.c），用C编译器（如gcc）编译：`gcc total_days.c -o total_days`，然后运行`./total_days`
//  2. 预期结果：输出三行内容，分别是“到3月为止的总天数：90”（1月31 + 2月28 + 3月31 = 90）、“到6月为止的总天数：181”（31+28+31+30+31+30 = 181）、“到12月为止的总天数：365”（非闰年全年天数之和为365）
//  3. 检查点：重点核对每个测试月份的总天数是否与手动计算结果一致（比如3月总天数是否为90，6月是否为181，12月是否为365）
// 易错点提醒：
//  1. 数组下标易混淆 - 结构体数组`months`的下标从0开始（对应1月），所以循环条件`i < monthNum`是正确的（如monthNum=3时，i取0、1、2，对应1、2、3月）
//  2. 月份号合法性易忽略 - 如果传入的`monthNum`是0或大于12，函数会访问数组越界，实际应添加`if (monthNum < 1 || monthNum > 12)`的合法性判断
// 拓展思考：
//  1. 如何支持闰年？可给函数增加`int isLeap`参数，当`isLeap`为1时，将2月天数视为29天（可在函数内判断月份为2时，根据`isLeap`调整天数）
//  2. 若结构体数组不是全局的，如何修改？可将结构体数组作为参数传递给函数，如`int calculateTotalDays(struct Month monthArr[], int monthNum)`，这样函数能操作不同的月份数组（如闰年/非闰年数组），灵活性更高
// 对比说明：
//  全局数组 vs 传参：使用全局数组时，函数直接访问全局变量，代码简洁但灵活性低；若把数组作为参数传递，函数不依赖全局变量，能适配不同场景（如闰年数组），但调用时需额外传参。
// ------------------------------