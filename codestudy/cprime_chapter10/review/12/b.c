// ------------------------------
// 题干：分别以传统方式和以变长数组为参数的方式，编写处理 clops 数组的 void 函数原型和函数调用
// 知识要点：
//  1. 二维数组的参数传递：传统方式需指定第二维大小，变长数组（VLA）可动态指定维度。
//  2. 函数原型声明：传统方式需固定第二维，VLA 方式可通过参数动态指定维度。
//  3. 变长数组（VLA）特性：C99/C11 支持，维度由运行时参数决定。
// 总体逻辑：
//  1. 传统方式：函数原型固定第二维为 30，调用时直接传数组名。
//  2. VLA 方式：函数原型通过参数动态指定第二维，调用时传入维度。
#include <stdio.h>

// 传统方式函数原型：第二维固定为 30
void traditional2D(double arr[][30], int rows);
// VLA 方式函数原型：第二维由参数 cols 动态指定
void vla2D(int rows, int cols, double arr[rows][cols]);

int main() {
    // 定义二维数组 clops
    double clops[10][30];
    int rows = 10, cols = 30;

    // 传统方式调用：第二维固定为 30
    traditional2D(clops, rows);
    // VLA 方式调用：动态传入维度
    vla2D(rows, cols, clops);

    return 0;
}

// 传统方式函数定义：处理二维数组，第二维固定为 30
void traditional2D(double arr[][30], int rows) {
    printf("传统方式处理二维数组，行数：%d，列数固定为 30\n", rows);
    // 可在此添加数组处理逻辑（如遍历）
}

// VLA 方式函数定义：处理二维数组，维度由参数动态决定
void vla2D(int rows, int cols, double arr[rows][cols]) {
    printf("VLA 方式处理二维数组，行数：%d，列数：%d\n", rows, cols);
    // 可在此添加数组处理逻辑（如遍历）
}

// 测试验证方案：
//  1. 怎么运行：编译运行（如 `gcc -std=c99 -o test test.c`，然后 `./test`）。
//  2. 预期结果：输出两种方式的提示信息，无编译错误。
//  3. 检查点：确认函数调用成功，输出行数和列数是否正确。
// 易错点提醒：
//  1. 传统方式容易忘记固定第二维，导致编译错误。
//  2. VLA 方式在不支持 C99 的编译器中会报错（如 MSVC）。
// 拓展思考：
//  1. 如果数组是三维的，如何用 VLA 方式传递参数？
//  2. 传统方式和 VLA 方式的性能差异大吗？为什么？
// 对比说明：
//  - 传统方式：第二维固定，兼容性好（支持老编译器），但不够灵活。
//  - VLA 方式：维度动态，更灵活，但依赖 C99/C11 标准，兼容性稍差。