// ------------------------------
// 题干：分别以传统方式和以变长数组为参数的方式编写处理trots数组的void函数原型和函数调用
// （这里trots数组是double trots[20];  ，题目中声明的数组 ）
// 知识要点：
//  1. 函数参数传递：传统数组参数传递方式（指定数组大小）和变长数组（VLA）参数传递方式（运行时确定大小） 
//  2. 函数原型声明：不同参数形式的函数原型写法 
// 总体逻辑：
//  1. 先写出处理trots数组的传统方式函数原型和调用
//  2. 再写出变长数组方式的函数原型和调用
#include <stdio.h>

// 传统方式函数原型：处理double数组，指定大小为20
void traditionalFunc(double arr[20], int size);
// 变长数组方式函数原型：处理double数组，大小由参数传入
void vlaFunc(int size, double arr[size]); 

int main() {
    double trots[20];
    int size = 20;

    // 传统方式函数调用
    traditionalFunc(trots, size);
    // 变长数组方式函数调用
    vlaFunc(size, trots);

    return 0;
}

// 传统方式函数定义
void traditionalFunc(double arr[20], int size) {
    printf("传统方式处理数组，数组大小固定为20\n");
    // 这里可添加处理数组的代码，比如遍历等
}

// 变长数组方式函数定义
void vlaFunc(int size, double arr[size]) {
    printf("变长数组方式处理数组，数组大小为%d\n", size);
    // 这里可添加处理数组的代码，比如遍历等
}
// 测试验证方案：
//  1. 怎么运行：编译并运行代码（需确保编译器支持C99及以上标准以支持变长数组 ）
//  2. 预期结果：函数调用成功，输出对应提示信息
//  3. 检查点：看函数是否能正常调用，验证两种参数传递方式
// 易错点提醒：
//  1. 传统方式函数原型中容易写错数组大小，要和实际数组匹配
//  2. 变长数组方式在不支持C99标准的编译器中会报错，要注意编译器设置
// 拓展思考：
//  1. 如果数组大小是动态变化的（比如由用户输入），哪种方式更合适？为什么？
// 对比说明：
//  - 传统方式：数组大小固定，适合大小确定的场景；变长数组方式：更灵活，适合大小运行时确定的场景。两种方式各有适用情况，根据需求选择 