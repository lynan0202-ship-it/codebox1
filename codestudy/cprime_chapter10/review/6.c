// ------------------------------
// 题干：假设有下面的声明：
//      int grid[30][100];
//      a. 用 1 种写法表示 grid[22][56] 的地址 
//      b. 用 1 种写法表示 grid[22][0] 的地址 
//      c. 用 1 种写法表示 grid[0][0] 的地址 
// 知识要点：
//  1. 数组元素地址的表示：数组元素的地址可以通过数组名、下标等方式表示，利用指针算术运算
//  2. 二维数组元素地址的计算：根据二维数组的存储布局和指针运算规则
// 总体逻辑：
//  1. 对于二维数组元素地址，可利用数组名 + 偏移的方式表示，或者通过指针算术运算推导
#include <stdio.h>
int main() {
    int grid[30][100];
    // a. 表示 grid[22][56] 的地址，写法一：&grid[22][56]  ，这里用另一种指针运算方式演示
    int *addrA = &grid[22][56];
    printf("grid[22][56] 的地址（写法：&grid[22][56] 对应的指针值）：%p\n", (void *)addrA);
    // b. 表示 grid[22][0] 的地址，写法：(int *)&grid[22]  ，也可写成 grid[22] 
    int *addrB = grid[22];
    printf("grid[22][0] 的地址（写法：grid[22] 对应的指针值）：%p\n", (void *)addrB);
    // c. 表示 grid[0][0] 的地址，写法：grid[0]  或者 &grid[0][0] 
    int *addrC = grid[0];
    printf("grid[0][0] 的地址（写法：grid[0] 对应的指针值）：%p\n", (void *)addrC);
    return 0;
}
// 测试验证方案：
//  1. 怎么运行：编译运行代码
//  2. 预期结果：输出对应元素地址的指针值，地址表示符合二维数组元素地址的计算规则
//  3. 检查点：看输出的地址表示是否符合题目要求的写法对应的指针值
// 易错点提醒：
//  1. 容易混淆不同地址表示方式，要牢记数组元素地址的多种正确写法
// 拓展思考：
//  1. 如果是动态分配的二维数组（如 int **grid = (int **)malloc(30 * sizeof(int *));  ，然后每行再分配 ），地址表示方式会有变化吗？为什么？
// 对比说明：
//  - 静态二维数组（本题这种声明方式）：地址表示基于连续存储的布局；动态分配的二维数组（指针数组形式 ）：地址表示会不同，因为其存储布局不是连续的行存储，而是指针指向各行的存储区域