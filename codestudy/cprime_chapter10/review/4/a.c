// ------------------------------
// 题干：在下面的代码中，*ptr 和*(ptr + 2)的值分别是什么？
//      a.
//      int *ptr;
//      int torf[2][2] = {12, 14, 16};
//      ptr = torf[0];
// 知识要点：
//  1. 二维数组的存储：二维数组在内存中是按行连续存储的
//  2. 指针与二维数组：二维数组的行可以看作一维数组，其数组名可赋值给指针
//  3. 指针的算术运算：指针移动时按所指向数据类型大小偏移
// 总体逻辑：
//  1. 分析二维数组 torf 的存储布局
//  2. 确定 ptr 指向的位置，计算 *ptr 和*(ptr + 2)的值
#include <stdio.h>
int main() {
    int *ptr;
    // 二维数组 torf 实际存储为按行连续：12,14,16, （剩余元素默认初始化，这里可能是随机值，实际在初始化时会自动填充，这里因初始化列表元素不足，剩余元素为 0 ，但在某些编译器可能有不同表现，不过按照题目逻辑分析 ）
    int torf[2][2] = {12, 14, 16};
    ptr = torf[0];
    printf("*ptr 的值是：%d\n", *ptr);
    printf("*(ptr + 2) 的值是：%d\n", *(ptr + 2));
    return 0;
}
// 测试验证方案：
//  1. 怎么运行：编译运行代码
//  2. 预期结果：*ptr 为 12 ，*(ptr + 2) 为 16 
//  3. 检查点：看输出是否符合预期
// 易错点提醒：
//  1. 容易错误认为二维数组的元素存储不是连续的，要牢记二维数组在内存中是按行连续存放的
// 拓展思考：
//  1. 如果 torf 的初始化列表元素更多，比如 {12,14,16,18} ，结果会怎么变化？
// 对比说明：
//  - 二维数组行的指针操作和一维数组指针操作类似，都是按元素大小偏移，只是二维数组在内存中是连续的行存储