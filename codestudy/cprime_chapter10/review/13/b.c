// ------------------------------
// 题干：编写 `show2` 函数，参数为 `const double ar2[][3]` 和 `int n`，输出二维数组信息
// 知识要点：
//  1. 二维数组的参数传递：需固定第二维（`3`），第一维由 `n` 控制。
//  2. `const` 修饰符：保护数组不被修改，增强代码安全性。
//  3. 嵌套循环遍历：二维数组需嵌套循环，外层控制行，内层控制列。
// 总体逻辑：
//  1. 定义 `show2` 函数，接收二维数组和行数。
//  2. 嵌套循环遍历数组，输出元素（或行数/列数）。
#include <stdio.h>

// 函数原型：输出二维数组的元素（或行数/列数，这里演示输出元素）
void show2(const double ar2[][3], int n);

int main() {
    // 定义二维数组，3 列，n=2 行
    const double ar2[2][3] = {{1.1, 2.2, 3.3}, {4.4, 5.5, 6.6}};
    int n = 2;

    // 调用 show2 函数
    show2(ar2, n);

    return 0;
}

// 函数定义：嵌套循环遍历二维数组，输出元素
void show2(const double ar2[][3], int n) {
    printf("二维数组元素：\n");
    for (int i = 0; i < n; i++) { // 遍历行
        for (int j = 0; j < 3; j++) { // 遍历列
            printf("%.1f ", ar2[i][j]);
        }
        printf("\n");
    }
}

// 测试验证方案：
//  1. 怎么运行：编译运行（如 `gcc -o test test.c`，然后 `./test`）。
//  2. 预期结果：输出二维数组的元素，按行排列。
//  3. 检查点：确认输出元素与初始化值一致，行列正确。
// 易错点提醒：
//  1. 容易忘记第二维固定为 `3`，导致内层循环条件错误（如写 `j < n`）。
//  2. 误用 `ar2` 的维度，如把 `ar2[i][j]` 写成 `ar2[j][i]`。
// 拓展思考：
//  1. 如果第二维也动态（用 VLA），如何修改函数？
//  2. 如何让函数同时输出数组的行列数？
// 对比说明：
//  - 二维数组传参时，必须固定除第一维外的维度（传统方式），否则需用 VLA 动态指定，灵活性与兼容性需权衡。