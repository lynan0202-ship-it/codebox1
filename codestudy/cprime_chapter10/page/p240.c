// ------------------------------
// 知识要点总结：
//  1. 数组的部分初始化：当初始化值数量少于数组大小时，剩余元素自动补 0
//  2. sizeof 运算符的应用：计算数组总字节数和单个元素字节数，推导数组长度
//  3. 符号常量的使用：#define 定义 SIZE，统一管理数组大小
//  4. 格式化输出：%2d（占 2 位的整数）、%14d（占 14 位的整数）控制输出格式
//  5. 数组遍历：for 循环结合数组下标，逐个访问数组元素
// 
// 总体逻辑说明：
//  1. 定义符号常量 SIZE 表示数组大小（4 个元素）
//  2. 部分初始化数组 some_data：前 2 个元素赋值，后 2 个元素自动补 0
//  3. 先打印表头（i 和 some_data[i]），再通过 for 循环遍历数组
//  4. 输出每个下标对应的数组元素值，验证部分初始化的补 0 特性
// ------------------------------

#include <stdio.h>
// 定义符号常量，控制数组的大小
#define SIZE 4  

int main(void)
{
    // 部分初始化数组：前 2 个元素为 1492、1066，后 2 个元素自动补 0
    int some_data[SIZE] = {1492, 1066};  
    int i;  // 循环下标变量

    // 打印表头：i 占 2 位，some_data[i] 占 14 位
    printf("%2s%14s\n", "i", "some_data[i]");  

    // 遍历数组：i 从 0 到 3（共 4 个元素）
    for (i = 0; i < SIZE; i++)  
    {
        // 输出格式：i 占 2 位，some_data[i] 占 14 位
        printf("%2d%14d\n", i, some_data[i]);  
    }

    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础功能测试：
//     - 运行程序，检查输出是否包含 4 行数据（0~3 下标）
//     - 确认表头格式正确（i 占 2 位，some_data[i] 占 14 位）
//     - 验证部分初始化效果：下标 0、1 为初始化值，下标 2、3 为 0
// 
//  2. 扩展测试：
//     a) 修改 SIZE 为 5，初始化值改为 {1,2}，观察输出是否后 3 个元素补 0
//     b) 尝试修改 some_data[2] = 5（普通数组可修改），重新编译运行，观察下标 2 的值变化
//     c) 把数组类型改为 float（如 float some_data[SIZE] = {1.5, 3.2};），观察补 0 特性是否相同
// 
//  3. 易错点提醒：
//     - 数组下标从 0 开始！some_data[0] 是第一个元素，不是 some_data[1]
//     - 部分初始化时，剩余元素补 0 的特性只对数值类型数组有效（如 int、float），字符数组补 '\0'（空字符）
//     - printf 格式控制符 %14d 中的数字是最小宽度，数值位数不足时会用空格填充，理解错容易导致格式混乱
// 
//  4. 对比学习（扩展）：
//     - 对比“完全初始化数组”和“部分初始化数组”的输出差异
//     - 对比数值数组（int）和字符数组（char）的补 0 特性（字符数组补 '\0'，表现为输出空）
// 
//  5. 拓展思考：
//     - 如果初始化值数量超过数组大小（如 SIZE=2 但给 3 个值），编译会报错吗？（提示：会报错，初始化值不能超过数组大小）
//     - 如何利用部分初始化特性快速创建“前几个元素有值，后面全 0”的数组？
// ------------------------------