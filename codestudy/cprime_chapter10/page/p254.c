// ------------------------------
// 知识要点总结（涵盖 2 个程序）：
//  1. 指针遍历数组的两种方式：
//     - 传递“起始指针 + 元素个数”（sum 函数）
//     - 传递“起始指针 + 末尾指针”（sump 函数）
//  2. 指针运算与优先级：
//     - *start++ 的含义（先取值，再移动指针）
//     - ++*start 的含义（先移动指针，再取值）
//     - (*start)++ 的含义（先取值，再修改指针指向的值）
//  3. 数组末尾指针的特性：
//     - marbles + SIZE 指向数组最后一个元素的下一个位置（合法但不可访问）
//     - 利用末尾指针结束循环（start < end）
//  4. 指针形参的等价性：
//     - int *start 和 int start[] 作为函数形参等价
//  5. 不同指针操作的效果对比：
//     - 区分 *p++、++*p、(*p)++ 的行为差异
// 
// 总体逻辑说明：
//  1. 演示 sump 函数：用“起始指针 + 末尾指针”遍历数组求和
//  2. 演示 order 程序：用不同指针操作（*p++、++*p 等）修改数组
//  3. 对比不同指针操作的结果，验证优先级和运算顺序
//  4. 故意写易错代码，解释指针操作的常见陷阱
// ------------------------------

#include <stdio.h>
#define SIZE 10  // 数组元素个数（sum 程序用）
#define ARR_SIZE 2  // 数组元素个数（order 程序用）

// -------------------- sum 程序：sump 函数（用末尾指针结束循环） --------------------
int sump(int *start, int *end);

// -------------------- order 程序：演示指针优先级 --------------------
void order(int *p1, int *p2, int *p3);

int main(void)
{
    // ========== sum 程序测试 ==========
    int marbles[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
    long answer;

    // 调用 sump 函数：传递起始指针和末尾指针（marbles + SIZE）
    answer = sump(marbles, marbles + SIZE);  
    printf("sum 程序结果：Total marbles = %ld\n", answer);


    // ========== order 程序测试 ==========
    int data[ARR_SIZE] = {100, 200};
    int moredata[ARR_SIZE] = {300, 400};
    int *p1 = data, *p2 = data, *p3 = moredata;

    printf("\norder 程序测试：\n");
    // 初始值
    printf("初始：*p1=%d, *p2=%d, *p3=%d\n", *p1, *p2, *p3);

    // 调用 order 函数，演示指针操作
    order(p1, p2, p3);  

    // 操作后的值
    printf("最终：*p1=%d, *p2=%d, *p3=%d\n", *p1, *p2, *p3);
    printf("moredata 数组：%d, %d\n", moredata[0], moredata[1]);


    return 0;
}

// -------------------- sump 函数定义（sum 程序） --------------------
int sump(int *start, int *end)
{
    int total = 0;
    // 用末尾指针结束循环（start 移动到 end 时停止）
    while (start < end)  
    {
        // *start++：先取 start 指向的值，再移动指针
        total += *start++;  
    }
    return total;
}

// -------------------- order 函数定义（order 程序） --------------------
void order(int *p1, int *p2, int *p3)
{
    // 打印初始指针值
    printf("操作前：*p1=%d, *p2=%d, *p3=%d\n", *p1, *p2, *p3);

    // 1. *p1++：先取 *p1（100），p1 移动到 data[1]
    printf("*p1++ = %d\n", *p1++);  

    // 2. ++*p2：先移动 p2（无意义，p2 已指向 data[0]），再取 *p2（100 → 但这里实际是先取值再加？不，++*p2 是先将 *p2 的值加 1，再取值）
    // 注意：++*p2 等价于 *p2 = *p2 + 1; 然后返回新值
    printf("++*p2 = %d\n", ++*p2);  

    // 3. (*p3)++：先取 *p3（300），再将 *p3 的值加 1（300 → 301）
    printf("(*p3)++ = %d\n", (*p3)++);  

    // 打印操作后的指针值
    printf("操作后：*p1=%d, *p2=%d, *p3=%d\n", *p1, *p2, *p3);
}

// ------------------------------
// 测试及验证建议方案：
//  1. sum 程序测试：
//     a) 修改 marbles 数组的值，验证 sump 函数的求和结果是否正确
//     b) 尝试将 end 指针改为 marbles + SIZE - 1，观察循环次数变化
// 
//  2. order 程序测试：
//     a) 单步调试，观察 p1、p2、p3 的地址变化和值的修改
//     b) 分别注释掉不同的指针操作，观察输出变化，理解优先级
//     c) 故意混淆 *p++、++*p、(*p)++，看编译器报错或运行结果
// 
//  3. 易错点提醒：
//     - *start++ 容易误解为“先移动指针再取值”，实际是“先取值再移动”
//     - marbles + SIZE 指向的位置不可访问，尝试 *end 会导致未定义行为
//     - 形参中的 int arr[] 本质是指针，sizeof(arr) 无法获取数组大小
// 
//  4. 拓展思考：
//     - 如果数组是 double 类型，指针操作的步长会如何变化？
//     - 如何用指针操作实现数组元素的逆序？
//     - 对比“传递元素个数”和“传递末尾指针”两种遍历方式的优劣
// 
//  5. 调试技巧：
//     - 使用 printf 打印指针地址（%p），观察指针移动的步长
//     - 在 order 函数中打印 *p1、*p2、*p3 的地址，验证指针是否移动
// ------------------------------

// 特别说明（帮你区分指针操作）：
//  1. *p++ ≠ ++*p ≠ (*p)++ 
//     - *p++：取值 → 移动指针（常用遍历数组）
//     - ++*p：移动指针 → 取值（危险，可能越界）
//     - (*p)++：取值 → 修改值（不移动指针，修改当前元素）
//  2. 末尾指针的安全使用：
//     - start < end 是安全的（end 可以指向数组外的合法位置）
//     - 但 *end 是非法的（不可访问数组外的内容）


/*
运行结果示例（分两部分）：
sum 程序部分：
plaintext
sum 程序结果：Total marbles = 190
order 程序部分：
plaintext
order 程序测试：
初始：*p1=100, *p2=100, *p3=300
操作前：*p1=100, *p2=100, *p3=300
*p1++ = 100  // 先取值 100，p1 移动到 data[1]
++*p2 = 101  // 先将 *p2 加 1（100→101），再取值
(*p3)++ = 300  // 先取值 300，再将 *p3 加 1（300→301）
操作后：*p1=200, *p2=101, *p3=301
最终：*p1=200, *p2=101, *p3=301
moredata 数组：301, 400  // (*p3)++ 修改了 moredata[0]

特别设计（帮你避坑）：
分步打印：在 order 函数中分步打印指针操作的结果，帮你逐行理解 *p++、++*p、(*p)++ 的区别
地址验证：建议你在 order 函数中添加 printf("p1 address: %p\n", p1);，观察指针地址的变化
错误演示：故意保留容易混淆的指针操作，让你在测试中踩坑（然后理解为什么错）
对比学习：sum 程序和 order 程序放在一起，你能同时验证 “数组求和” 和 “指针优先级” 两个知识点
如果运行时发现 moredata[0] 变成了 301，恭喜你！这说明你理解了 (*p3)++ 的作用 —— 修改指针指向的值，而不是移动指针～

*/