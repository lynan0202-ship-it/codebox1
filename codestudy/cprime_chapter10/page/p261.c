
/*
知识要点总结：
1. 指向二维数组的指针声明：int (*pz)[2]，表示 pz 是一个指针，指向“内含 2 个 int 的数组”
2. 二维数组名与指针的关系：二维数组名（如 zippo）本质是指向其首元素（一维数组）的指针，可赋值给指向二维数组的指针（如 pz = zippo）
3. 指针运算与数组访问：
   - pz + 1：跳过一个“内含 2 个 int 的数组”，指向下一个一维数组
   - pz[0] / *pz：等价于 zippo[0]，是一维数组的首地址
   - pz[2][1] / *(*(pz + 2) + 1)：两种方式访问二维数组元素，体现“数组表示法”和“指针表示法”的等价性
4. 优先级易错点：int *pax[2] 是指针数组（[] 优先级高于 *），与 int (*pz)[2]（指向数组的指针）声明形式需严格区分

代码总体逻辑说明：
1. 定义二维数组 zippo 并初始化，作为演示对象
2. 声明指向二维数组的指针 pz，将 zippo 的地址赋值给 pz
3. 通过一系列 printf，对比指针运算（如 pz、pz+1、*pz 等）的地址，以及数组元素访问（如 pz[0][0]、**pz 等）的值
4. 验证“数组表示法”和“指针表示法”访问元素的等价性，帮助理解二维数组的指针操作
*/

#include <stdio.h>

int main(void)
{
    // 定义二维数组 zippo：4 个一维数组，每个一维数组含 2 个 int
    int zippo[4][2] = { {2, 4}, {6, 8}, {1, 3}, {5, 7} };
    // 声明指向二维数组的指针：pz 指向“内含 2 个 int 的数组”
    int (*pz)[2];

    // 将二维数组名 zippo 赋值给 pz（zippo 是其首元素一维数组的地址）
    pz = zippo;

    // 打印指针地址：对比 pz、pz+1 的跳转，验证“跳过一个一维数组”
    printf(" pz = %p,   pz + 1 = %p\n",  pz,  pz + 1);
    // 打印一维数组地址：pz[0]/*pz 等价于 zippo[0]，验证指针与数组首元素的关系
    printf("pz[0] = %p, pz[0] + 1 = %p\n", pz[0], pz[0] + 1);
    // 打印解引用地址：*pz 等价于 pz[0]，进一步验证指针操作
    printf("  *pz = %p,   *pz + 1 = %p\n",  *pz,  *pz + 1);
    // 直接访问数组元素：验证数组下标法
    printf("pz[0][0] = %d\n", pz[0][0]);
    // 指针解引用访问：*pz[0] 等价于 zippo[0][0]
    printf("  *pz[0] = %d\n", *pz[0]);
    // 双重解引用访问：**pz 等价于 zippo[0][0]
    printf("   **pz = %d\n", **pz);
    // 数组下标法访问：直接访问二维数组元素
    printf("  pz[2][1] = %d\n", pz[2][1]);
    // 指针表示法访问：*(*(pz + 2) + 1) 等价于 pz[2][1]
    printf("*(*(pz+2) + 1) = %d\n", *(*(pz + 2) + 1));

    return 0;
}

/*
测试及验证建议方案：
1. 编译运行代码，观察地址输出：
   - 检查 pz + 1 与 pz 的地址差是否为“2 * sizeof(int)”（跳过一个一维数组的大小）
   - 对比 pz[0]、*pz、zippo[0] 的地址是否一致，验证指针赋值逻辑
2. 修改数组元素值（如 zippo[2][1] = 5），重新运行：
   - 检查 pz[2][1] 和 *(*(pz + 2) + 1) 的输出是否同步改变，验证两种访问方式的等价性
3. 故意写错指针声明（如 int *pz[2]），观察编译器报错：
   - 对比 int (*pz)[2] 和 int *pz[2] 的区别，强化“指向数组的指针”与“指针数组”的声明记忆
4. 扩展测试：
   - 尝试 pz = &zippo[1]，观察 pz + 1 后的地址变化，理解指针指向中间一维数组时的运算逻辑
   - 用循环遍历二维数组（for 循环 + pz 指针），练习指针遍历二维数组的写法
*/

/*
### 代码运行示例输出（地址值因环境而异，逻辑关系一致）：
```
 pz = 0x7ffeefbff5a0,   pz + 1 = 0x7ffeefbff5a8
pz[0] = 0x7ffeefbff5a0, pz[0] + 1 = 0x7ffeefbff5a4
  *pz = 0x7ffeefbff5a0,   *pz + 1 = 0x7ffeefbff5a4
pz[0][0] = 2
  *pz[0] = 2
   **pz = 2
  pz[2][1] = 3
*(*(pz+2) + 1) = 3
```

### 关键验证点说明：
- **地址差验证**：`pz + 1` 与 `pz` 的地址差应为 `2 * sizeof(int)`（假设 int 占 4 字节，则差为 8），体现指针跳过“一维数组”的逻辑  
- **访问等价性**：`pz[2][1]` 和 `*(*(pz + 2) + 1)` 输出值必须相同，验证两种表示法的等价性  
- **声明对比**：将 `int (*pz)[2]` 改为 `int *pz[2]` 后，编译器会报错（类型不匹配），可直观感受声明形式的严格性  

通过上述代码和测试，可深度理解**指向二维数组的指针**的声明、运算及与数组访问的关系，解决“二维数组指针”学习中的核心难点。
*/