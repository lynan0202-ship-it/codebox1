// ------------------------------
// 知识要点总结：
//  1. 未初始化指针的危害：
//     - 指针变量存储随机地址，解引用会导致未知内存被修改（程序崩溃、数据损坏）
//  2. 指针的有效操作：
//     - 指针自增（ptr++）、指针加减整数（ptr + n）
//     - 指针赋值（用数组名或已有变量地址初始化）
//  3. 指针的无效操作：
//     - 数组名自增（urn++，数组名是常量，不能修改）
//     - 指针相加（ptr2 + ptr1，无实际意义，编译器报错）
//     - 指针与数组名相乘（urn * ptr1，非法操作，编译器报错）
//  4. 指针初始化的正确方式：
//     - 用数组名初始化（ptr = urn）
//     - 用变量地址初始化（ptr = &var）
//     - 动态分配内存（后续学习 malloc）
// 
// 总体逻辑说明：
//  1. 演示未初始化指针的危险操作（注释掉，避免直接运行）
//  2. 定义数组 urn 和指针 ptr1、ptr2，演示有效操作
//  3. 对比有效操作（ptr1++、ptr2 = ptr1 + 2 等）和无效操作（urn++ 等）
//  4. 故意写无效操作代码（注释掉），让编译器报错，理解错误场景
// ------------------------------

#include <stdio.h>

int main(void)
{
    // 定义数组（3 个 int 元素）
    int urn[3] = {10, 20, 30};  
    // 定义两个 int 类型指针
    int *ptr1, *ptr2;  


    // -------------------- 危险操作：解引用未初始化指针（别学！） --------------------
    // 错误示例：未初始化指针，解引用会导致未知错误
    // int *bad_ptr;
    // *bad_ptr = 5;  // 严重错误！编译器可能警告，运行时可能崩溃


    // -------------------- 有效操作演示：指针初始化与算术 --------------------
    // 正确初始化：用数组名（首地址）初始化 ptr1
    ptr1 = urn;  
    printf("ptr1 初始化后：ptr1 = %p, *ptr1 = %d\n", ptr1, *ptr1);

    // 有效操作 1：指针自增（ptr1++）
    ptr1++;  
    printf("ptr1++ 后：ptr1 = %p, *ptr1 = %d\n", ptr1, *ptr1);

    // 有效操作 2：指针加减整数（ptr2 = ptr1 + 2）
    ptr2 = ptr1 + 2;  
    printf("ptr2 = ptr1 + 2 后：ptr2 = %p, *ptr2 = %d\n", ptr2, *ptr2);

    // 有效操作 3：指针赋值（ptr2 = urn + 1）
    ptr2 = urn + 1;  
    printf("ptr2 = urn + 1 后：ptr2 = %p, *ptr2 = %d\n", ptr2, *ptr2);


    // -------------------- 无效操作演示（注释掉，避免报错） --------------------
    // 错误操作 1：数组名自增（urn 是常量，不能修改）
    // urn++;  // 编译器报错：表达式必须是可修改的左值

    // 错误操作 2：指针相加（ptr2 + ptr1 无意义）
    // ptr2 = ptr2 + ptr1;  // 编译器报错：无效的操作数 +

    // 错误操作 3：指针与数组名相乘（urn * ptr1 非法）
    // ptr2 = urn * ptr1;  // 编译器报错：无效的操作数 *


    // -------------------- 验证指针操作的边界 --------------------
    // ptr1 现在指向 urn[1]，ptr2 指向 urn[1]
    // 有效操作：指针相减（计算元素个数差）
    int diff = ptr2 - ptr1;  
    printf("ptr2 - ptr1 = %d（元素个数差，不是字节差）\n", diff);


    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础功能测试：
//     a) 运行程序，检查有效操作的输出是否符合预期（ptr1 地址变化、值变化）
//     b) 核对 ptr1++ 后是否指向 urn[1]（值为 20）
//     c) 核对 ptr2 = ptr1 + 2 后是否指向 urn[3]（越界但合法，值可能随机）
// 
//  2. 错误场景测试：
//     a) 取消注释“危险操作”，编译看报错（警告未初始化指针）
//     b) 取消注释“无效操作”，编译看报错（理解错误类型）
// 
//  3. 易错点提醒：
//     - 数组名是常量，不能自增（urn++ 报错）
//     - 指针相加、相乘是非法操作（编译器直接报错）
//     - 未初始化指针解引用是“未定义行为”（可能崩溃或静默错误）
// 
//  4. 拓展思考：
//     - 如果 ptr2 = ptr1 + 3，指向 urn[4]（越界），解引用会怎样？
//     - 如何用指针遍历数组的所有元素（用 ptr1++ 和条件判断）？
//     - 对比指针初始化前后的地址变化，理解“指针存储的是地址”
// ------------------------------

/*特别设计（帮你避坑）：
1. **危险代码先注释**：把危险操作注释掉，避免你直接运行时报错 confusion（想测试错误时，再取消注释看编译器怎么说 ）  
2. **对比输出**：特意打印指针地址和值，帮你直观看到指针移动和元素访问的效果  
3. **错误代码分组**：把无效操作集中注释掉，你能清晰区分“编译器允许”和“编译器禁止”的操作  
4. **边界验证**：故意让 ptr2 指向 urn[3]（越界），运行后看值是否随机，验证“越界指针解引用是未定义行为”  

如果运行时发现 ptr2 指向 urn[3] 后的值是随机数，别慌！这就是越界指针的效果～ 想验证数组名不能自增，取消注释 `urn++`，看编译器怎么报错吧～
*/