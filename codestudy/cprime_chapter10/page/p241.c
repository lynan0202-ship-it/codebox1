// ------------------------------
// 知识要点总结：
//  1. 指定初始化器（C99 特性）：用 [下标] = 值 的方式，直接初始化指定位置的数组元素
//  2. 自动补 0 特性：未显式初始化的元素，会被自动设置为 0
//  3. 混合初始化：可以同时用指定初始化和普通初始化，灵活控制数组内容
//  4. 下标范围：初始化时下标不能超过数组定义的大小（否则编译报错）
// 
// 总体逻辑说明：
//  1. 定义一个长度为 6 的数组 arr
//  2. 用指定初始化器，只初始化下标 5 的元素为 212
//  3. 再用混合初始化，给下标 2 赋值 9527，验证自动补 0 特性
//  4. 遍历数组，输出每个下标对应的元素值，观察初始化效果
// ------------------------------

#include <stdio.h>

int main(void)
{
    // 定义长度为 6 的数组，演示两种初始化方式
    // 方式 1：指定初始化器，只初始化 arr[5] = 212
    // 方式 2：混合初始化，给 arr[2] = 9527（普通初始化）
    int arr[6] = { 
        [5] = 212,    // 指定下标 5 的元素为 212
        [2] = 9527    // 混合初始化，指定下标 2 的元素为 9527
    };  

    int i;  // 循环下标变量

    // 遍历数组，输出每个下标和对应的值
    for (i = 0; i < 6; i++)
    {
        // 输出格式：下标占 2 位，值占 6 位
        printf("arr[%d] = %6d\n", i, arr[i]);  
    }

    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础功能测试：
//     - 运行程序，检查输出是否有 6 行（下标 0~5）
//     - 确认 arr[5] = 212，arr[2] = 9527，其余下标为 0
// 
//  2. 特性验证测试：
//     a) 注释掉 [2] = 9527，重新编译运行，观察 arr[2] 是否自动补 0
//     b) 尝试初始化一个不存在的下标（如 [6] = 100），观察编译报错信息
//     c) 混合普通初始化（如在大括号里直接写 1,2），看是否能和指定初始化共存
// 
//  3. 易错点提醒：
//     - 指定初始化器的语法是 [下标] = 值，注意方括号和等号的位置
//     - C89 标准不支持该特性！如果编译报错，需确认编译器支持 C99（如 gcc -std=c99）
//     - 下标不能超过数组长度（如数组长度 6，下标最大是 5）
// 
//  4. 对比学习（扩展）：
//     - 传统初始化：必须按顺序赋值，对比指定初始化的灵活性
//     - 自动补 0：和“部分初始化数组”的补 0 特性一致，加深理解
// 
//  5. 拓展思考：
//     - 如果数组是 float 类型，指定初始化后补 0 会变成 0.0 吗？（动手测试）
//     - 如何用指定初始化器初始化二维数组？（提示：arr[行][列] = 值）
// ------------------------------