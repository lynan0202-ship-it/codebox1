
/*
知识要点总结：
1. 复合字面量（C99 特性）：
   - 语法：(类型名){ 初始化列表 }，如 (int[2]){10,20} 创建匿名数组
   - 特性：类型名需明确维度（一维/二维），可省略维度大小（编译器自动计算）
   - 作用域：块作用域，离开定义的块后可能失效，常用于临时传递数组参数
2. 复合字面量的使用场景：
   - 直接传递给函数（无需先定义数组变量）
   - 赋值给指针（如 int *p = (int[3]){1,2,3} ）
   - 初始化指向数组的指针（如二维数组指针 int (*p)[4] = (int[2][4]){{1,2,3,4},{5,6,7,8}} ）
3. 函数参数兼容：
   - 复合字面量可直接作为函数实参，匹配数组形参（如 int arr[] 或 int (*arr)[COLS] ）
   - 演示一维数组、二维数组的复合字面量传递
4. 易错点：
   - 复合字面量是匿名的，不能二次使用（需用指针保存地址）
   - 作用域限制：在函数外使用可能导致未定义行为
   - 编译器支持：需开启 C99 及以上标准（如 gcc -std=c99 ）

代码总体逻辑说明：
1. 定义两个处理数组的函数：
   - sum：处理一维数组，计算元素总和
   - sum2d：处理二维数组（需指定列数 COLS ），计算元素总和
2. 主函数中：
   - 使用复合字面量创建一维数组、二维数组的匿名实例
   - 将复合字面量直接传递给 sum 和 sum2d 函数
   - 同时演示用指针保存复合字面量地址，再传递给函数的用法
3. 输出三个总和（一维数组、二维数组、直接传递复合字面量），验证复合字面量的功能
*/

#include <stdio.h>
#define COLS 4  // 二维数组的列数，用于 sum2d 函数

// 处理一维数组的求和函数
int sum(const int ar[], int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += ar[i];
    }
    return total;
}

// 处理二维数组的求和函数（列数固定为 COLS ）
int sum2d(const int ar[][COLS], int rows) {
    int tot = 0;
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < COLS; c++) {
            tot += ar[r][c];
        }
    }
    return tot;
}

int main(void) {
    // 场景1：一维数组复合字面量直接传递给 sum
    // 复合字面量 (int[]){4,4,4,5,5,5} 作为实参，匹配形参 int ar[]
    int total3 = sum((int[]){4, 4, 4, 5, 5, 5}, 6);

    // 场景2：用指针保存一维复合字面量地址，再传递
    int *pt1 = (int[2]){10, 20};  // 复合字面量 (int[2]){10,20} 的地址存入 pt1
    int total1 = sum(pt1, 2);

    // 场景3：二维数组复合字面量传递给 sum2d
    // 复合字面量 (int[2][COLS]){{1,2,3,-9},{4,5,6,-8}} 匹配形参 int ar[][COLS]
    int (*pt2)[COLS] = (int[2][COLS]){{1, 2, 3, -9}, {4, 5, 6, -8}};
    int total2 = sum2d(pt2, 2);

    // 输出结果，验证复合字面量传递是否正确
    printf("total1 (一维指针传递) = %d\n", total1);
    printf("total2 (二维指针传递) = %d\n", total2);
    printf("total3 (直接传递复合字面量) = %d\n", total3);

    // （拓展）测试作用域外使用复合字面量（危险操作，演示未定义行为）
    // int *p = NULL;
    // {
    //     p = (int[3]){1,2,3};  // 复合字面量在块作用域内
    // }
    // printf("%d\n", *p);  // 离开作用域后，p 指向的内容可能失效

    return 0;
}

/*
测试及验证建议方案：
1. 基础功能验证：
   - 运行代码，检查输出是否与书中示例一致（total1=30, total2=4, total3=27）
   - 修改复合字面量的元素值（如 (int[2]){10,30} ），重新运行验证求和逻辑
2. 编译器兼容性测试：
   - 使用 gcc 编译：`gcc -std=c99 -o compound_literal compound_literal.c`
   - 尝试用 C89 标准编译（`-std=c89`），观察复合字面量相关报错
3. 作用域测试：
   - 取消注释“拓展测试”部分，观察离开块作用域后访问复合字面量的行为（可能输出随机值或崩溃）
   - 在函数内创建复合字面量，返回其指针，主函数中访问（演示未定义行为）
4. 维度匹配测试：
   - 传递列数不匹配的二维复合字面量（如 (int[2][3]){{1,2,3},{4,5,6}} 给 sum2d ），查看编译器警告
   - 省略复合字面量的维度（如 (int[]){1,2,3,4} ），验证编译器自动计算维度的功能
5. 二次使用测试：
   - 尝试用同一个复合字面量传递给多个函数，观察是否影响结果（复合字面量是只读的？不，实际是可修改的，但地址唯一）
   - 用指针保存复合字面量地址后，修改指针指向的值（如 *pt1 = 99 ），查看是否影响函数内的计算
6. 动态维度测试：
   - 用变量作为复合字面量的维度（如 int n=3; (int[n]){1,2,3} ），验证 C99 对变长数组的支持
   - 结合 VLA（变长数组）与复合字面量，传递动态维度的二维数组
*/
/*

### 关键教学点强化说明：
- **复合字面量语法**：通过注释明确 `(类型名){初始化列表}` 的结构，对比变量定义和匿名数组的区别  
- **作用域演示**：特意加入“拓展测试”的注释代码，帮助初学者理解“块作用域内创建，外部访问危险”的特性  
- **编译器指令**：给出具体的 gcc 编译命令，解决“代码编译报错”的常见问题  
- **函数参数匹配**：详细说明复合字面量如何匹配 `int arr[]` 和 `int (*arr)[COLS]` 两种形参，覆盖一维、二维场景  

此代码和测试方案可帮助初学者完整掌握复合字面量的声明、使用、传递规则，解决“临时
数组参数传递”的实际需求，同时规避作用域和未定义行为的风险。
*/