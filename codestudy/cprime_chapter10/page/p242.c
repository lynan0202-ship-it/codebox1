// ------------------------------
// 知识要点总结：
//  1. 数组赋值规则：C 语言不允许直接把一个数组整体赋值给另一个数组（如 yaks = oxen 不行）
//  2. 下标边界问题：数组下标最大是 “数组长度 - 1”，超出会导致越界（如 SIZE 为 5 时，下标 5 越界）
//  3. 初始化与赋值区别：只有初始化时能用 { } 批量赋值，后续赋值只能单个元素操作
//  4. 循环赋值用法：通过下标循环，给数组元素逐个赋值是合法且常用的方式 
// 
// 总体逻辑说明：
//  1. 先演示错误的数组赋值方式（整体赋值、越界赋值、错误批量赋值 ），让编译器报错
//  2. 再写正确的赋值示例：用循环给数组元素逐个赋值，展示合法操作
//  3. 最后遍历数组，输出正确赋值后的结果，验证代码逻辑 
// ------------------------------

#include <stdio.h>
#define SIZE 5  // 定义数组长度，方便修改

int main(void)
{
    // 正确初始化：oxen 用 { } 批量赋值，yaks 先定义后赋值
    int oxen[SIZE] = {5, 3, 2, 8}; 
    int yaks[SIZE];

    // -------------------- 错误赋值演示（初学者别学！） --------------------
    // 错误 1：数组不能直接整体赋值（编译器会报错：数组类型不可赋值）
    // yaks = oxen;  

    // 错误 2：下标越界（SIZE 是 5，下标最大是 4，用 5 会越界）
    // yaks[SIZE] = oxen[SIZE];  

    // 错误 3：非初始化时，不能用 { } 批量赋值（编译器报错：语法错误）
    // yaks[SIZE] = {5, 3, 2, 8};  

    // -------------------- 正确赋值演示 --------------------
    // 合法操作：用循环逐个给 yaks 元素赋值（复制 oxen 的值）
    for (int i = 0; i < SIZE; i++)
    {
        // 单个元素赋值：把 oxen 的值逐个赋给 yaks
        yaks[i] = oxen[i];  
    }

    // 再演示直接修改单个元素（合法操作）
    yaks[2] = 999;  // 把 yaks 下标 2 的元素改成 999

    // -------------------- 遍历数组，输出结果 --------------------
    // 先输出 oxen 的值
    printf("oxen 数组元素：");
    for (int i = 0; i < SIZE; i++)
    {
        printf("%d ", oxen[i]);
    }
    printf("\n");

    // 再输出 yaks 的值，验证赋值结果
    printf("yaks 数组元素：");
    for (int i = 0; i < SIZE; i++)
    {
        printf("%d ", yaks[i]);
    }
    printf("\n");

    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 错误场景测试（看编译器报错）：
//     - 把注释的错误代码取消注释（如 yaks = oxen; ），编译代码
//     - 观察编译器报错信息，记住 “数组不能整体赋值”“下标越界” 等错误提示 
// 
//  2. 正确场景测试（运行程序看结果）：
//     a) 运行代码，检查输出是否有 2 行（oxen 和 yaks 的值）
//     b) 确认 yaks 初始值和 oxen 一致（前 4 个元素是 5,3,2,8 ），但下标 2 被改成 999 
//     c) 核对数组长度：输出 5 个元素（下标 0~4 ），没有越界 
// 
//  3. 易错点提醒：
//     - 别把 “初始化” 和 “赋值” 搞混！只有定义数组时能用 { } 批量赋值 
//     - 写循环时，下标别超过 “SIZE - 1”，否则越界（比如 for 循环条件写成 i <= SIZE ）
//     - 数组整体赋值、越界操作不会让程序直接崩溃，但会导致“未定义行为”（可能程序异常 ） 
// 
//  4. 拓展思考：
//     - 如果想复制数组，除了循环，还有其他方法吗？（提示：可以用 memcpy 函数，需 #include <string.h> ）
//     - 越界赋值时，程序没报错但结果不对，怎么排查？（可打印下标，检查循环条件 ）
//     - 对比 “初始化” 和 “赋值” 的语法，用表格整理两者的区别 
// ------------------------------

