// ------------------------------
// 知识要点总结：
//  1. 数组下标越界问题：C 语言不检查数组下标是否越界，越界访问会导致未定义行为
//  2. 未定义行为的表现：程序可能输出奇怪结果、修改其他变量值、甚至崩溃
//  3. 内存地址观察：通过打印数组越界元素和变量的地址，理解越界访问的本质（破坏其他变量内存）
//  4. 符号常量的作用：用 #define 定义 SIZE，统一管理数组大小
// 
// 总体逻辑说明：
//  1. 定义数组 arr 和两个变量 value1、value2
//  2. 故意用越界下标（-1 到 SIZE）给 arr 赋值，演示未定义行为
//  3. 打印越界赋值前后的变量值，对比观察变化
//  4. 打印数组越界元素和变量的内存地址，验证越界访问如何破坏其他变量
// ------------------------------

#include <stdio.h>
// 定义数组大小，arr 实际有效下标是 0~3（SIZE-1）
#define SIZE 4  

int main(void)
{
    // 定义两个普通变量，用于观察越界访问的影响
    int value1 = 44;  
    int value2 = 88;  
    // 定义长度为 SIZE 的数组，有效下标 0~3
    int arr[SIZE];    
    int i;  // 循环下标变量

    // 打印初始值，记录 value1 和 value2 的原始数据
    printf("value1 = %d, value2 = %d\n", value1, value2);

    // -------------------- 故意越界赋值（初学者别学！） --------------------
    // 下标范围：-1 到 SIZE（超出有效范围 0~3）
    for (i = -1; i <= SIZE; i++)  
    {
        // 越界赋值：arr[i] 会访问非法内存
        arr[i] = 2 * i + 1;  
    }

    // -------------------- 打印越界访问后的数组元素 --------------------
    // 下标范围：-1 到 6（继续越界访问）
    for (i = -1; i < 7; i++)  
    {
        // 打印越界下标和对应的值（可能破坏其他变量）
        printf("%2d %d\n", i, arr[i]);  
    }

    // 打印越界赋值后的变量值，观察是否被修改
    printf("value1 = %d, value2 = %d\n", value1, value2);

    // -------------------- 打印内存地址，验证越界影响 --------------------
    printf("address of arr[-1]: %p\n", &arr[-1]);  
    printf("address of arr[4]: %p\n", &arr[4]);    
    printf("address of value1: %p\n", &value1);    
    printf("address of value2: %p\n", &value2);    

    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础运行测试：
//     - 用 gcc 编译：gcc -o bounds bounds.c（或其他编译器）
//     - 运行程序，观察输出的奇怪结果（如 value1/value2 被修改）
// 
//  2. 地址观察测试：
//     a) 对比 arr[-1]、arr[4] 和 value1、value2 的地址，看是否重叠
//     b) 思考：地址重叠的元素，赋值时如何影响变量值
// 
//  3. 易错点提醒：
//     - 数组下标越界不会报错！但会悄悄破坏其他变量（C 语言信任程序员自己检查边界）
//     - 有效下标范围是 0 ~ SIZE-1，别把循环条件写成 i <= SIZE
//     - 越界访问的结果不确定（不同编译器/环境表现不同），但一定不安全
// 
//  4. 拓展思考：
//     - 如果把数组 arr 定义在 value1、value2 之后，越界访问的影响会变吗？（试试调整变量定义顺序）
//     - 如何修改程序，让数组下标始终安全？（提示：循环条件改为 i < SIZE）
//     - 对比调试模式和 Release 模式的运行结果，观察编译器对未定义行为的优化差异
// ------------------------------