// ------------------------------
// 知识要点总结：
//  1. 二维数组初始化的两种方式：
//     - 完整初始化：用嵌套大括号，每行对应一组数据（推荐，可读性高）
//     - 简化初始化：省略内层大括号，按顺序填充数据（需保证总数量正确）
//  2. 自动补 0 特性：
//     - 每行数据不足时，剩余元素自动补 0
//     - 总行数不足时，剩余行自动补 0（但需注意数组定义的行数）
//  3. 错误处理：
//     - 某行数据过多会报错（超出列数）
//     - 总行数超过定义的行数会报错
//  4. const 修饰数组：表明数组内容只读，初始化后不能修改
// 
// 总体逻辑说明：
//  1. 定义两个二维数组：
//     - rain_full：用完整嵌套大括号初始化（每行显式分组）
//     - rain_simple：用简化方式初始化（省略内层大括号）
//  2. 分别遍历两个数组，输出初始化结果，验证两种方式的效果
//  3. 故意写错误初始化代码（注释掉），让编译器报错，理解错误场景
// ------------------------------

#include <stdio.h>
// 定义二维数组的行数（年数）和列数（月数）
#define YEARS 5  
#define MONTHS 12  

int main(void)
{
    // -------------------- 完整初始化（推荐用法） --------------------
    // 每行用大括号分组，显式对应 1 年的 12 个月
    const float rain_full[YEARS][MONTHS] = {
        // 第 1 行（2010年）：12 个数据，完整初始化
        {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
        // 第 2 行（2011年）：只给 10 个数据，剩余 2 个自动补 0
        {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9},
        // 第 3 行（2012年）：数据过多会报错（注释掉，看错误）
        // {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4, 9.9},
        // 第 4 行（2013年）：完整 12 个数据
        {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
        // 第 5 行（2014年）：完整 12 个数据
        {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
    };

    // -------------------- 简化初始化（省略内层大括号） --------------------
    // 总数据量：YEARS*MONTHS = 5*12=60 个
    // 按顺序填充 60 个数据，省略内层大括号
    const float rain_simple[YEARS][MONTHS] = {
        4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6,  // 第1行数据
        8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,0.0,0.0,    // 第2行数据（补2个0）
        9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4,    // 第3行数据
        7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2,    // 第4行数据
        7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2     // 第5行数据
    };

    // -------------------- 错误初始化演示（初学者别学！） --------------------
    // 错误 1：某行数据过多（超过 MONTHS=12 个）
    // const float rain_error1[YEARS][MONTHS] = {
    //     {1,2,3,4,5,6,7,8,9,10,11,12,13},  // 第1行有13个数据，报错
    // };

    // 错误 2：总行数超过 YEARS=5 个
    // const float rain_error2[5][12] = {
    //     {1,2}, {3,4}, {5,6}, {7,8}, {9,10}, {11,12}  // 6行，超过5行，报错
    // };


    // -------------------- 遍历数组，验证初始化结果 --------------------
    // 遍历 rain_full，输出完整初始化的结果
    printf("=== rain_full（完整初始化） ===\n");
    for (int year = 0; year < YEARS; year++) {
        printf("Year %d: ", 2010 + year);
        for (int month = 0; month < MONTHS; month++) {
            // 输出每个元素，保留1位小数
            printf("%.1f ", rain_full[year][month]);  
        }
        printf("\n");
    }

    // 遍历 rain_simple，输出简化初始化的结果
    printf("\n=== rain_simple（简化初始化） ===\n");
    for (int year = 0; year < YEARS; year++) {
        printf("Year %d: ", 2010 + year);
        for (int month = 0; month < MONTHS; month++) {
            printf("%.1f ", rain_simple[year][month]);
        }
        printf("\n");
    }

    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础功能测试：
//     a) 运行程序，检查两个数组的输出是否一致（两种初始化方式效果相同）
//     b) 观察第2行（2011年）的输出，确认自动补 0（rain_full 第2行最后两个数是 0.0）
// 
//  2. 错误场景测试：
//     a) 取消注释“错误 1”，编译看报错：提示“初始化值过多”
//     b) 取消注释“错误 2”，编译看报错：提示“初始化值过多”（总行数超过定义）
// 
//  3. 易错点提醒：
//     - 简化初始化时，必须保证总数据量 = 行数×列数，否则补 0 逻辑会混乱
//     - 完整初始化时，某行数据不足会补 0，但数据过多会报错
//     - const 数组初始化后不能修改，尝试赋值会编译报错（如 rain_full[0][0] = 5; ）
// 
//  4. 拓展思考：
//     - 如果简化初始化时总数据量不足（如只有 59 个数据），剩余元素会怎么补？
//     - 对比两种初始化方式的可读性，什么时候用简化方式更合适？
//     - 如果数组定义为 float rain[][12]（省略行数），初始化时总行数由数据决定，效果如何？
// ------------------------------