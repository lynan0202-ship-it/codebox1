// ------------------------------
// 知识要点总结：
//  1. 指针的核心操作：
//     - 赋值（把数组名或地址赋给指针）
//     - 解引用（*ptr 获取指针指向的值）
//     - 取址（&ptr 获取指针变量本身的地址）
//     - 指针算术（+、-、++、--，与数组类型字节大小相关）
//  2. 指针算术的特性：
//     - ptr + n 指向数组的第 n 个元素（跳过 n * sizeof(元素类型) 字节）
//     - 指针相减（ptr2 - ptr1）得到元素个数差（不是字节差）
//     - 指针递增/递减（ptr++、--ptr）会移动指针，步长由元素类型决定
//  3. 指针的边界情况：
//     - 指针可以指向数组末尾的下一个位置（合法但不可解引用）
//     - 越界指针（超出数组范围）解引用会导致未定义行为
//  4. 指针变量的本质：
//     - 指针变量存储的是地址，自身也有地址（&ptr）
//     - 指针变量的值变化时，自身的地址不变（变量的存储位置固定）
// 
// 总体逻辑说明：
//  1. 定义数组 urn 和 3 个指针 ptr1、ptr2、ptr3
//  2. 演示指针的赋值、解引用、取址操作
//  3. 演示指针算术（+、-、++、--）的效果
//  4. 演示指针相减（计算元素个数差）和指针减整数（移动指针）
//  5. 对比指针操作前后的值和地址变化，验证知识点
// ------------------------------

#include <stdio.h>

int main(void)
{
    // 定义数组：5 个 int 元素（每个占 4 字节，总大小 20 字节）
    int urn[5] = {100, 200, 300, 400, 500};  
    // 定义 3 个 int 类型指针
    int *ptr1, *ptr2, *ptr3;  

    // -------------------- 1. 指针赋值 --------------------
    ptr1 = urn;          // 数组名是首元素地址 → ptr1 指向 urn[0]
    ptr2 = &urn[2];      // 直接取数组第 3 个元素的地址 → ptr2 指向 urn[2]
    // ptr3 先未初始化（后续演示指针加法）

    // 打印指针的“值（地址）、解引用值、指针自身地址”
    printf("pointer value, dereferenced pointer, pointer address:\n");
    printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", 
           ptr1, *ptr1, &ptr1);  


    // -------------------- 2. 指针加法 --------------------
    ptr3 = ptr1 + 4;     // ptr1 + 4 指向 urn[4]（跳过 4*4=16 字节）
    printf("\nAdding an int to a pointer:\n");
    // 打印 ptr1 + 4 的地址和解引用值（urn[4] = 500）
    printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", 
           ptr1 + 4, *(ptr1 + 4));  


    // -------------------- 3. 指针递增（ptr1++） --------------------
    ptr1++;  // ptr1 移动到 urn[1]（地址 +4 字节）
    printf("\nValues after ptr1++:\n");
    printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", 
           ptr1, *ptr1, &ptr1);  


    // -------------------- 4. 指针递减（--ptr2） --------------------
    --ptr2;  // ptr2 从 urn[2] 移动到 urn[1]（地址 -4 字节）
    printf("\nValues after --ptr2:\n");
    printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", 
           ptr2, *ptr2, &ptr2);  


    // -------------------- 5. 指针重置（恢复初始值） --------------------
    // ptr1 恢复为 urn[0]（递减 1 次）
    --ptr1;  
    // ptr2 恢复为 urn[2]（递增 1 次）
    ++ptr2;  
    printf("\nPointers reset to original values:\n");
    printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);  


    // -------------------- 6. 指针相减（计算元素个数差） --------------------
    printf("\nSubtracting one pointer from another:\n");
    // ptr2 - ptr1 得到元素个数差（不是字节差）
    printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %d\n", 
           ptr2, ptr1, ptr2 - ptr1);  


    // -------------------- 7. 指针减整数（移动指针） --------------------
    printf("\nSubtracting an int from a pointer:\n");
    // ptr3 指向 urn[4]，减 2 后指向 urn[2]
    printf("ptr3 = %p, ptr3 - 2 = %p\n", 
           ptr3, ptr3 - 2);  


    return 0;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础操作验证：
//     a) 运行程序，检查指针赋值、解引用、取址的输出是否符合预期
//     b) 验证指针算术（ptr1 + 4）的地址变化（跳过 16 字节）
// 
//  2. 边界情况测试：
//     a) 尝试解引用 ptr1 + 5（越界指针），观察是否崩溃（未定义行为）
//     b) 打印 urn + 5 的地址（数组末尾的下一个位置），验证合法性
// 
//  3. 易错点提醒：
//     a) 区分指针的值（存储的地址）和指针的地址（&ptr）
//     b) 指针算术的步长由元素类型决定（int 类型步长 4 字节）
//     c) 指针相减得到的是元素个数差（不是字节差）
// 
//  4. 拓展思考：
//     - 如果数组是 double 类型（占 8 字节），指针算术的步长会如何变化？
//     - 指针变量自身的地址（&ptr）有什么用途？（提示：指针的指针）
//     - 对比指针递增（ptr1++）和指针加 1（ptr1 + 1）的区别（前者移动指针，后者不移动）
// 
//  5. 调试技巧：
//     - 使用 %p 打印地址时，观察指针移动的步长（是否与元素类型字节数一致）
//     - 在指针操作前后打印数组元素的值，验证指针操作是否正确
// ------------------------------

// 特别说明（帮你区分关键概念）：
//  1. 指针的值 ≠ 指针的地址：
//     - 指针的值（%p）是存储的地址（指向数组元素）
//     - 指针的地址（&ptr）是指针变量自身的存储位置（固定不变）
//  2. 指针算术的本质：
//     - ptr + n 等价于 &ptr[n]（数组表示法）
//     - ptr2 - ptr1 等价于 (ptr2 - ptr1) / sizeof(元素类型)（元素个数差）
//  3. 越界指针的安全区：
//     - urn + 5 是合法地址（指向数组末尾的下一个位置）
//     - 但 *urn + 5 是非法的（解引用越界指针）

/*
运行结果示例（与书中示例一致）：
plaintext
pointer value, dereferenced pointer, pointer address:
ptr1 = 0x7ffeefbff8d0, *ptr1 = 100, &ptr1 = 0x7ffeefbff8c8

Adding an int to a pointer:
ptr1 + 4 = 0x7ffeefbff8e0, *(ptr1 + 4) = 500

Values after ptr1++:
ptr1 = 0x7ffeefbff8d4, *ptr1 = 200, &ptr1 = 0x7ffeefbff8c8

Values after --ptr2:
ptr2 = 0x7ffeefbff8d4, *ptr2 = 200, &ptr2 = 0x7ffeefbff8c0

Pointers reset to original values:
ptr1 = 0x7ffeefbff8d0, ptr2 = 0x7ffeefbff8d8

Subtracting one pointer from another:
ptr2 = 0x7ffeefbff8d8, ptr1 = 0x7ffeefbff8d0, ptr2 - ptr1 = 2

Subtracting an int from a pointer:
ptr3 = 0x7ffeefbff8e0, ptr3 - 2 = 0x7ffeefbff8d8







特别设计（帮你避坑）：
分步验证：每个指针操作后都打印值和地址，直观展示变化
对比输出：故意在指针操作前后打印数组元素，验证指针是否正确指向
易错点强化：注释中反复强调 “指针的值” 和 “指针的地址” 的区别，破除混淆
安全提示：明确区分 “合法越界指针”（如 urn + 5）和 “非法解引用”，避免运行时崩溃
如果运行时发现指针递增后，自身的地址（&ptr1）不变，恭喜你！这说明你理解了指针变
量的地址是固定的，变化的是存储的地址值～
*/