// ------------------------------
// 知识要点总结：
//  1. 数组传参的本质：数组名作为参数传递时，实际传递的是首元素地址（退化为指针）
//  2. 函数形参的两种写法：
//     - int ar[]：语法糖，本质是 int *ar（提醒读者 ar 指向数组）
//     - int *ar：直接声明指针形参，更直观体现传参本质
//  3. 数组大小的传递：
//     - 必须手动传递数组元素个数（函数无法通过形参获取数组真实大小）
//  4. sizeof 的特性：
//     - 在主函数中，sizeof(数组名) 计算整个数组的字节大小
//     - 在函数中，sizeof(指针形参) 计算的是指针变量的字节大小（与数组真实大小无关）
//  5. 函数形参等价性：
//     - int ar[]、int *ar、int ar[10]（形参中数组大小无意义） 三者等价
// 
// 总体逻辑说明：
//  1. 主函数定义数组 marbles，存储 10 个元素
//  2. 调用 sum 函数，传递数组名（首地址）和元素个数
//  3. sum 函数接收数组指针和元素个数，遍历数组求和
//  4. 对比主函数和 sum 函数中 sizeof 的输出，验证数组传参退化为指针
// ------------------------------

#include <stdio.h>
// 数组元素个数（主函数和 sum 函数共用）
#define SIZE 10  

// 函数声明：两种写法等价（int ar[] 或 int *ar）
int sum(int ar[], int n);  

int main(void)
{
    // 初始化数组：10 个 int 元素（每个占 4 字节，总大小 40 字节）
    int marbles[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};  
    long answer;  // 存储总和（防止 int 溢出）

    // 调用 sum 函数：传递数组名（首地址）和元素个数
    answer = sum(marbles, SIZE);  
    printf("The total number of marbles is %ld.\n", answer);

    // 主函数中 sizeof(marbles)：计算整个数组的字节大小（10*4=40）
    printf("The size of marbles is %zd bytes.\n", sizeof(marbles));  

    return 0;
}

// -------------------- 函数定义：演示数组传参和 sizeof 特性 --------------------
int sum(int ar[], int n)  // int ar[] 等价于 int *ar
{
    int i;
    int total = 0;  // 存储数组元素总和

    // 函数中 sizeof(ar)：计算的是指针变量的字节大小（与数组真实大小无关）
    printf("The size of ar is %zd bytes.\n", sizeof(ar));  

    // 遍历数组，累加元素值（使用 ar[i] 或 *(ar + i) 均可）
    for (i = 0; i < n; i++)
    {
        total += ar[i];
    }

    return total;
}

// ------------------------------
// 测试及验证建议方案：
//  1. 基础功能测试：
//     a) 运行程序，检查总和是否为 190（20+10+5+39+4+16+19+26+31+20）
//     b) 观察主函数和 sum 函数中 sizeof 的输出差异
// 
//  2. 传参本质验证：
//     a) 修改 sum 函数形参为 int ar[10]，重新编译（验证形参大小无意义）
//     b) 尝试在 sum 函数中用 sizeof(ar) 计算数组大小（确认结果为指针大小）
// 
//  3. 易错点提醒：
//     - 函数无法通过形参自动获取数组大小，必须手动传递 n
//     - 主函数中 sizeof(数组名) 是数组总字节数，函数中 sizeof(指针形参) 是指针字节数
//     - int ar[] 和 int *ar 等价，但 int ar[] 更易读（提醒读者 ar 关联数组）
// 
//  4. 拓展思考：
//     - 如果传递的数组元素个数 n 大于实际元素个数，会发生什么？（数组越界访问）
//     - 如何修改函数，让其支持任意类型的数组求和？（提示：使用 void 指针和函数指针）
//     - 对比 “传递数组指针” 和 “传递结构体” 的差异（结构体传参会拷贝整个内容）
// ------------------------------

// 特别说明（给初学者的关键提醒）：
//  1. 数组传参后，函数里的 ar 是指针，不再是数组！
//     - 所以 sum 里的 sizeof(ar) 永远等于指针大小（如 8 字节，取决于系统）
//  2. 形参写 int ar[10] 只是“虚假提示”，实际元素个数由 n 决定
//     - 即使传参时元素个数不是 10，编译器也不会报错（但会有逻辑错误）
//  3. 安全写法：始终手动传递 n，并在函数中严格用 n 控制循环