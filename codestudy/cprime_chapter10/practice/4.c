// ------------------------------
// 题干：编写一个函数，返回存储在 double 类型数组中最大值的下标，并在一个简单的程序中测试该函数。
// 知识要点：
//  1. 数组遍历：通过循环逐个比较元素，记录最大值的下标。
//  2. 指针与下标：数组下标 `arr[i]` 和指针 `*(arr+i)` 等价，可灵活切换。
//  3. 函数返回值：返回 `int` 类型下标，需确保下标有效（数组非空）。
//  4. 边界处理：数组为空或只有一个元素时，下标返回逻辑。
// 总体逻辑：
//  1. 初始化最大值下标为 `0`（假设第一个元素最大）。
//  2. 遍历数组（从第二个元素开始），发现更大值时更新下标。
//  3. 返回最终记录的下标，主函数调用验证。
#include <stdio.h>

// 函数：返回 double 数组最大值的下标
int find_max_index(const double arr[], int len) {
    if (len <= 0) { // 处理空数组（避免访问 arr[0] 越界）
        return -1;  // 用 -1 标记无效下标
    }

    int max_index = 0; // 假设第一个元素是最大值，记录其下标
    for (int i = 1; i < len; i++) {
        if (arr[i] > arr[max_index]) { // 当前元素比之前的最大值大
            max_index = i; // 更新最大值的下标
        }
    }
    return max_index; // 返回最大值的下标
}

int main() {
    // 测试数组（可修改，比如加入负数、重复最大值）
    double scores[] = {89.5, 92.0, 77.3, 95.5, 88.0};
    int len = sizeof(scores) / sizeof(scores[0]); // 计算元素个数

    // 调用函数，获取最大值下标
    int index = find_max_index(scores, len);

    // 输出结果（验证是否正确）
    if (index == -1) {
        printf("数组为空，无最大值下标！\n");
    } else {
        printf("最大值的下标是：%d，对应值为：%.1f\n", index, scores[index]);
    }

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为 `max_index.c`，用 `gcc max_index.c -o max_index` 编译，运行 `./max_index`（Windows 运行 `max_index.exe`）。
//  2. 预期结果：
//     - 对于数组 `{89.5,92.0,77.3,95.5,88.0}`，输出 `下标 3，对应值 95.5`。
//  3. 检查点：
//     - 修改数组（如把 `95.5` 改成 `90.0`，最大值变为 `92.0`，下标应更新为 `1`）。
//     - 测试空数组（`double scores[] = {};`），应输出 `数组为空...`。

// 易错点提醒：
//  1. 忘记处理空数组：若数组长度 `len=0`，函数访问 `arr[0]` 会导致程序崩溃（未定义行为）。
//  2. 下标更新错误：循环中写成 `max_index = arr[i]`（把值赋给下标变量，导致下标变成非法值）。
//  3. 数组长度计算错误：`sizeof(scores)` 是总字节数（如 `5*8=40`），必须除以 `sizeof(scores[0])`（8）得到元素个数 `5`。

// 拓展思考：
//  1. 支持多最大值：返回存储所有最大值下标的数组（如 `int* get_max_indices(...)`），注意动态分配内存和释放。
//  2. 指针遍历版：把 `arr[i]` 换成 `*(arr + i)`，`max_index` 逻辑不变（演示指针和下标的等价性）。
//  3. 同时返回最大值和下标：用结构体 `typedef struct { int index; double value; } Result;` 封装返回值。

// 对比说明：
//  - 下标法 vs 指针法：
//    → 下标法直观（`arr[i]`），指针法灵活（`*(arr+i)` 或 `ptr++`），编译后底层逻辑完全相同。
//  - 返回下标 vs 返回值：
//    → 返回下标更节省内存（`int` 占 4 字节），且可通过下标随时获取对应值；返回值适合直接用结果的场景。