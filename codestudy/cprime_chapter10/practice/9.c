// ------------------------------
// 题干：初始化一个 3×5 的 double 二维数组，用变长数组（VLA）函数拷贝到另一个二维数组，再用 VLA 函数打印两个数组。若编译器不支持 VLA，则处理 N×5 的数组。
// 知识要点：
//  1. 变长数组（VLA）：C99 支持，参数中动态指定数组维度（如 `int arr[n][m]`）。
//  2. 二维数组的拷贝与打印：嵌套循环遍历，外层控制行，内层控制列。
//  3. 函数参数灵活性：VLA 让函数支持任意 N×M 的二维数组，无需固定维度。
// 总体逻辑：
//  1. 定义原始二维数组（3行5列）和目标二维数组（3行5列）。
//  2. 调用 `copy_2d` 函数，用 VLA 参数实现二维数组拷贝。
//  3. 调用 `print_2d` 函数，用 VLA 参数打印原始和目标数组。
//  4. 若编译器不支持 VLA，修改参数为固定列数（如 `double arr[n][5]`）。

#include <stdio.h>

// 变长数组版本：拷贝二维数组（支持任意 N×M）
void copy_2d(int rows, int cols, double target[rows][cols], const double source[rows][cols]) {
    for (int i = 0; i < rows; i++) {      // 遍历行
        for (int j = 0; j < cols; j++) {  // 遍历列
            target[i][j] = source[i][j];  // 逐个拷贝元素
        }
    }
}

// 变长数组版本：打印二维数组（支持任意 N×M）
void print_2d(int rows, int cols, const double arr[rows][cols]) {
    for (int i = 0; i < rows; i++) {      // 遍历行
        for (int j = 0; j < cols; j++) {  // 遍历列
            printf("%.1f ", arr[i][j]);   // 输出元素，保留1位小数
        }
        printf("\n");  // 每行结束换行
    }
}

int main() {
    // 原始二维数组：3行5列
    double original[3][5] = {
        {1.1, 2.2, 3.3, 4.4, 5.5},
        {6.6, 7.7, 8.8, 9.9, 1.0},
        {2.0, 3.0, 4.0, 5.0, 6.0}
    };
    // 目标二维数组：3行5列（未初始化，拷贝后覆盖）
    double target[3][5];
    
    // 拷贝二维数组（调用变长数组函数）
    copy_2d(3, 5, target, original);
    
    // 打印原始数组和目标数组
    printf("原始数组：\n");
    print_2d(3, 5, original);
    
    printf("\n拷贝后的目标数组：\n");
    print_2d(3, 5, target);
    
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为 `ex9.c`，用支持 C99 的编译器编译（如 `gcc -std=c99 ex9.c -o ex9`），运行 `./ex9`。
//  2. 预期结果：
//     - 原始数组和目标数组的内容完全一致，按行打印，每行5个元素。
//  3. 检查点：
//     - 核对每行每列的元素是否与 `original` 数组初始化值一致。

// 易错点提醒：
//  1. 编译器不支持 VLA：若报错，需修改函数参数为固定列数（如 `double arr[n][5]`），适配 `N×5` 数组。
//  2. 循环条件错误：内层循环写成 `j <= cols` 会越界（列下标最大为 `cols-1`）。
//  3. 数组维度传递错误：调用 `copy_2d` 时，`rows` 和 `cols` 需与数组实际维度一致（如3和5）。

// 拓展思考：
//  1. 适配任意维度：若数组是 4×6，只需修改 `main` 中数组定义和函数调用的 `rows`、`cols` 参数。
//  2. 传统方式实现（无 VLA）：将函数参数改为 `double target[n][5]`，仅支持 `N×5` 的数组，灵活性降低。
//  3. 动态分配二维数组：用 `malloc` 分配内存（如 `double **arr = malloc(rows * sizeof(double*))`），函数参数需调整为指针的指针。

// 对比说明：
//  - VLA vs 传统二维数组：
//    → VLA 支持**动态维度**（运行时确定 rows 和 cols），代码更灵活；传统方式需**固定列数**，兼容性好但缺乏灵活性。
//  - 二维拷贝 vs 一维拷贝：
//    → 二维需**嵌套循环**（行+列），一维只需单循环；但核心逻辑都是**逐个元素拷贝**，只是维度不同。