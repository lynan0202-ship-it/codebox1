// ------------------------------
// 题干：编写一个程序，使用指针操作计算单年12个月的降雨量总和与平均值。要求：通过指针接收用户输入的每月降雨量，用指针遍历数组完成计算，最后输出结果。
// 知识要点：
//  1. 指针访问数组：通过指针的移动（ptr++）和解引用（*ptr）操作数组元素，替代下标访问。
//  2. 一维数组遍历：利用指针范围（从首地址到尾地址）控制循环，避免下标越界。
//  3. 基本输入输出：通过指针地址接收用户输入（scanf），格式化输出计算结果（printf）。
//  4. 数值计算：累加求和后计算平均值，注意浮点数转换避免精度丢失。
// 总体逻辑：
//  1. 定义存储12个月降雨量的数组，声明指针并指向数组首元素。
//  2. 使用指针遍历数组，通过scanf接收用户输入的每月降雨量。
//  3. 重置指针到数组开头，再次遍历累加所有元素，计算总和与平均值。
//  4. 打印总和与平均值，验证指针操作的正确性。
#include <stdio.h>

#define MONTHS 12  // 一年的月份数

int main() {
    // 定义存储12个月降雨量的数组（单位：mm）
    float rain[MONTHS];
    // 指针指向数组首元素，后续用指针操作替代下标
    float *ptr = rain;

    // 步骤1：通过指针接收用户输入的每月降雨量
    printf("请输入12个月的降雨量（单位：mm）：\n");
    for (int i = 0; i < MONTHS; i++) {
        // 指针+偏移量表示第i个元素的地址，等价于 &rain[i]
        printf("第%d个月：", i + 1);
        scanf("%f", ptr + i);
    }

    // 步骤2：用指针遍历数组，计算总和
    float total = 0.0;  // 总降雨量
    ptr = rain;  // 重置指针到数组开头（避免之前的偏移影响）
    while (ptr < rain + MONTHS) {  // 指针未超过数组末尾时循环
        total += *ptr;  // 累加当前元素值（*ptr等价于rain[i]）
        ptr++;  // 指针向后移动一个元素（指向 next 月）
    }

    // 步骤3：计算平均值
    float avg = total / MONTHS;

    // 步骤4：输出结果
    printf("\n全年总降雨量：%.2f mm\n", total);
    printf("月平均降雨量：%.2f mm\n", avg);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为`rain.c`，用gcc编译（如`gcc rain.c -o rain`），运行`./rain`（Windows下运行`rain.exe`）。
//     - 输入12个数字（示例：10 20 30 40 50 60 70 80 90 100 110 120）。
//  2. 预期结果：
//     - 总和：10+20+...+120 = 780.00 mm；
//     - 平均值：780 / 12 = 65.00 mm。
//  3. 检查点：
//     - 输入负数（如下雨为0，干旱），观察程序是否正常计算（如输入12个0，总和与平均值均为0）。
//     - 核对输出的总和与手动计算结果是否一致，平均值是否保留2位小数。

// 易错点提醒：
//  1. 指针未重置：输入后指针已指向数组末尾，计算总和前若忘记`ptr = rain`，会导致总和为0（指针越界后访问无效数据）。
//  2. 输入格式错误：`scanf("%f", ptr + i)`中，`ptr + i`已经是地址，不能加`&`（否则变成`&(ptr + i)`，语法错误）。
//  3. 循环条件错误：`while (ptr <= rain + MONTHS)`会让指针越界访问第13个元素（数组下标最大为11），导致结果错误。

// 拓展思考：
//  1. 改为动态数组：用`float *rain = malloc(MONTHS * sizeof(float))`，体验完全用指针管理数组（最后需`free(rain)`）。
//  2. 增加月份名称：定义字符串数组`char *months[] = {"一月", ..., "十二月"}`，输入输出时显示月份名，更直观。
//  3. 筛选最大降雨量：在遍历过程中记录最大值，用指针比较`if (*ptr > max) max = *ptr`，一次遍历完成多任务。

// 对比说明：
//  - 指针操作 vs 下标操作：
//    → 指针操作（`*ptr`）和下标操作（`rain[i]`）本质相同，都是通过地址访问元素，编译后生成的机器码一致。
//    → 指针更适合连续内存的灵活遍历（如`ptr += 3`跳过3个月），下标更直观（一眼看出是第几个元素），按需选择。
//  - 固定数组 vs 变长数组：
//    → 本题用`#define`固定为12个月，若改为用户输入年份的月份数（如闰年13个月，假设），可改用VLA：`int n; scanf("%d", &n); float rain[n];`，更灵活。