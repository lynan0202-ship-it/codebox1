// ------------------------------
// 题干：使用编程练习2中的拷贝函数，把一个内含7个元素的数组中第3～第5个元素拷贝至内含3个元素的数组中。
// 知识要点：
//  1. 数组元素地址：通过 `&arr[i]` 或 `arr+i` 获取元素的地址（指针操作）。
//  2. 函数参数灵活传递：无需传递整个数组，只需传递部分元素的起始地址和个数。
//  3. 代码复用：直接使用编程练习2的拷贝函数（如 `copy_arr`），避免重复开发。
// 总体逻辑：
//  1. 定义源数组（7个元素）和目标数组（3个元素）。
//  2. 定位源数组的起始位置：第3个元素对应下标`2`，地址为 `src+2`。
//  3. 调用拷贝函数，传递目标数组、源起始地址、拷贝个数（3个）。
//  4. 输出目标数组，验证拷贝结果是否正确。

#include <stdio.h>

// 复用编程练习2的拷贝函数（数组表示法实现）
void copy_arr(double target[], const double source[], int n) {
    for (int i = 0; i < n; i++) {
        target[i] = source[i]; // 逐个拷贝元素
    }
}

int main() {
    // 源数组：7个元素（下标0~6）
    double src[7] = {1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7};
    // 目标数组：存储3个元素
    double dest[3];
    
    // 拷贝第3~5个元素（下标2、3、4，共3个元素）
    // 源起始地址：src + 2（指向src[2]），拷贝个数：3
    copy_arr(dest, src + 2, 3); 
    
    // 输出目标数组，验证结果
    printf("目标数组内容：");
    for (int i = 0; i < 3; i++) {
        printf("%.1f ", dest[i]); // 输出：3.3 4.4 5.5
    }
    printf("\n");
    
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为 `ex8.c`，用 `gcc ex8.c -o ex8` 编译，运行 `./ex8`（Windows 运行 `ex8.exe`）。
//  2. 预期结果：
//     - 目标数组输出 `3.3 4.4 5.5`（对应源数组下标2~4的元素）。
//  3. 检查点：
//     - 核对输出值是否与源数组的 `src[2]`、`src[3]`、`src[4]` 一致。

// 易错点提醒：
//  1. 下标计算错误：第3个元素的下标是`2`（不是3），若写成 `src+3` 会导致拷贝 `4.4、5.5、6.6`，结果错误。
//  2. 目标数组越界：若目标数组大小小于3（如 `double dest[2]`），会导致程序崩溃，需确保目标数组足够大。
//  3. 函数参数类型：`src+2` 是 `double*` 类型，与 `copy_arr` 的 `source` 参数匹配，无需强转。

// 拓展思考：
//  1. 用 `copy_ptrs` 实现（需先实现该函数）：
//     → `copy_ptrs(dest, src+2, src+5);`（尾指针为 `src+5`，因为 2+3=5）。
//  2. 动态指定拷贝范围：让用户输入起始下标和个数，计算 `start = src + input_start` 和 `n = input_count`，再调用函数。
//  3. 安全校验：添加 `if (2 + 3 > 7)` 判断，避免拷贝超出源数组范围（如起始下标+个数超过7）。

// 对比说明：
//  - 部分拷贝 vs 整体拷贝：
//    → 整体拷贝传递**数组名（首元素地址）**和**总个数**；部分拷贝传递**部分元素的起始地址**和**子数组个数**，本质都是**指针传递**，函数内部逻辑完全复用。
//  - 不同拷贝函数的适配：
//    → `copy_arr` 适合**已知个数**的场景，`copy_ptrs` 适合**已知尾指针**的场景，只需调整参数即可复用，体现代码灵活性。