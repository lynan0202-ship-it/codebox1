// ------------------------------
// 题干：编写一个函数，计算 int 类型二维数组每行的总和，将结果存储在一个一维数组中返回，并在程序中测试该函数。
// 知识要点：
//  1. 二维数组的参数传递：作为函数参数时需指定第二维大小（如 int arr[][4]）。
//  2. 嵌套循环遍历：外层循环控制行，内层循环控制列，逐行累加元素。
//  3. 一维数组作为返回结果：通过指针传递一维数组，在函数中修改其值（函数无法直接返回数组，需用指针接收）。
//  4. 数组下标访问：通过 row（行）和 col（列）下标访问二维数组元素。
// 总体逻辑：
//  1. 主函数定义二维数组和存储结果的一维数组。
//  2. 调用求和函数，传入二维数组、行数、列数和结果数组指针。
//  3. 函数内逐行遍历，累加每行元素的和，存入结果数组。
//  4. 主函数打印结果数组，验证每行总和是否正确。
#include <stdio.h>

// 函数：计算二维数组每行的总和，结果存到 result 中
// arr：二维数组（第二维固定为 4）；rows：行数；cols：列数；result：存储每行总和的一维数组
void row_sum(int arr[][4], int rows, int cols, int result[]) {
    for (int row = 0; row < rows; row++) { // 遍历每一行
        int sum = 0; // 记录当前行的总和
        for (int col = 0; col < cols; col++) { // 遍历当前行的每一列
            sum += arr[row][col]; // 累加当前元素到 sum
        }
        result[row] = sum; // 把当前行的总和存到 result 对应位置
    }
}

int main() {
    // 定义一个 3 行 4 列的二维数组（测试数据）
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    int rows = 3; // 行数
    int cols = 4; // 列数
    int row_sums[rows]; // 存储每行总和的一维数组

    // 调用函数计算每行总和
    row_sum(matrix, rows, cols, row_sums);

    // 打印结果，验证正确性
    printf("二维数组每行的总和：\n");
    for (int i = 0; i < rows; i++) {
        printf("第 %d 行总和：%d\n", i + 1, row_sums[i]);
    }

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为 `row_sum.c`，用 `gcc row_sum.c -o row_sum` 编译，运行 `./row_sum`（Windows 运行 `row_sum.exe`）。
//  2. 预期结果：
//     - 第 1 行总和：1+2+3+4=10；第 2 行：5+6+7+8=26；第 3 行：9+10+11+12=42，输出对应结果。
//  3. 检查点：
//     - 修改二维数组元素（如 matrix[0][0] = 10），重新运行，观察总和是否同步更新。
//     - 测试不同行数（如 2 行），检查函数是否适配。

// 易错点提醒：
//  1. 二维数组传参漏写第二维大小：如写成 `int arr[][]` 会编译错误，必须指定第二维（如 `[][4]`）。
//  2. 循环条件错误：内层循环写成 `col <= cols` 会越界（列下标最大为 cols-1）。
//  3. 结果数组未初始化：但函数会直接赋值，不影响结果，不过最好在主函数初始化为 0 更规范。

// 拓展思考：
//  1. 如何计算每列的总和？只需交换循环顺序（外层列、内层行），结果数组大小改为列数。
//  2. 若二维数组是动态分配的（如 int **arr），函数参数需如何修改？需传递每行的指针，遍历方式类似。
//  3. 用变长数组（VLA）支持任意列数：函数参数改为 `int rows, int cols, int arr[rows][cols]`（需 C99 支持）。

// 对比说明：
//  - 行遍历 vs 列遍历：
//    → 行遍历外层是行，适合按行处理数据；列遍历外层是列，适合按列统计，核心都是嵌套循环，只是顺序不同。
//  - 固定列数 vs 变长数组：
//    → 固定列数兼容性好（支持老编译器），但不灵活；VLA 可动态适应列数，更灵活但依赖 C99+。