// ------------------------------
// 题干：编写一个函数，返回存储在 int 类型数组中的最大值，并在一个简单的程序中测试该函数。
// 知识要点：
//  1. 函数定义：设计返回值为 int、参数含数组和长度的函数，避免数组越界。
//  2. 数组遍历：通过循环逐个比较元素，利用“假设法”初始化最大值（先取第一个元素）。
//  3. 函数调用：主函数中通过数组名（退化为指针）和长度传参，接收返回值。
// 总体逻辑：
//  1. 主函数初始化测试数组，计算其长度（避免硬编码，增强通用性）。
//  2. 调用 `find_max` 函数，传入数组和长度，获取最大值。
//  3. 函数内从第二个元素开始遍历，逐次比较更新最大值。
//  4. 主函数打印结果，验证逻辑正确性。
#include <stdio.h>

// 找数组最大值的函数
// arr：要遍历的数组（函数内退化为指针）
// len：数组元素个数（必须准确，否则越界）
int find_max(const int arr[], int len) {
    // 假设第一个元素是最大值（初始化）
    int max = arr[0];  
    // 从第二个元素开始比较（下标从 1 开始）
    for (int i = 1; i < len; i++) { 
        if (arr[i] > max) {         // 如果当前元素比 max 大
            max = arr[i];           // 更新 max 为当前元素
        }
    }
    return max; // 返回最终的最大值
}

int main() {
    // 测试数组（可修改元素，比如加负数、重复值）
    int numbers[] = {12, 45, 7, 99, 32, 56}; 
    // 计算数组长度：总字节数 ÷ 单个元素字节数
    int len = sizeof(numbers) / sizeof(numbers[0]); 
    
    // 调用函数，获取最大值
    int max_value = find_max(numbers, len); 
    
    // 输出结果（方便观察是否正确）
    printf("数组中的最大值是：%d\n", max_value);
    
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为 `max_int.c`，用命令 `gcc max_int.c -o max_int` 编译，运行 `./max_int`（Windows 下运行 `max_int.exe`）。
//  2. 预期结果：
//     - 对于数组 `{12,45,7,99,32,56}`，输出 `99`。
//  3. 检查点：
//     - 修改数组元素（比如把 `99` 改成 `100`，或加入负数 `-1`），重新运行，观察结果是否同步更新。

// 易错点提醒：
//  1. 长度计算错误：忘记写 `sizeof(numbers[0])`，直接用 `sizeof(numbers)` 会导致 `len` 变成“总字节数”（比如数组占 24 字节，`len=24` 而非 6），循环越界。
//  2. 循环起始错误：如果 `i` 从 `0` 开始，第一次比较 `arr[0]` 和 `arr[0]`，虽不影响结果，但多一次无效比较。
//  3. 数组为空：若数组 `len=0`（如 `int numbers[] = {};`），函数会访问 `arr[0]` 导致未定义行为，需提前判断。

// 拓展思考：
//  1. 处理空数组：在 `find_max` 里加 `if (len <= 0) return -1;`（或其他标记值），主函数判断返回值。
//  2. 指针遍历：把循环里的 `arr[i]` 改成 `*(arr + i)`，效果完全相同（演示指针和下标的等价性）。
//  3. 同时找最大最小值：让函数返回结构体（含 `max` 和 `min`），或通过指针参数带回 `min`（如 `void find_max_min(..., int *min)`）。

// 对比说明：
//  - 下标访问 vs 指针访问：
//    → 语法不同，本质一样（`arr[i]` 等价于 `*(arr + i)`）。下标更直观，指针更灵活（比如指针可手动移动 `arr++`，但数组名作为参数时是**常量指针**，不能直接 `arr++`）。
//  - 假设法初始化 vs 初始化为极小值：
//    → 本题用 `arr[0]` 初始化，适合数组非空的情况；若数组可能为空，可初始化为 `INT_MIN`（需 `#include <limits.h>`），更通用。