// ------------------------------
// 题干：编写函数，将两个 int 数组的对应元素相加，结果存入第三个数组。测试该函数（如数组1: {2,4,5,8}，数组2: {1,0,4,6}，结果: {3,4,9,14}）。
// 知识要点：
//  1. 数组遍历：单循环遍历数组，逐元素计算。
//  2. 函数参数：三个数组（指针传递）和长度，实现数据复用。
//  3. 下标操作：通过 `arr[i]` 访问元素，本质是指针解引用。
// 总体逻辑：
//  1. 主函数定义两个源数组和一个目标数组，初始化值。
//  2. 调用 `add_arrays` 函数，逐元素计算 `target[i] = a[i] + b[i]`。
//  3. 打印三个数组，验证求和结果。
#include <stdio.h>

// 函数：两个数组对应元素求和，存入第三个数组
void add_arrays(const int a[], const int b[], int target[], int n) {
    for (int i = 0; i < n; i++) {
        target[i] = a[i] + b[i]; // 对应位置相加
    }
}

int main() {
    // 初始化两个源数组（示例数据）
    int arr1[] = {2, 4, 5, 8};
    int arr2[] = {1, 0, 4, 6};
    int result[4]; // 存储结果的数组（长度与源数组一致）
    int len = sizeof(arr1) / sizeof(arr1[0]); // 计算数组长度

    // 调用求和函数
    add_arrays(arr1, arr2, result, len);

    // 打印三个数组，验证结果
    printf("数组1：");
    for (int i = 0; i < len; i++) {
        printf("%d ", arr1[i]);
    }
    printf("\n数组2：");
    for (int i = 0; i < len; i++) {
        printf("%d ", arr2[i]);
    }
    printf("\n结果数组：");
    for (int i = 0; i < len; i++) {
        printf("%d ", result[i]); // 预期：3 4 9 14
    }
    printf("\n");

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：编译后直接运行（如 `gcc ex10.c -o ex10 && ./ex10`）。
//  2. 预期结果：结果数组输出 `3 4 9 14`，与题目示例一致。
//  3. 检查点：核对每个位置的和是否正确（如 2+1=3，4+0=4 等）。

// 易错点提醒：
//  1. 数组长度计算错误：若源数组长度不同（如 arr1 长度4，arr2 长度5），会导致越界，需确保长度一致。
//  2. 函数参数顺序写错：把 `target` 写成 `a` 或 `b`，导致源数组被覆盖。
//  3. 循环条件越界：`i <= len` 会访问不存在的元素（下标最大为 len-1）。

// 拓展思考：
//  1. 支持不同长度的数组：计算最小长度 `min_len = len1 < len2 ? len1 : len2`，只计算前 min_len 个元素。
//  2. 动态分配结果数组：用 `int *result = malloc(len * sizeof(int))`，避免固定数组长度。
//  3. 扩展为浮点数：将数组类型改为 `double`，函数参数和运算同步修改。

// 对比说明：
//  - 与“数组拷贝”对比：拷贝是 `target[i] = a[i]`，求和是 `target[i] = a[i] + b[i]`，核心都是**遍历+赋值**，逻辑相似但运算不同。
//  - 值传递 vs 指针传递：数组传参是**指针传递**（实际传递地址），函数内修改 `target` 会直接影响主函数的数组（此处是赋值，无问题；若修改 `a` 或 `b`，会破坏源数据，故用 `const` 保护）。