// ------------------------------
// 题干：编写程序，处理 3×5 的 int 数组：
//  a. 计算每个元素的立方，存入新数组；
//  b. 计算所有元素的平均值；
//  c. 找出15个元素的最大值；
//  d. 打印原始数组、立方数组、平均值、最大值。
// 知识要点：
//  1. 二维数组遍历：嵌套循环（行+列），用下标或指针访问元素。
//  2. 多结果处理：通过数组存储立方结果，变量存储平均值和最大值。
//  3. 函数化扩展：可拆分 `cube_array`、`calc_avg`、`find_max` 函数（本题为简洁，直接写逻辑）。
// 总体逻辑：
//  1. 初始化 3×5 原始数组，声明立方数组、平均值、最大值变量。
//  2. 嵌套循环：
//     - 计算立方（`cube[i][j] = arr[i][j] * arr[i][j] * arr[i][j]`）；
//     - 累加总和（计算平均值）；
//     - 比较最大值。
//  3. 打印所有结果，验证正确性。

#include <stdio.h>

int main() {
    // 初始化 3×5 原始数组（示例值）
    int original[3][5] = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15}
    };
    int cube[3][5] = {0}; // 存储立方结果
    double sum = 0.0;     // 总和（计算平均值）
    int max_val = original[0][0]; // 最大值（初始化为第一个元素）
    int rows = 3, cols = 5;       // 行列数

    // 遍历二维数组，完成三个任务：立方、求和、找最大值
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            // 【a】计算立方
            int val = original[i][j];
            cube[i][j] = val * val * val; 

            // 【b】累加总和（用于计算平均值）
            sum += val;

            // 【c】更新最大值
            if (val > max_val) {
                max_val = val;
            }
        }
    }

    // 计算平均值
    double avg = sum / (rows * cols); // 15个元素

    // 【d】打印结果
    printf("=== 原始数组 ===\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d\t", original[i][j]);
        }
        printf("\n");
    }

    printf("\n=== 立方数组 ===\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d\t", cube[i][j]);
        }
        printf("\n");
    }

    printf("\n=== 统计结果 ===\n");
    printf("平均值：%.2f\n", avg);   // 预期：(1+2+...+15)/15 = 8.0
    printf("最大值：%d\n", max_val); // 预期：15

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：编译后直接运行（如 `gcc ex13.c -o ex13 && ./ex13`）。
//  2. 预期结果：
//     - 立方数组：1³=1，2³=8，…，15³=3375；
//     - 平均值：8.00；最大值：15。
//  3. 检查点：核对立方值、平均值、最大值是否正确。

// 易错点提醒：
//  1. 立方计算溢出：若元素大（如 100），int 可能溢出，需改用 `long long` 存储立方结果。
//  2. 平均值类型错误：`sum` 是 `double`，但 `rows*cols` 是 int，需确保除法是浮点数运算（如 `sum / 15.0`）。
//  3. 最大值初始化错误：若数组元素全为负，初始值 `original[0][0]` 可能不是最大值，需正确初始化（如 `INT_MIN`）。

// 拓展思考：
//  1. 函数化重构：将立方、求和、找最大值拆分为独立函数（如 `void calc_cube(int cube[][5], const int original[][5], int rows)`）。
//  2. 动态二维数组：用变长数组（`int rows=3, cols=5; int arr[rows][cols]`），支持任意行列数。
//  3. 同时找最小值：添加 `min_val` 变量，遍历中同时更新，对比最大值逻辑。

// 对比说明：
//  - 单循环 vs 嵌套循环：
//    → 二维数组必须用嵌套循环（行+列），一维数组用单循环，本质是维度差异导致的遍历复杂度不同。
//  - 多任务合并 vs 拆分：
//    → 本题合并在一个嵌套循环中，效率更高（一次遍历完成多个任务）；拆分函数更易维护，适合复杂逻辑。