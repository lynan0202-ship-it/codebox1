// ------------------------------
// 题干：编写一个函数，找出 int 类型二维数组中的最大值，并返回其行下标和列下标（通过指针参数带回），在程序中测试该函数。
// 知识要点：
//  1. 指针参数带回多个结果：函数无法返回多个值，通过指针参数（如 int *row_ptr）存储行/列下标。
//  2. 二维数组全遍历：嵌套循环遍历所有元素，比较找出最大值。
//  3. 初始值设置：假设第一个元素为最大值，后续元素逐个比较更新。
//  4. 指针解引用赋值：通过 `*row_ptr = row` 修改主函数中的变量。
// 总体逻辑：
//  1. 主函数定义二维数组，声明存储最大值位置的变量（row, col）。
//  2. 调用函数，传入二维数组、行数、列数和 row、col 的指针。
//  3. 函数内遍历所有元素，找到最大值时记录其行/列下标，通过指针传回。
//  4. 主函数打印最大值及其位置，验证结果。
#include <stdio.h>

// 函数：查找二维数组最大值，通过指针带回其行下标和列下标
// arr：二维数组；rows/cols：行数/列数；row_ptr/col_ptr：存储结果的指针
int find_max_pos(int arr[][3], int rows, int cols, int *row_ptr, int *col_ptr) {
    if (rows <= 0 || cols <= 0) { // 处理空数组
        *row_ptr = -1;
        *col_ptr = -1;
        return -1; // 用 -1 标记无效值
    }

    int max_val = arr[0][0]; // 假设第一个元素是最大值
    *row_ptr = 0;            // 初始行下标
    *col_ptr = 0;            // 初始列下标

    for (int row = 0; row < rows; row++) { // 遍历所有行
        for (int col = 0; col < cols; col++) { // 遍历所有列
            if (arr[row][col] > max_val) { // 当前元素更大
                max_val = arr[row][col];   // 更新最大值
                *row_ptr = row;            // 更新行下标（通过指针）
                *col_ptr = col;            // 更新列下标（通过指针）
            }
        }
    }
    return max_val; // 返回最大值
}

int main() {
    // 定义一个 2 行 3 列的二维数组（测试数据）
    int matrix[2][3] = {
        {15, 8, 22},
        {10, 30, 5}
    };
    int rows = 2;
    int cols = 3;
    int max_row, max_col; // 存储最大值的行、列下标

    // 调用函数，传入 max_row 和 max_col 的地址
    int max_val = find_max_pos(matrix, rows, cols, &max_row, &max_col);

    // 打印结果
    if (max_row == -1) {
        printf("数组为空，无最大值！\n");
    } else {
        printf("最大值是：%d，位于第 %d 行，第 %d 列（下标从 0 开始）\n", 
               max_val, max_row, max_col);
    }

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：
//     - 保存为 `max_pos.c`，用 `gcc max_pos.c -o max_pos` 编译，运行 `./max_pos`（Windows 运行 `max_pos.exe`）。
//  2. 预期结果：
//     - 数组中最大值是 30，位于行 1、列 1，输出对应结果。
//  3. 检查点：
//     - 修改数组（如 matrix[1][1] = 50），重新运行，确认位置和值同步更新。
//     - 测试有多个最大值的情况（如两个 30），检查是否返回第一个出现的位置。

// 易错点提醒：
//  1. 忘记传指针：调用函数时写成 `find_max_pos(..., max_row, max_col)` 会导致结果错误（传值无法修改主函数变量）。
//  2. 初始值设置错误：若数组元素全为负数，初始值设为 0 会出错，必须用数组第一个元素初始化。
//  3. 越界访问：循环条件写成 `row <= rows` 会访问不存在的行，导致结果错误。

// 拓展思考：
//  1. 如何返回所有最大值的位置？用二维数组存储多个 (row, col)，返回其地址（注意动态分配内存）。
//  2. 适配任意列数：用变长数组 `int arr[rows][cols]` 作为参数（需 C99 支持）。
//  3. 用结构体返回结果：定义 `struct { int val; int row; int col; }` 封装最大值和位置，函数返回该结构体。

// 对比说明：
//  - 指针带回结果 vs 结构体返回：
//    → 指针方式适合少量结果（2-3 个），简洁；结构体适合多个相关结果，代码更清晰，无需记指针参数顺序。
//  - 二维数组遍历 vs 一维数组遍历：
//    → 二维需嵌套循环（行+列），一维只需单循环，本质都是逐个比较，只是维度不同。