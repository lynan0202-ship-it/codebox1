// ------------------------------
// 题干：修改程序清单10.7的 rain.c 程序，用指针进行计算（仍声明并初始化数组，用指针代替下标 操作）。
// 知识要点：
//  1. 指针遍历数组：通过 `ptr++` 移动指针，`*ptr` 访问元素。
//  2. 数组与指针等价性：`arr[i]` 等价于 `*(arr+i)`，指针操作更灵活。
//  3. 输入输出：通过指针接收用户输入，计算总和/平均值。
// 总体逻辑：
//  1. 声明雨量数组 `rain` 和指针 `ptr`，让 `ptr` 指向数组首元素。
//  2. 用指针遍历，通过 `scanf` 录入每月雨量（替代下标 `rain[i]`）。
//  3. 用指针遍历求和，计算平均值，打印结果。

#include <stdio.h>

int main() {
    // 月份：12个月的降雨量（示例初始值，实际可改为用户输入）
    double rain[12] = {0.0}; 
    double *ptr = rain;       // 指针指向数组首元素
    double sum = 0.0;         // 总降雨量
    int months = 12;          // 月份数

    // 【1】用指针录入数据（替代下标 rain[i]）
    printf("请输入12个月的降雨量（单位：mm）：\n");
    for (int i = 0; i < months; i++) {
        // ptr+i 等价于 &rain[i]，*ptr 等价于 rain[i]
        scanf("%lf", ptr + i); 
    }

    // 【2】用指针求和（遍历数组）
    for (ptr = rain; ptr < rain + months; ptr++) { 
        sum += *ptr; // *ptr 访问当前元素值，累加
    }

    // 【3】计算并打印结果
    double avg = sum / months;
    printf("\n全年总降雨量：%.2f mm\n", sum);
    printf("月平均降雨量：%.2f mm\n", avg);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：编译后运行（如 `gcc ex12.c -o ex12 && ./ex12`），输入12个数字（如 `10 20 ...`）。
//  2. 预期结果：输出总降雨量和平均值，与手动计算一致。
//  3. 检查点：
//     - 输入 `1 2 3 4 5 6 7 8 9 10 11 12`，总和应为 78，平均 6.5。
//     - 观察指针操作是否替代了下标，程序逻辑是否正确。

// 易错点提醒：
//  1. 指针越界：`ptr < rain + months` 是正确边界，若写成 `ptr <= rain + months` 会越界（访问第13个元素）。
//  2. 输入格式错误：`scanf("%lf", ptr + i)` 中，`ptr + i` 是地址，无需加 `&`（否则变成“地址的地址”，导致错误）。
//  3. 指针重复使用：求和时 `ptr` 被修改，需重新指向 `rain` 首元素（`ptr = rain`）。

// 拓展思考：
//  1. 用指针逆序遍历：从 `rain + 11` 开始，`ptr--` 遍历，计算最后6个月的总和。
//  2. 动态分配数组：用 `double *rain = malloc(12 * sizeof(double))`，体验指针完全操作数组（无下标）。
//  3. 对比下标和指针：将代码中指针操作改回下标，观察编译后的汇编代码是否相似（本质相同）。

// 对比说明：
//  - 下标 vs 指针：
//    → 下标更直观（`rain[i]`），指针更灵活（可自由移动，如 `ptr += 3` 跳过元素）。
//    → 编译后，两者生成的机器码几乎一样（下标本质是指针运算 `*(rain + i)`）。