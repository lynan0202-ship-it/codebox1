// ------------------------------
// 题干：声明 3×5 的 int 二维数组，初始化后打印；再将每个元素翻倍，再次打印。需实现 `print_array`（打印数组）和 `double_array`（翻倍元素）函数。
// 知识要点：
//  1. 二维数组遍历：嵌套循环（外层行，内层列）。
//  2. 函数参数：二维数组需指定第二维大小（如 `int arr[][5]`），否则编译错误。
//  3. 数组修改：函数通过指针修改主函数的数组（二维数组传参是指针传递）。
// 总体逻辑：
//  1. 主函数定义并初始化 3×5 二维数组。
//  2. 调用 `print_array` 打印初始值。
//  3. 调用 `double_array` 逐元素翻倍（`arr[i][j] *= 2`）。
//  4. 再次调用 `print_array` 打印翻倍后的值。
#include <stdio.h>

// 函数：打印 3×5 二维数组
void print_array(const int arr[][5], int rows) {
    for (int i = 0; i < rows; i++) { // 遍历行
        for (int j = 0; j < 5; j++) { // 遍历列
            printf("%d ", arr[i][j]);
        }
        printf("\n"); // 每行结束换行
    }
}

// 函数：将二维数组每个元素翻倍
void double_array(int arr[][5], int rows) {
    for (int i = 0; i < rows; i++) { // 遍历行
        for (int j = 0; j < 5; j++) { // 遍历列
            arr[i][j] *= 2; // 元素翻倍（直接修改原数组）
        }
    }
}

int main() {
    // 初始化 3×5 二维数组（示例值）
    int matrix[3][5] = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15}
    };
    int rows = 3; // 行数

    // 打印初始值
    printf("二维数组初始值：\n");
    print_array(matrix, rows);

    // 元素翻倍
    double_array(matrix, rows);

    // 打印翻倍后的值
    printf("\n元素翻倍后：\n");
    print_array(matrix, rows);

    return 0;
}

// 测试验证方案：
//  1. 怎么运行：编译后直接运行（如 `gcc ex11.c -o ex11 && ./ex11`）。
//  2. 预期结果：
//     - 初始值：每行 5 个元素，如第一行 `1 2 3 4 5`。
//     - 翻倍后：每个元素是原值的 2 倍，如第一行 `2 4 6 8 10`。
//  3. 检查点：核对每行每列的元素是否正确翻倍。

// 易错点提醒：
//  1. 二维数组传参错误：若函数参数写成 `int arr[][]`（未指定第二维），会编译错误，必须显式写第二维（如 `[][5]`）。
//  2. 循环范围错误：行循环写成 `i <= rows`（最大行下标是 rows-1，如 3 行时下标 0~2）。
//  3. 函数修改源数组：`double_array` 直接修改原数组，若需保留原值，需先拷贝再修改（可复用第2题的拷贝函数）。

// 拓展思考：
//  1. 支持任意大小的二维数组（变长数组，C99+）：
//     → 函数参数改为 `int rows, int cols, int arr[rows][cols]`，调用时传入行列数。
//  2. 递归实现翻倍：对每行递归处理，直到行号超过 rows-1（练习递归思维）。
//  3. 同时返回最大值：在 `double_array` 中记录最大值，通过指针参数带回（如 `int *max_ptr`）。

// 对比说明：
//  - 二维遍历 vs 一维遍历：
//    → 二维需**嵌套循环**（行+列），一维只需单循环；但核心都是**逐个元素处理**，逻辑可复用（如把二维拆分为多个一维处理）。
//  - 固定维度 vs 变长数组：
//    → 固定维度（`[][5]`）兼容性好，适合已知列数的场景；变长数组（VLA）更灵活，支持任意行列数，但依赖 C99+ 编译器。