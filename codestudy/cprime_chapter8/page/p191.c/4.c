/*


### 五、【初学者实践建议】  
1. **文件操作部分**：  
   - 先跑通“代码示例 1”，换不同文件测试（比如 `.txt` 文本、自己写的代码文件），看输出是否和文件内容一致。  
   - 故意输错文件名，观察 `fopen` 返回 `NULL` 时程序如何报错，理解“文件打开失败处理”的重要性。  

2. **用户交互部分**：  
   - 改“示例 2”里的 `target` 值，试试输入非法内容（比如字母），看 `scanf` 返回值怎么变化，理解输入校验逻辑。  
   - 扩展“示例 2”：把 `target` 改成用 `rand()` 生成随机数（记得加 `#include <stdlib.h>` 和 `srand(time(0))` 初始化随机种子），做成完整猜数字游戏。  

3. **输出重定向部分**：  
   - 跑“示例 3”，输入文件名后，到对应路径找文件，打开看内容是否和你输入的一致，感受“程序输出写入文件”的效果。  
   - 把 `fopen` 模式从 `"w"` 改成 `"a"`，多运行几次程序，观察文件是“覆盖内容”还是“追加内容”。  


这样一套代码 + 注释 + 实践指引，能帮初学者把“输入输出重定向”的概念落地到 C 语言代码里，同时掌握文件操作、基础用户交互的核心逻辑。遇到问题多调试（比如看变量值、看文件是否真的创建/读写成功），慢慢就熟悉啦～
*/

/*
在这段代码中，`fp = NULL` 的作用和后续再次打开文件时的情况可以这样理解：


### 1. `fp = NULL` 的作用  
`fp` 是一个文件指针，当用 `fclose(fp)` 关闭文件后，这个指针本身并不会自动变成 `NULL`，
它仍然会保留之前指向的内存地址（但这个地址已经无效了，因为文件已经关闭）。  

这时候如果不小心再次使用这个指针（比如误写 `fputs("abc", fp)`），程序会试图访问一个已经失效的地址，
可能导致**程序崩溃**或**不可预知的错误**（这种指针被称为“野指针”）。  

而 `fp = NULL` 就是为了**避免野指针风险**：把指针明确指向空地址后，
即使后续不小心误用，程序通常能检测到 `NULL` 指针并报错（比崩溃更容易调试）。  


### 2. 下一次打开文件时，`fp` 的值还会是 `NULL` 吗？  
**不会**。  

当你再次调用 `fopen` 打开文件时，代码会重新给 `fp` 赋值：  
```c
fp = fopen("demo.txt", "r");  // 这里会覆盖之前的 NULL 值
```  

`fopen` 会根据文件打开的结果返回一个新的有效地址（成功时）或 `NULL`（失败时），与之前的 `fp = NULL` 没有关系。  

简单说：`fp = NULL` 只是“清空当前指针”，不影响后续对 `fp` 的重新赋值。
*/