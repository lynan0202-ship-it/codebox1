// ------------------------------  
// 题干：生成100个1~10范围内的随机数，并以降序排列。  
// 知识要点：  
//  1. 随机数生成（rand() % 10 + 1 → 1-10）  
//  2. 排序算法（冒泡排序，降序实现）  
//  3. 数组操作（存储随机数，遍历修改）  
// 总体逻辑：  
//  1. 定义数组存储100个随机数  
//  2. 生成随机数并填充数组  
//  3. 冒泡排序降序排列（相邻元素比较，大的放前面）  
//  4. 输出排序后的数组（前10个示例，避免过长）  
#include <stdio.h>  
#include <stdlib.h> // 包含 rand()  

int main() {  
    int nums[100]; // 存储100个随机数  

    // 1. 生成随机数（1-10）  
    for (int i = 0; i < 100; i++) {  
        nums[i] = rand() % 10 + 1; // rand()范围0~RAND_MAX，取模10得0~9，+1后1~10  
    }  

    // 2. 冒泡排序（降序：大的元素往前移）  
    for (int i = 0; i < 99; i++) { // 外层循环：比较轮次  
        for (int j = 0; j < 99 - i; j++) { // 内层循环：每轮比较的元素对  
            if (nums[j] < nums[j+1]) { // 降序：如果前数 < 后数，交换  
                int temp = nums[j];  
                nums[j] = nums[j+1];  
                nums[j+1] = temp;  
            }  
        }  
    }  

    // 3. 输出结果（前10个示例，方便查看）  
    printf("降序排列的前10个随机数：\n");  
    for (int i = 0; i < 10; i++) {  
        printf("%d ", nums[i]);  
    }  
    printf("\n");  

    return 0;  
}  

// 测试验证方案：  
//  1. 怎么运行：编译后运行（如 `gcc 5.c -o 5 && ./5`），需注意：  
//     - rand()默认种子是1，每次运行随机数相同（若要真随机，需加 srand(time(0))，但本题未要求）  
//  2. 预期结果：  
//     - 输出10个降序排列的数（如 10 10 9 9 8 8 7 7 6 6，因随机数范围1-10，重复常见）  
//  3. 检查点：  
//     - 数是否在1-10之间？  
//     - 排列是否严格降序？（前数 ≥ 后数）  
// 易错点提醒：  
//  1. 随机数生成错误：写成 `rand() % 10`（会得到0-9，漏+1）  
//  2. 冒泡排序逻辑错误：内层循环条件写成 `j < 100`（导致越界，应是 `j < 99 - i`）  
//  3. 降序判断写反：`nums[j] > nums[j+1]`（会变成升序，需注意符号）  
// 拓展思考：  
//  1. 如何优化排序效率？（比如改用快速排序）  
//  2. 如果要生成1-100的随机数，只需修改 `% 100 + 1`  
// 对比说明：  
//  降序冒泡 vs 升序冒泡：  
//  - 升序：`if (nums[j] > nums[j+1])` 交换  
//  - 降序：`if (nums[j] < nums[j+1])` 交换（核心是比较符号的差异）  
