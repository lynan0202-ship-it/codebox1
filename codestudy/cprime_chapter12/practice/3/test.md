// 测试验证方案：
//  1. 怎么运行：  
//     - 编译命令：`gcc pe12-2b.c pe12-2a.c -o fuel`（需同时编译两个文件）  
//     - 运行：`./fuel`  
//  2. 预期结果（示例）：  
//     → 输入`0` → 600 → 78.8 → 输出`13.13 liters per 100 km`  
//     → 输入`1` → 434 → 12.7 → 输出`34.2 miles per gallon`  
//     → 输入`3` → 提示`Invalid mode...`，使用上次模式（如1）→ 输入388 →15.3 → 输出`25.4 miles per gallon`  
//     → 输入`-1` → 输出`Done.`并退出  
//  3. 检查点：  
//     - 无效模式是否触发提示，且保留历史有效模式？  
//     - 公制/美制的计算结果是否符合公式？  
//     - 循环是否正确处理多次输入，直到-1退出？  


// 易错点提醒：  
//  1. 函数调用时忘记传指针（如`set_mode(data, input_mode)`，漏写`&`）：  
//     → 会导致函数操作**拷贝的结构体**，主函数的data不会被修改，逻辑错误！  
//  2. 结构体成员访问错误（如`data.current_mode` instead of `data->current_mode`）：  
//     → 指针必须用`->`，普通变量用`.`，混写会编译报错。  
//  3. 忘记初始化`data.current_mode`：  
//     → 若没调用`init_data`，初始值可能是随机数，导致模式判断错误。  


// 拓展思考：  
//  1. 如何记录历史油耗数据？  
//     → 主函数定义`FuelData history[100]; int count = 0;`，每次调用`show_info`后，将`data`存入`history[count++]`。  
//  2. 对比“全局变量”和“自动变量+指针”：  
//     - 全局变量：数据隐藏在文件内，函数直接访问，耦合度高。  
//     - 指针传递：数据在主函数，函数通过地址修改，逻辑更清晰，便于调试。  
//  3. 若要支持“同时计算公制和美制”，如何修改？  
//     → 在`show_info`里同时计算两种模式的结果，或添加参数控制输出。  


// 对比说明（指针传递 vs 全局变量）：  
//  | 特性                | 指针传递（当前方案）                     | 全局变量（原方案）               |  
//  |---------------------|------------------------------------------|----------------------------------|  
//  | 数据作用域          | 主函数内的自动变量，函数通过指针访问     | 文件作用域的静态变量             |  
//  | 代码耦合度          | 低（函数明确修改哪些数据）               | 高（多个函数直接操作全局变量）   |  
//  | 调试难度            | 易（跟踪指针即可定位修改）               | 难（需排查所有访问全局变量的函数）|  
//  | 扩展性              | 强（可扩展结构体，添加新数据）           | 弱（全局变量增多会导致冲突）     |  