// ------------------------------
// 题干：主程序，处理模式输入循环，调用pe12-2a的函数完成油耗计算
// 知识要点：
//  1. 循环结构（直到输入-1退出）
//  2. 函数调用（协同pe12-2a.c的逻辑）
// 总体逻辑：
//  1. 循环读取mode，调用set_mode处理模式
//  2. 若mode≠-1，调用get_info输入数据，show_info显示结果
//  3. 输入-1时，退出循环并输出Done.
#include <stdio.h>
#include "pe12-2a.h"

int main(void) {
    int mode;

    // 第一次输入模式
    printf("Enter 0 for metric mode, 1 for US mode (-1 to quit): ");
    scanf("%d", &mode);

    while (mode != -1) {       // -1时退出循环
        set_mode(mode);        // 设置模式（处理无效输入）
        get_info();            // 输入距离和燃料
        show_info();           // 计算并显示油耗

        // 下一轮输入
        printf("Enter 0 for metric mode, 1 for US mode (-1 to quit): ");
        scanf("%d", &mode);
    }

    printf("Done.\n");         // 退出提示
    return 0;
}

// 测试验证方案：
//  1. 怎么运行：编译命令 `gcc pe12-2b.c pe12-2a.c -o fuel`，运行./fuel
//  2. 预期结果：
//     - 无效模式触发提示，保留历史有效模式
//     - 公制/美制计算结果符合公式
//     - 输入-1后正常退出，输出Done.
//  3. 检查点：
//     - 循环是否正确处理多次输入？
//     - 退出逻辑是否正常？
// 易错点提醒：
//  1. 循环条件写错（如写成mode == -1，导致直接退出）
//  2. 忘记包含头文件"pe12-2a.h"，导致函数未声明报错
// 拓展思考：
//  1. 若要记录历史油耗数据（如最多10次），如何扩展？可在pe12-2a.c中添加静态数组存储
// 对比说明：
//  函数调用的“隐式数据共享” vs “显式传参”：
//  - 本题通过pe12-2a.c的static变量共享数据，减少参数传递，但耦合度较高
//  - 显式传参（如将数据封装为结构体传递）更灵活，但代码更复杂
//  两种设计各有优劣，本题因需求“文件作用域变量”，故采用前者