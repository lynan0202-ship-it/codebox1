### 一、核心知识要点提炼  
#### 1. 链接属性分类  
C 变量的 **3 种链接属性**：外部链接、内部链接、无链接。  

#### 2. 链接与作用域的关系  
- **无链接变量**：作用域为 **块作用域**（如函数内局部变量）、**函数作用域**（如 goto 标签）、**函数原型作用域**（如函数参数），属于定义它们的“私有域”。  
- **文件作用域变量**：作用域覆盖整个源文件，可细分为：  
  - **外部链接**：能被多文件程序共享（跨翻译单元访问）。  
  - **内部链接**：仅能在**一个翻译单元**（单个 .c 文件 + 其包含的头文件）内使用。  


### 二、目标段落逻辑梳理（因果/递进关系）  
1. **概念引入**：先明确“链接属性”是 C 变量的特性，分为三类。  
2. **作用域关联**：  
   - 无链接 → 块/函数/原型作用域（私有）；  
   - 文件作用域 → 外部/内部链接（共享 vs 私有）。  
3. **术语简化**：官方术语繁琐，程序员约定：  
   - “内部链接的文件作用域” → 简称 **文件作用域**（本文件私有）；  
   - “外部链接的文件作用域” → 简称 **全局/程序作用域**（跨文件共享）。  
4. **判断方法**：文件作用域变量中，**定义时加 `static` → 内部链接**；不加 → 外部链接。  
5. **代码验证**：通过 `giants`（外部链接）和 `dodgers`（内部链接）的示例，解释访问范围差异。  


### 三、编程知识点：代码示例与说明  
#### 示例场景  
演示 **外部链接**（跨文件共享）和 **内部链接**（本文件私有）的区别。  

##### 文件 1：`file1.c`  
```c
// 外部链接：默认不加 static，可被其他文件访问
int giants = 5;  

// 内部链接：加 static，仅本文件可用
static int dodgers = 3;  

void print_info() {
    // 本文件内可访问两者
    printf("giants: %d, dodgers: %d\n", giants, dodgers); 
}
```  

##### 文件 2：`file2.c`  
```c
#include <stdio.h>

// 声明外部链接变量（跨文件引用，不定义）
extern int giants;  

int main() {
    print_info(); // 调用 file1 的函数（需确保链接时关联）
    printf("giants (from file2): %d\n", giants);  

    // 错误：dodgers 是内部链接，file2 无法访问（编译器报错“未定义”）
    // printf("%d", dodgers);  

    return 0;
}
```  

##### 编译运行（GCC 示例）  
```bash
# 编译两个翻译单元
gcc -c file1.c file2.c  
# 链接生成可执行文件
gcc file1.o file2.o -o program  
# 运行输出：
# giants: 5, dodgers: 3  
# giants (from file2): 5  
```  

**说明**：  
- `giants` 无 `static`，是外部链接：`file2` 通过 `extern` 声明后可访问。  
- `dodgers` 加 `static`，是内部链接：仅 `file1` 内的函数（如 `print_info`）可访问，`file2` 无法引用。  


### 四、对比表格：外部链接 vs 内部链接  
| **对比维度**       | 外部链接变量                     | 内部链接变量                     |
|--------------------|----------------------------------|----------------------------------|
| **作用范围**       | 多翻译单元（跨文件共享）         | 单一翻译单元（本文件私有）       |
| **定义关键字**     | 默认（不加 `static`）            | 必须加 `static`                  |
| **跨文件访问方式** | 通过 `extern` 声明引用           | 无法跨文件访问                   |
| **存储特性**       | 静态存储（程序运行期常驻内存）   | 静态存储（同左）                 |
| **典型场景**       | 多文件共享的全局配置（如常量）   | 本文件内部使用的“隐藏数据”       |  


### 五、扩展知识点补充  
#### 1. 翻译单元的本质  
- 一个 **翻译单元** = 1 个 `.c` 文件 + 它 `#include` 的所有头文件（预处理后合并为一个单元）。  
- 链接阶段会合并所有翻译单元的符号，外部链接符号会被解析，内部链接符号仅在本单元可见。  

#### 2. 存储类别与链接的关联  
- `auto`/`register`：**自动存储**，无链接（块作用域）。  
- `static`：  
  - 修饰局部变量 → 静态存储，**无链接**（仅块内持久，仍私有）；  
  - 修饰文件作用域变量 → 改变链接属性为 **内部链接**（本翻译单元私有）。  
- `extern`：  
  - 修饰文件作用域变量 → 声明**外部链接**（不分配内存，仅引用其他单元的定义）。  

#### 3. 链接的工程意义  
- **外部链接**：实现多文件协作（如模块间共享状态）。  
- **内部链接**：隐藏实现细节（类似“封装”），避免同名变量冲突（如不同文件定义同名 `static` 变量不冲突）。  

#### 4. 链接错误场景  
- **未定义符号**：引用了外部链接变量，但其他单元未定义（如 `file2` 用 `extern int x`，但无文件定义 `x`）。  
- **重复定义**：多个翻译单元定义同名**外部链接**变量（链接器报“多重定义”错误），但同名**内部链接**变量可共存。  


通过以上梳理，可清晰掌握“链接属性”的核心逻辑、代码实践及工程应用！