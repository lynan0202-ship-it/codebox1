### 一、主题总结：C99 旧关键字的语法扩展（形参位置）  
1. **核心概念**：  
   - C99 允许 **类型限定符（`const`/`restrict`）** 和 **存储类 `static`** 出现在函数形参的**方括号**内，扩展语法表达能力。  
   - 新用法用于 **约束参数特性**（如 `const` 保护数据、`restrict` 唯一访问）或 **提示编译器优化**（如 `static` 约束数组长度）。  
2. **核心结论**：  
   - 形参的方括号内可写限定符，与指针写法等价（如 `int a[const]` ≡ `int *const a`）。  
   - `static` 在形参中不再仅表“静态存储”，还用于 **强制数组长度下限**（如 `a[static 20]` 要求数组至少 20 元素），辅助编译器优化。  


### 二、内容逻辑梳理（因果/递进）  
1. **语法扩展背景**：  
   C99 为函数形参提供更灵活的限定符写法，让代码更简洁，同时明确参数约束。  
2. **类型限定符的新位置**：  
   - **`const`/`restrict` 示例**：  
     旧写法（指针修饰）：`void func(int *const a1, int *restrict a2)`  
     新写法（方括号内）：`void func(int a1[const], int a2[restrict])`  
     两者等价：`a1` 是“指针本身只读”（`*const`），`a2` 是“唯一访问指针”（`restrict`）。  
3. **`static` 的新用法（形参方括号）**：  
   - 旧用法：`static` 修饰变量表“静态存储”（作用域/生命周期特殊）。  
   - 新用法：`void stick(double a[static 20])`，表示 **`a` 指向的数组至少有 20 个元素**（编译器可利用此信息优化，如数组越界检查提示）。  


### 三、编程示例（知识点：形参的新语法）  
#### 示例 1：`const` 和 `restrict` 的方括号写法  
```c
#include <stdio.h>

// 新写法：方括号内用 const/restrict
void printArray(int arr[const], int len[restrict]) {
    // arr[0] = 10; // 非法：arr 是“指向的值只读”（等价 const int *arr）
    // len = &len;  // 合法：len 是 restrict 指针（唯一访问，语法允许改指向，但逻辑上应唯一）
    for (int i=0; i<*len; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[] = {1,2,3,4};
    int len = 4;
    printArray(arr, &len); // 输出：1 2 3 4 
    return 0;
}
```  
**说明**：  
- `arr[const]` ≡ `const int *arr`：保证函数内不修改数组内容。  
- `len[restrict]` ≡ `int *restrict len`：提示编译器 `len` 是访问该整数的唯一指针，可优化。  


#### 示例 2：`static` 约束数组长度  
```c
#include <stdio.h>

// 要求：a 指向的数组至少有 5 个元素
double sumFirst5(double a[static 5]) {
    double total = 0;
    for (int i=0; i<5; i++) {
        total += a[i]; // 编译器可假设 a[0-4] 有效，放心优化
    }
    return total;
}

int main() {
    double arr[6] = {1.1, 2.2, 3.3, 4.4, 5.5, 6.6};
    printf("Sum: %.2f\n", sumFirst5(arr)); // 输出：16.50（1.1+2.2+3.3+4.4+5.5）
    
    // double arr2[3] = {1,2,3}; 
    // sumFirst5(arr2); // 编译器可能警告：数组长度不足 5（逻辑风险，非语法错误）
    return 0;
}
```  
**说明**：  
- `a[static 5]` 是“提示”而非强制：语法允许传短数组，但编译器会警示（逻辑风险），辅助开发者避免错误。  


### 四、对比表格（Markdown）  
#### 1. 类型限定符：旧写法 vs 新写法  
| 特性                | 旧写法（指针修饰）          | 新写法（方括号内）          | 等价关系                  |  
|---------------------|-----------------------------|-----------------------------|---------------------------|  
| 保护指针指向的值    | `const int *a`              | `int a[const]`              | 完全等价                  |  
| 标记唯一访问指针    | `int *restrict a`           | `int a[restrict]`           | 完全等价                  |  


#### 2. `static` 的旧用法 vs 新用法  
| 用法场景            | 旧用法（存储类）                     | 新用法（形参方括号）               | 核心区别                  |  
|---------------------|--------------------------------------|------------------------------------|---------------------------|  
| 修饰变量            | 表“静态存储”（作用域/生命周期特殊）  | 无（新用法仅用于形参方括号）       | 语义完全不同              |  
| 形参方括号内        | 不允许（旧标准）                     | `int a[static N]`（要求数组≥N元素）| 用于**数组长度约束**，辅助优化 |  


### 五、扩展知识点补充  
#### 1. `static` 新用法的细节  
- **编译器支持**：GCC、Clang 完全支持，MSVC 对 C99 特性支持有限（需开启 C99 模式）。  
- **优化效果**：编译器可假设数组长度≥N，提前做边界检查优化（如省略运行时检查），或更高效加载数据。  


#### 2. 类型限定符的组合限制  
- 方括号内的限定符 **只能是 `const`、`restrict`、`static`**（C99 规定），不能混合其他存储类（如 `auto` 无效）。  
- 多个限定符可共存：如 `int a[const restrict static 10]`（但实际场景少用，需清晰语义）。  


#### 3. 实践注意事项  
- **`static` 是“提示”而非强制**：传短数组不会编译报错（语法合法），但会引发逻辑错误，需开发者自律。  
- **与指针的兼容性**：形参的方括号写法本质是指针，如 `int a[5]` ≡ `int *a`，新写法只是**修饰指针的特性**，不改变“形参是指针”的本质。  




通过以上拆解，可清晰掌握 C99 对旧关键字（`const`/`restrict`/`static`）在函数形参中的语法扩展，结合示例和对比表，理解其用法、差异及实践价值。